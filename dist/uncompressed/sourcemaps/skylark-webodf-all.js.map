{"version":3,"sources":["skylark-webodf-all.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../skylark-webodf-all.js","sourcesContent":["define('skylark-langx-ns/_attach',[],function(){\r\n    return  function attach(obj1,path,obj2) {\r\n        if (typeof path == \"string\") {\r\n            path = path.split(\".\");//[path]\r\n        };\r\n        var length = path.length,\r\n            ns=obj1,\r\n            i=0,\r\n            name = path[i++];\r\n\r\n        while (i < length) {\r\n            ns = ns[name] = ns[name] || {};\r\n            name = path[i++];\r\n        }\r\n\r\n        ns[name] = obj2 || {};\r\n        return ns[name];\r\n    }\r\n});\ndefine('skylark-langx-ns/ns',[\r\n    \"./_attach\"\r\n], function(_attach) {\r\n    var skylark = {\r\n    \tattach : function(path,obj) {\r\n    \t\treturn _attach(skylark,path,obj);\r\n    \t}\r\n    };\r\n    return skylark;\r\n});\r\n\ndefine('skylark-langx-ns/main',[\r\n\t\"./ns\"\r\n],function(skylark){\r\n\treturn skylark;\r\n});\ndefine('skylark-langx-ns', ['skylark-langx-ns/main'], function (main) { return main; });\n\ndefine('skylark-webodf/webodf',[],function() {\n\tvar webodf_version = \"0.5.9\";\n\tfunction Runtime() {}\n\tRuntime.prototype.getVariable = function(g) {}\n\t;\n\tRuntime.prototype.toJson = function(g) {}\n\t;\n\tRuntime.prototype.fromJson = function(g) {}\n\t;\n\tRuntime.prototype.byteArrayFromString = function(g, k) {}\n\t;\n\tRuntime.prototype.byteArrayToString = function(g, k) {}\n\t;\n\tRuntime.prototype.read = function(g, k, d, b) {}\n\t;\n\tRuntime.prototype.readFile = function(g, k, d) {}\n\t;\n\tRuntime.prototype.readFileSync = function(g, k) {}\n\t;\n\tRuntime.prototype.loadXML = function(g, k) {}\n\t;\n\tRuntime.prototype.writeFile = function(g, k, d) {}\n\t;\n\tRuntime.prototype.deleteFile = function(g, k) {}\n\t;\n\tRuntime.prototype.log = function(g, k) {}\n\t;\n\tRuntime.prototype.setTimeout = function(g, k) {}\n\t;\n\tRuntime.prototype.clearTimeout = function(g) {}\n\t;\n\tRuntime.prototype.libraryPaths = function() {}\n\t;\n\tRuntime.prototype.currentDirectory = function() {}\n\t;\n\tRuntime.prototype.setCurrentDirectory = function(g) {}\n\t;\n\tRuntime.prototype.type = function() {}\n\t;\n\tRuntime.prototype.getDOMImplementation = function() {}\n\t;\n\tRuntime.prototype.parseXML = function(g) {}\n\t;\n\tRuntime.prototype.exit = function(g) {}\n\t;\n\tRuntime.prototype.getWindow = function() {}\n\t;\n\tRuntime.prototype.requestAnimationFrame = function(g) {}\n\t;\n\tRuntime.prototype.cancelAnimationFrame = function(g) {}\n\t;\n\tRuntime.prototype.assert = function(g, k) {}\n\t;\n\tvar IS_COMPILED_CODE = !0;\n\tRuntime.byteArrayToString = function(g, k) {\n\t    function d(b) {\n\t        var d = \"\", r, q = b.length;\n\t        for (r = 0; r < q; r += 1)\n\t            d += String.fromCharCode(b[r] & 255);\n\t        return d\n\t    }\n\t    function b(b) {\n\t        var d = \"\", r, q = b.length, e = [], l, a, c, m;\n\t        for (r = 3 <= q && 239 === b[0] && 187 === b[1] && 191 === b[2] ? 3 : 0; r < q; r += 1)\n\t            l = b[r],\n\t            128 > l ? e.push(l) : (r += 1,\n\t            a = b[r],\n\t            194 <= l && 224 > l ? e.push((l & 31) << 6 | a & 63) : (r += 1,\n\t            c = b[r],\n\t            224 <= l && 240 > l ? e.push((l & 15) << 12 | (a & 63) << 6 | c & 63) : (r += 1,\n\t            m = b[r],\n\t            240 <= l && 245 > l && (l = (l & 7) << 18 | (a & 63) << 12 | (c & 63) << 6 | m & 63,\n\t            l -= 65536,\n\t            e.push((l >> 10) + 55296, (l & 1023) + 56320))))),\n\t            1E3 <= e.length && (d += String.fromCharCode.apply(null, e),\n\t            e.length = 0);\n\t        return d + String.fromCharCode.apply(null, e)\n\t    }\n\t    var f;\n\t    \"utf8\" === k ? f = b(g) : (\"binary\" !== k && this.log(\"Unsupported encoding: \" + k),\n\t    f = d(g));\n\t    return f\n\t}\n\t;\n\tRuntime.getVariable = function(g) {\n\t    try {\n\t        return eval(g)\n\t    } catch (k) {}\n\t}\n\t;\n\tRuntime.toJson = function(g) {\n\t    return JSON.stringify(g)\n\t}\n\t;\n\tRuntime.fromJson = function(g) {\n\t    return JSON.parse(g)\n\t}\n\t;\n\tRuntime.getFunctionName = function(g) {\n\t    return void 0 === g.name ? (g = /function\\s+(\\w+)/.exec(g)) && g[1] : g.name\n\t}\n\t;\n\tRuntime.assert = function(g, k) {\n\t    if (!g)\n\t        throw this.log(\"alert\", \"ASSERTION FAILED:\\n\" + k),\n\t        Error(k);\n\t}\n\t;\n\tfunction BrowserRuntime() {\n\t    function g(b) {\n\t        var e = b.length, l, a, c = 0;\n\t        for (l = 0; l < e; l += 1)\n\t            a = b.charCodeAt(l),\n\t            c += 1 + (128 < a) + (2048 < a),\n\t            55040 < a && 57344 > a && (c += 1,\n\t            l += 1);\n\t        return c\n\t    }\n\t    function k(b, e, l) {\n\t        var a = b.length, c, m;\n\t        e = new Uint8Array(new ArrayBuffer(e));\n\t        l ? (e[0] = 239,\n\t        e[1] = 187,\n\t        e[2] = 191,\n\t        m = 3) : m = 0;\n\t        for (l = 0; l < a; l += 1)\n\t            c = b.charCodeAt(l),\n\t            128 > c ? (e[m] = c,\n\t            m += 1) : 2048 > c ? (e[m] = 192 | c >>> 6,\n\t            e[m + 1] = 128 | c & 63,\n\t            m += 2) : 55040 >= c || 57344 <= c ? (e[m] = 224 | c >>> 12 & 15,\n\t            e[m + 1] = 128 | c >>> 6 & 63,\n\t            e[m + 2] = 128 | c & 63,\n\t            m += 3) : (l += 1,\n\t            c = (c - 55296 << 10 | b.charCodeAt(l) - 56320) + 65536,\n\t            e[m] = 240 | c >>> 18 & 7,\n\t            e[m + 1] = 128 | c >>> 12 & 63,\n\t            e[m + 2] = 128 | c >>> 6 & 63,\n\t            e[m + 3] = 128 | c & 63,\n\t            m += 4);\n\t        return e\n\t    }\n\t    function d(b) {\n\t        var e = b.length, l = new Uint8Array(new ArrayBuffer(e)), a;\n\t        for (a = 0; a < e; a += 1)\n\t            l[a] = b.charCodeAt(a) & 255;\n\t        return l\n\t    }\n\t    function b(b, e) {\n\t        var l;\n\t        void 0 !== e ? l = b : e = b;\n\t        console.log(e);\n\t        r.enableAlerts && \"alert\" === l && alert(e)\n\t    }\n\t    function f(b, e, l) {\n\t        if (0 !== l.status || l.responseText)\n\t            if (200 === l.status || 0 === l.status) {\n\t                if (l.response && \"string\" !== typeof l.response)\n\t                    \"binary\" === e ? (l = l.response,\n\t                    l = new Uint8Array(l)) : l = String(l.response);\n\t                else if (\"binary\" === e)\n\t                    if (null !== l.responseBody && \"undefined\" !== String(typeof VBArray)) {\n\t                        l = (new VBArray(l.responseBody)).toArray();\n\t                        var a = l.length;\n\t                        e = new Uint8Array(new ArrayBuffer(a));\n\t                        for (b = 0; b < a; b += 1)\n\t                            e[b] = l[b];\n\t                        l = e\n\t                    } else {\n\t                        (b = l.getResponseHeader(\"Content-Length\")) && (b = parseInt(b, 10));\n\t                        if (b && b !== l.responseText.length)\n\t                            a: {\n\t                                a = l.responseText;\n\t                                e = !1;\n\t                                var c = g(a);\n\t                                if (\"number\" === typeof b) {\n\t                                    if (b !== c && b !== c + 3) {\n\t                                        a = void 0;\n\t                                        break a\n\t                                    }\n\t                                    e = c + 3 === b;\n\t                                    c = b\n\t                                }\n\t                                a = k(a, c, e)\n\t                            }\n\t                        void 0 === a && (a = d(l.responseText));\n\t                        l = a\n\t                    }\n\t                else\n\t                    l = l.responseText;\n\t                l = {\n\t                    err: null,\n\t                    data: l\n\t                }\n\t            } else\n\t                l = {\n\t                    err: l.responseText || l.statusText,\n\t                    data: null\n\t                };\n\t        else\n\t            l = {\n\t                err: \"File \" + b + \" is empty.\",\n\t                data: null\n\t            };\n\t        return l\n\t    }\n\t    function n(b, e, l) {\n\t        var a = new XMLHttpRequest;\n\t        a.open(\"GET\", b, l);\n\t        a.overrideMimeType && (\"binary\" !== e ? a.overrideMimeType(\"text/plain; charset=\" + e) : a.overrideMimeType(\"text/plain; charset=x-user-defined\"));\n\t        return a\n\t    }\n\t    function p(b, e, l) {\n\t        var a = n(b, e, !0);\n\t        a.onreadystatechange = function() {\n\t            var c;\n\t            4 === a.readyState && (c = f(b, e, a),\n\t            l(c.err, c.data))\n\t        }\n\t        ;\n\t        try {\n\t            a.send(null)\n\t        } catch (c) {\n\t            l(c.message, null)\n\t        }\n\t    }\n\t    var r = this;\n\t    this.byteArrayFromString = function(b, e) {\n\t        var l;\n\t        \"utf8\" === e ? l = k(b, g(b), !1) : (\"binary\" !== e && r.log(\"unknown encoding: \" + e),\n\t        l = d(b));\n\t        return l\n\t    }\n\t    ;\n\t    this.byteArrayToString = Runtime.byteArrayToString;\n\t    this.getVariable = Runtime.getVariable;\n\t    this.fromJson = Runtime.fromJson;\n\t    this.toJson = Runtime.toJson;\n\t    this.readFile = p;\n\t    this.read = function(b, e, l, a) {\n\t        p(b, \"binary\", function(c, m) {\n\t            var h = null;\n\t            if (m) {\n\t                if (\"string\" === typeof m)\n\t                    throw \"This should not happen.\";\n\t                h = m.subarray(e, e + l)\n\t            }\n\t            a(c, h)\n\t        })\n\t    }\n\t    ;\n\t    this.readFileSync = function(b, e) {\n\t        var l = n(b, e, !1), a;\n\t        try {\n\t            l.send(null);\n\t            a = f(b, e, l);\n\t            if (a.err)\n\t                throw a.err;\n\t            if (null === a.data)\n\t                throw \"No data read from \" + b + \".\";\n\t        } catch (c) {\n\t            throw c;\n\t        }\n\t        return a.data\n\t    }\n\t    ;\n\t    this.writeFile = function(b, e, l) {\n\t        var a = new XMLHttpRequest, c;\n\t        a.open(\"PUT\", b, !0);\n\t        a.onreadystatechange = function() {\n\t            4 === a.readyState && (0 !== a.status || a.responseText ? 200 <= a.status && 300 > a.status || 0 === a.status ? l(null) : l(\"Status \" + String(a.status) + \": \" + a.responseText || a.statusText) : l(\"File \" + b + \" is empty.\"))\n\t        }\n\t        ;\n\t        c = e.buffer && !a.sendAsBinary ? e.buffer : r.byteArrayToString(e, \"binary\");\n\t        try {\n\t            a.sendAsBinary ? a.sendAsBinary(c) : a.send(c)\n\t        } catch (m) {\n\t            r.log(\"HUH? \" + m + \" \" + e),\n\t            l(m.message)\n\t        }\n\t    }\n\t    ;\n\t    this.deleteFile = function(b, e) {\n\t        var l = new XMLHttpRequest;\n\t        l.open(\"DELETE\", b, !0);\n\t        l.onreadystatechange = function() {\n\t            4 === l.readyState && (200 > l.status && 300 <= l.status ? e(l.responseText) : e(null))\n\t        }\n\t        ;\n\t        l.send(null)\n\t    }\n\t    ;\n\t    this.loadXML = function(b, e) {\n\t        var l = new XMLHttpRequest;\n\t        l.open(\"GET\", b, !0);\n\t        l.overrideMimeType && l.overrideMimeType(\"text/xml\");\n\t        l.onreadystatechange = function() {\n\t            4 === l.readyState && (0 !== l.status || l.responseText ? 200 === l.status || 0 === l.status ? e(null, l.responseXML) : e(l.responseText, null) : e(\"File \" + b + \" is empty.\", null))\n\t        }\n\t        ;\n\t        try {\n\t            l.send(null)\n\t        } catch (a) {\n\t            e(a.message, null)\n\t        }\n\t    }\n\t    ;\n\t    this.log = b;\n\t    this.enableAlerts = !0;\n\t    this.assert = Runtime.assert;\n\t    this.setTimeout = function(b, e) {\n\t        return setTimeout(function() {\n\t            b()\n\t        }, e)\n\t    }\n\t    ;\n\t    this.clearTimeout = function(b) {\n\t        clearTimeout(b)\n\t    }\n\t    ;\n\t    this.libraryPaths = function() {\n\t        return [\"lib\"]\n\t    }\n\t    ;\n\t    this.setCurrentDirectory = function() {}\n\t    ;\n\t    this.currentDirectory = function() {\n\t        return \"\"\n\t    }\n\t    ;\n\t    this.type = function() {\n\t        return \"BrowserRuntime\"\n\t    }\n\t    ;\n\t    this.getDOMImplementation = function() {\n\t        return window.document.implementation\n\t    }\n\t    ;\n\t    this.parseXML = function(b) {\n\t        return (new DOMParser).parseFromString(b, \"text/xml\")\n\t    }\n\t    ;\n\t    this.exit = function(d) {\n\t        b(\"Calling exit with code \" + String(d) + \", but exit() is not implemented.\")\n\t    }\n\t    ;\n\t    this.getWindow = function() {\n\t        return window\n\t    }\n\t    ;\n\t    this.requestAnimationFrame = function(b) {\n\t        var e = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame\n\t          , l = 0;\n\t        if (e)\n\t            e.bind(window),\n\t            l = e(b);\n\t        else\n\t            return setTimeout(b, 15);\n\t        return l\n\t    }\n\t    ;\n\t    this.cancelAnimationFrame = function(b) {\n\t        var e = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.msCancelAnimationFrame;\n\t        e ? (e.bind(window),\n\t        e(b)) : clearTimeout(b)\n\t    }\n\t}\n\tfunction NodeJSRuntime() {\n\t    function g(b) {\n\t        var e = b.length, l, a = new Uint8Array(new ArrayBuffer(e));\n\t        for (l = 0; l < e; l += 1)\n\t            a[l] = b[l];\n\t        return a\n\t    }\n\t    function k(d, e, l) {\n\t        function a(a, m) {\n\t            if (a)\n\t                return l(a, null);\n\t            if (!m)\n\t                return l(\"No data for \" + d + \".\", null);\n\t            if (\"string\" === typeof m)\n\t                return l(a, m);\n\t            l(a, g(m))\n\t        }\n\t        d = f.resolve(n, d);\n\t        \"binary\" !== e ? b.readFile(d, e, a) : b.readFile(d, null, a)\n\t    }\n\t    var d = this, b = require(\"fs\"), f = require(\"path\"), n = \"\", p, r;\n\t    this.byteArrayFromString = function(b, e) {\n\t        var l = new Buffer(b,e), a, c = l.length, m = new Uint8Array(new ArrayBuffer(c));\n\t        for (a = 0; a < c; a += 1)\n\t            m[a] = l[a];\n\t        return m\n\t    }\n\t    ;\n\t    this.byteArrayToString = Runtime.byteArrayToString;\n\t    this.getVariable = Runtime.getVariable;\n\t    this.fromJson = Runtime.fromJson;\n\t    this.toJson = Runtime.toJson;\n\t    this.readFile = k;\n\t    this.loadXML = function(b, e) {\n\t        k(b, \"utf-8\", function(l, a) {\n\t            if (l)\n\t                return e(l, null);\n\t            if (!a)\n\t                return e(\"No data for \" + b + \".\", null);\n\t            e(null, d.parseXML(a))\n\t        })\n\t    }\n\t    ;\n\t    this.writeFile = function(d, e, l) {\n\t        e = new Buffer(e);\n\t        d = f.resolve(n, d);\n\t        b.writeFile(d, e, \"binary\", function(a) {\n\t            l(a || null)\n\t        })\n\t    }\n\t    ;\n\t    this.deleteFile = function(d, e) {\n\t        d = f.resolve(n, d);\n\t        b.unlink(d, e)\n\t    }\n\t    ;\n\t    this.read = function(d, e, l, a) {\n\t        d = f.resolve(n, d);\n\t        b.open(d, \"r+\", 666, function(c, m) {\n\t            if (c)\n\t                a(c, null);\n\t            else {\n\t                var h = new Buffer(l);\n\t                b.read(m, h, 0, l, e, function(c) {\n\t                    b.close(m);\n\t                    a(c, g(h))\n\t                })\n\t            }\n\t        })\n\t    }\n\t    ;\n\t    this.readFileSync = function(d, e) {\n\t        var l;\n\t        l = b.readFileSync(d, \"binary\" === e ? null : e);\n\t        if (null === l)\n\t            throw \"File \" + d + \" could not be read.\";\n\t        \"binary\" === e && (l = g(l));\n\t        return l\n\t    }\n\t    ;\n\t    this.log = function(b, e) {\n\t        var l;\n\t        void 0 !== e ? l = b : e = b;\n\t        \"alert\" === l && process.stderr.write(\"\\n!!!!! ALERT !!!!!\\n\");\n\t        process.stderr.write(e + \"\\n\");\n\t        \"alert\" === l && process.stderr.write(\"!!!!! ALERT !!!!!\\n\")\n\t    }\n\t    ;\n\t    this.assert = Runtime.assert;\n\t    this.setTimeout = function(b, e) {\n\t        return setTimeout(function() {\n\t            b()\n\t        }, e)\n\t    }\n\t    ;\n\t    this.clearTimeout = function(b) {\n\t        clearTimeout(b)\n\t    }\n\t    ;\n\t    this.libraryPaths = function() {\n\t        return [__dirname]\n\t    }\n\t    ;\n\t    this.setCurrentDirectory = function(b) {\n\t        n = b\n\t    }\n\t    ;\n\t    this.currentDirectory = function() {\n\t        return n\n\t    }\n\t    ;\n\t    this.type = function() {\n\t        return \"NodeJSRuntime\"\n\t    }\n\t    ;\n\t    this.getDOMImplementation = function() {\n\t        return r\n\t    }\n\t    ;\n\t    this.parseXML = function(b) {\n\t        return p.parseFromString(b, \"text/xml\")\n\t    }\n\t    ;\n\t    this.exit = process.exit;\n\t    this.getWindow = function() {\n\t        return null\n\t    }\n\t    ;\n\t    this.requestAnimationFrame = function(b) {\n\t        return setTimeout(b, 15)\n\t    }\n\t    ;\n\t    this.cancelAnimationFrame = function(b) {\n\t        clearTimeout(b)\n\t    }\n\t    ;\n\t    p = new (require(\"xmldom\").DOMParser);\n\t    r = d.parseXML(\"<a/>\").implementation\n\t}\n\tfunction RhinoRuntime() {\n\t    var g = this, k = {}, d = k.javax.xml.parsers.DocumentBuilderFactory.newInstance(), b, f, n = \"\";\n\t    d.setValidating(!1);\n\t    d.setNamespaceAware(!0);\n\t    d.setExpandEntityReferences(!1);\n\t    d.setSchema(null);\n\t    f = k.org.xml.sax.EntityResolver({\n\t        resolveEntity: function(b, d) {\n\t            var f = new k.java.io.FileReader(d);\n\t            return new k.org.xml.sax.InputSource(f)\n\t        }\n\t    });\n\t    b = d.newDocumentBuilder();\n\t    b.setEntityResolver(f);\n\t    this.byteArrayFromString = function(b, d) {\n\t        var f, e = b.length, l = new Uint8Array(new ArrayBuffer(e));\n\t        for (f = 0; f < e; f += 1)\n\t            l[f] = b.charCodeAt(f) & 255;\n\t        return l\n\t    }\n\t    ;\n\t    this.byteArrayToString = Runtime.byteArrayToString;\n\t    this.getVariable = Runtime.getVariable;\n\t    this.fromJson = Runtime.fromJson;\n\t    this.toJson = Runtime.toJson;\n\t    this.loadXML = function(d, f) {\n\t        var n = new k.java.io.File(d)\n\t          , e = null;\n\t        try {\n\t            e = b.parse(n)\n\t        } catch (l) {\n\t            return print(l),\n\t            f(l, null)\n\t        }\n\t        f(null, e)\n\t    }\n\t    ;\n\t    this.readFile = function(b, d, f) {\n\t        n && (b = n + \"/\" + b);\n\t        var e = new k.java.io.File(b)\n\t          , l = \"binary\" === d ? \"latin1\" : d;\n\t        e.isFile() ? ((b = readFile(b, l)) && \"binary\" === d && (b = g.byteArrayFromString(b, \"binary\")),\n\t        f(null, b)) : f(b + \" is not a file.\", null)\n\t    }\n\t    ;\n\t    this.writeFile = function(b, d, f) {\n\t        n && (b = n + \"/\" + b);\n\t        b = new k.java.io.FileOutputStream(b);\n\t        var e, l = d.length;\n\t        for (e = 0; e < l; e += 1)\n\t            b.write(d[e]);\n\t        b.close();\n\t        f(null)\n\t    }\n\t    ;\n\t    this.deleteFile = function(b, d) {\n\t        n && (b = n + \"/\" + b);\n\t        var f = new k.java.io.File(b)\n\t          , e = b + Math.random()\n\t          , e = new k.java.io.File(e);\n\t        f.rename(e) ? (e.deleteOnExit(),\n\t        d(null)) : d(\"Could not delete \" + b)\n\t    }\n\t    ;\n\t    this.read = function(b, d, f, e) {\n\t        n && (b = n + \"/\" + b);\n\t        var l;\n\t        l = b;\n\t        var a = \"binary\";\n\t        (new k.java.io.File(l)).isFile() ? (\"binary\" === a && (a = \"latin1\"),\n\t        l = readFile(l, a)) : l = null;\n\t        l ? e(null, this.byteArrayFromString(l.substring(d, d + f), \"binary\")) : e(\"Cannot read \" + b, null)\n\t    }\n\t    ;\n\t    this.readFileSync = function(b, d) {\n\t        if (!d)\n\t            return \"\";\n\t        var f = readFile(b, d);\n\t        if (null === f)\n\t            throw \"File could not be read.\";\n\t        return f\n\t    }\n\t    ;\n\t    this.log = function(b, d) {\n\t        var f;\n\t        void 0 !== d ? f = b : d = b;\n\t        \"alert\" === f && print(\"\\n!!!!! ALERT !!!!!\");\n\t        print(d);\n\t        \"alert\" === f && print(\"!!!!! ALERT !!!!!\")\n\t    }\n\t    ;\n\t    this.assert = Runtime.assert;\n\t    this.setTimeout = function(b) {\n\t        b();\n\t        return 0\n\t    }\n\t    ;\n\t    this.clearTimeout = function() {}\n\t    ;\n\t    this.libraryPaths = function() {\n\t        return [\"lib\"]\n\t    }\n\t    ;\n\t    this.setCurrentDirectory = function(b) {\n\t        n = b\n\t    }\n\t    ;\n\t    this.currentDirectory = function() {\n\t        return n\n\t    }\n\t    ;\n\t    this.type = function() {\n\t        return \"RhinoRuntime\"\n\t    }\n\t    ;\n\t    this.getDOMImplementation = function() {\n\t        return b.getDOMImplementation()\n\t    }\n\t    ;\n\t    this.parseXML = function(d) {\n\t        d = new k.java.io.StringReader(d);\n\t        d = new k.org.xml.sax.InputSource(d);\n\t        return b.parse(d)\n\t    }\n\t    ;\n\t    this.exit = quit;\n\t    this.getWindow = function() {\n\t        return null\n\t    }\n\t    ;\n\t    this.requestAnimationFrame = function(b) {\n\t        b();\n\t        return 0\n\t    }\n\t    ;\n\t    this.cancelAnimationFrame = function() {}\n\t}\n\tRuntime.create = function() {\n\t    return \"undefined\" !== String(typeof window) ? new BrowserRuntime : \"undefined\" !== String(typeof require) ? new NodeJSRuntime : new RhinoRuntime\n\t}\n\t;\n\tvar runtime = Runtime.create()\n\t  , core = {}\n\t  , gui = {}\n\t  , xmldom = {}\n\t  , odf = {}\n\t  , ops = {}\n\t  , webodf = {};\n\t(function() {\n\t    webodf.Version = \"undefined\" !== String(typeof webodf_version) ? webodf_version : \"From Source\"\n\t}\n\t)();\n\t(function() {\n\t    function g(b, d, e) {\n\t        var l = b + \"/manifest.json\", a, c;\n\t        runtime.log(\"Loading manifest: \" + l);\n\t        try {\n\t            a = runtime.readFileSync(l, \"utf-8\")\n\t        } catch (m) {\n\t            if (e)\n\t                runtime.log(\"No loadable manifest found.\");\n\t            else\n\t                throw console.log(String(m)),\n\t                m;\n\t            return\n\t        }\n\t        e = JSON.parse(a);\n\t        for (c in e)\n\t            e.hasOwnProperty(c) && (d[c] = {\n\t                dir: b,\n\t                deps: e[c]\n\t            })\n\t    }\n\t    function k(b, d, e) {\n\t        function l(h) {\n\t            if (!m[h] && !e(h)) {\n\t                if (c[h])\n\t                    throw \"Circular dependency detected for \" + h + \".\";\n\t                c[h] = !0;\n\t                if (!d[h])\n\t                    throw \"Missing dependency information for class \" + h + \".\";\n\t                var b = d[h], f = b.deps, n, r = f.length;\n\t                for (n = 0; n < r; n += 1)\n\t                    l(f[n]);\n\t                c[h] = !1;\n\t                m[h] = !0;\n\t                a.push(b.dir + \"/\" + h.replace(\".\", \"/\") + \".js\")\n\t            }\n\t        }\n\t        var a = []\n\t          , c = {}\n\t          , m = {};\n\t        b.forEach(l);\n\t        return a\n\t    }\n\t    function d(b, d) {\n\t        return d + (\"\\n//# sourceURL=\" + b)\n\t    }\n\t    function b(b) {\n\t        var f, e;\n\t        for (f = 0; f < b.length; f += 1)\n\t            e = runtime.readFileSync(b[f], \"utf-8\"),\n\t            e = d(b[f], e),\n\t            eval(e)\n\t    }\n\t    function f(b) {\n\t        b = b.split(\".\");\n\t        var d, e = p, l = b.length;\n\t        for (d = 0; d < l; d += 1) {\n\t            if (!e.hasOwnProperty(b[d]))\n\t                return !1;\n\t            e = e[b[d]]\n\t        }\n\t        return !0\n\t    }\n\t    var n, p = {\n\t        core: core,\n\t        gui: gui,\n\t        xmldom: xmldom,\n\t        odf: odf,\n\t        ops: ops\n\t    };\n\t    runtime.loadClasses = function(d, p) {\n\t        if (IS_COMPILED_CODE || 0 === d.length)\n\t            return p && p();\n\t        var e;\n\t        if (!(e = n)) {\n\t            e = [];\n\t            var l = runtime.libraryPaths(), a;\n\t            runtime.currentDirectory() && -1 === l.indexOf(runtime.currentDirectory()) && g(runtime.currentDirectory(), e, !0);\n\t            for (a = 0; a < l.length; a += 1)\n\t                g(l[a], e)\n\t        }\n\t        n = e;\n\t        d = k(d, n, f);\n\t        if (0 === d.length)\n\t            return p && p();\n\t        if (\"BrowserRuntime\" === runtime.type() && p) {\n\t            e = d;\n\t            l = document.currentScript || document.documentElement.lastChild;\n\t            a = document.createDocumentFragment();\n\t            var c, m;\n\t            for (m = 0; m < e.length; m += 1)\n\t                c = document.createElement(\"script\"),\n\t                c.type = \"text/javascript\",\n\t                c.charset = \"utf-8\",\n\t                c.async = !1,\n\t                c.setAttribute(\"src\", e[m]),\n\t                a.appendChild(c);\n\t            p && (c.onload = p);\n\t            l.parentNode.insertBefore(a, l)\n\t        } else\n\t            b(d),\n\t            p && p()\n\t    }\n\t    ;\n\t    runtime.loadClass = function(b, d) {\n\t        runtime.loadClasses([b], d)\n\t    }\n\t}\n\t)();\n\t(function() {\n\t    var g = function(g) {\n\t        return g\n\t    };\n\t    runtime.getTranslator = function() {\n\t        return g\n\t    }\n\t    ;\n\t    runtime.setTranslator = function(k) {\n\t        g = k\n\t    }\n\t    ;\n\t    runtime.tr = function(k) {\n\t        var d = g(k);\n\t        return d && \"string\" === String(typeof d) ? d : k\n\t    }\n\t}\n\t)();\n\t(function(g) {\n\t    function k(d) {\n\t        if (d.length) {\n\t            var b = d[0];\n\t            runtime.readFile(b, \"utf8\", function(f, n) {\n\t                function g() {\n\t                    var b;\n\t                    (b = eval(k)) && runtime.exit(b)\n\t                }\n\t                var r = \"\"\n\t                  , r = b.lastIndexOf(\"/\")\n\t                  , k = n\n\t                  , r = -1 !== r ? b.substring(0, r) : \".\";\n\t                runtime.setCurrentDirectory(r);\n\t                f ? (runtime.log(f),\n\t                runtime.exit(1)) : null === k ? (runtime.log(\"No code found for \" + b),\n\t                runtime.exit(1)) : g.apply(null, d)\n\t            })\n\t        }\n\t    }\n\t    g = g ? Array.prototype.slice.call(g) : [];\n\t    \"NodeJSRuntime\" === runtime.type() ? k(process.argv.slice(2)) : \"RhinoRuntime\" === runtime.type() ? k(g) : k(g.slice(1))\n\t}\n\t)(\"undefined\" !== String(typeof arguments) && arguments);\n\t(function() {\n\t    core.Async = function() {\n\t        return {\n\t            forEach: function(g, k, d) {\n\t                function b(b) {\n\t                    p !== n && (b ? (p = n,\n\t                    d(b)) : (p += 1,\n\t                    p === n && d(null)))\n\t                }\n\t                var f, n = g.length, p = 0;\n\t                for (f = 0; f < n; f += 1)\n\t                    k(g[f], b)\n\t            },\n\t            destroyAll: function(g, k) {\n\t                function d(b, f) {\n\t                    if (f)\n\t                        k(f);\n\t                    else if (b < g.length)\n\t                        g[b](function(f) {\n\t                            d(b + 1, f)\n\t                        });\n\t                    else\n\t                        k()\n\t                }\n\t                d(0, void 0)\n\t            }\n\t        }\n\t    }()\n\t}\n\t)();\n\tfunction makeBase64() {\n\t    function g(a) {\n\t        var c, m = a.length, h = new Uint8Array(new ArrayBuffer(m));\n\t        for (c = 0; c < m; c += 1)\n\t            h[c] = a.charCodeAt(c) & 255;\n\t        return h\n\t    }\n\t    function k(a) {\n\t        var c, m = \"\", h, b = a.length - 2;\n\t        for (h = 0; h < b; h += 3)\n\t            c = a[h] << 16 | a[h + 1] << 8 | a[h + 2],\n\t            m += \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"[c >>> 18],\n\t            m += \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"[c >>> 12 & 63],\n\t            m += \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"[c >>> 6 & 63],\n\t            m += \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"[c & 63];\n\t        h === b + 1 ? (c = a[h] << 4,\n\t        m += \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"[c >>> 6],\n\t        m += \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"[c & 63],\n\t        m += \"==\") : h === b && (c = a[h] << 10 | a[h + 1] << 2,\n\t        m += \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"[c >>> 12],\n\t        m += \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"[c >>> 6 & 63],\n\t        m += \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"[c & 63],\n\t        m += \"=\");\n\t        return m\n\t    }\n\t    function d(a) {\n\t        a = a.replace(/[^A-Za-z0-9+\\/]+/g, \"\");\n\t        var c = a.length, m = new Uint8Array(new ArrayBuffer(3 * c)), b = a.length % 4, d = 0, l, e;\n\t        for (l = 0; l < c; l += 4)\n\t            e = (h[a.charAt(l)] || 0) << 18 | (h[a.charAt(l + 1)] || 0) << 12 | (h[a.charAt(l + 2)] || 0) << 6 | (h[a.charAt(l + 3)] || 0),\n\t            m[d] = e >> 16,\n\t            m[d + 1] = e >> 8 & 255,\n\t            m[d + 2] = e & 255,\n\t            d += 3;\n\t        c = 3 * c - [0, 0, 2, 1][b];\n\t        return m.subarray(0, c)\n\t    }\n\t    function b(a) {\n\t        var c, m, h = a.length, b = 0, d = new Uint8Array(new ArrayBuffer(3 * h));\n\t        for (c = 0; c < h; c += 1)\n\t            m = a[c],\n\t            128 > m ? d[b++] = m : (2048 > m ? d[b++] = 192 | m >>> 6 : (d[b++] = 224 | m >>> 12 & 15,\n\t            d[b++] = 128 | m >>> 6 & 63),\n\t            d[b++] = 128 | m & 63);\n\t        return d.subarray(0, b)\n\t    }\n\t    function f(a) {\n\t        var c, m, h, b, d = a.length, l = new Uint8Array(new ArrayBuffer(d)), e = 0;\n\t        for (c = 0; c < d; c += 1)\n\t            m = a[c],\n\t            128 > m ? l[e++] = m : (c += 1,\n\t            h = a[c],\n\t            224 > m ? l[e++] = (m & 31) << 6 | h & 63 : (c += 1,\n\t            b = a[c],\n\t            l[e++] = (m & 15) << 12 | (h & 63) << 6 | b & 63));\n\t        return l.subarray(0, e)\n\t    }\n\t    function n(a) {\n\t        return k(g(a))\n\t    }\n\t    function p(a) {\n\t        return String.fromCharCode.apply(String, d(a))\n\t    }\n\t    function r(a) {\n\t        return f(g(a))\n\t    }\n\t    function q(a) {\n\t        a = f(a);\n\t        for (var c = \"\", m = 0; m < a.length; )\n\t            c += String.fromCharCode.apply(String, a.subarray(m, m + 45E3)),\n\t            m += 45E3;\n\t        return c\n\t    }\n\t    function e(a, c, m) {\n\t        var h, b, d, l = \"\";\n\t        for (d = c; d < m; d += 1)\n\t            c = a.charCodeAt(d) & 255,\n\t            128 > c ? l += String.fromCharCode(c) : (d += 1,\n\t            h = a.charCodeAt(d) & 255,\n\t            224 > c ? l += String.fromCharCode((c & 31) << 6 | h & 63) : (d += 1,\n\t            b = a.charCodeAt(d) & 255,\n\t            l += String.fromCharCode((c & 15) << 12 | (h & 63) << 6 | b & 63)));\n\t        return l\n\t    }\n\t    function l(a, c) {\n\t        function m() {\n\t            var d = b + 1E5;\n\t            d > a.length && (d = a.length);\n\t            h += e(a, b, d);\n\t            b = d;\n\t            d = b === a.length;\n\t            c(h, d) && !d && runtime.setTimeout(m, 0)\n\t        }\n\t        var h = \"\"\n\t          , b = 0;\n\t        1E5 > a.length ? c(e(a, 0, a.length), !0) : (\"string\" !== typeof a && (a = a.slice()),\n\t        m())\n\t    }\n\t    function a(a) {\n\t        return b(g(a))\n\t    }\n\t    function c(a) {\n\t        return String.fromCharCode.apply(String, b(a))\n\t    }\n\t    function m(a) {\n\t        return String.fromCharCode.apply(String, b(g(a)))\n\t    }\n\t    var h = function(a) {\n\t        var c = {}, m, h;\n\t        m = 0;\n\t        for (h = a.length; m < h; m += 1)\n\t            c[a.charAt(m)] = m;\n\t        return c\n\t    }(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"), y, x, z = runtime.getWindow(), w, v;\n\t    z && z.btoa ? (w = z.btoa,\n\t    y = function(a) {\n\t        return w(m(a))\n\t    }\n\t    ) : (w = n,\n\t    y = function(c) {\n\t        return k(a(c))\n\t    }\n\t    );\n\t    z && z.atob ? (v = z.atob,\n\t    x = function(a) {\n\t        a = v(a);\n\t        return e(a, 0, a.length)\n\t    }\n\t    ) : (v = p,\n\t    x = function(a) {\n\t        return q(d(a))\n\t    }\n\t    );\n\t    core.Base64 = function() {\n\t        this.convertByteArrayToBase64 = this.convertUTF8ArrayToBase64 = k;\n\t        this.convertBase64ToByteArray = this.convertBase64ToUTF8Array = d;\n\t        this.convertUTF16ArrayToByteArray = this.convertUTF16ArrayToUTF8Array = b;\n\t        this.convertByteArrayToUTF16Array = this.convertUTF8ArrayToUTF16Array = f;\n\t        this.convertUTF8StringToBase64 = n;\n\t        this.convertBase64ToUTF8String = p;\n\t        this.convertUTF8StringToUTF16Array = r;\n\t        this.convertByteArrayToUTF16String = this.convertUTF8ArrayToUTF16String = q;\n\t        this.convertUTF8StringToUTF16String = l;\n\t        this.convertUTF16StringToByteArray = this.convertUTF16StringToUTF8Array = a;\n\t        this.convertUTF16ArrayToUTF8String = c;\n\t        this.convertUTF16StringToUTF8String = m;\n\t        this.convertUTF16StringToBase64 = y;\n\t        this.convertBase64ToUTF16String = x;\n\t        this.fromBase64 = p;\n\t        this.toBase64 = n;\n\t        this.atob = v;\n\t        this.btoa = w;\n\t        this.utob = m;\n\t        this.btou = l;\n\t        this.encode = y;\n\t        this.encodeURI = function(a) {\n\t            return y(a).replace(/[+\\/]/g, function(a) {\n\t                return \"+\" === a ? \"-\" : \"_\"\n\t            }).replace(/\\\\=+$/, \"\")\n\t        }\n\t        ;\n\t        this.decode = function(a) {\n\t            return x(a.replace(/[\\-_]/g, function(a) {\n\t                return \"-\" === a ? \"+\" : \"/\"\n\t            }))\n\t        }\n\t        ;\n\t        return this\n\t    }\n\t    ;\n\t    return core.Base64\n\t}\n\tcore.Base64 = makeBase64();\n\tcore.CSSUnits = function() {\n\t    var g = this\n\t      , k = {\n\t        \"in\": 1,\n\t        cm: 2.54,\n\t        mm: 25.4,\n\t        pt: 72,\n\t        pc: 12,\n\t        px: 96\n\t    };\n\t    this.convert = function(d, b, f) {\n\t        return d * k[f] / k[b]\n\t    }\n\t    ;\n\t    this.convertMeasure = function(d, b) {\n\t        var f, n;\n\t        d && b && (f = parseFloat(d),\n\t        n = d.replace(f.toString(), \"\"),\n\t        f = g.convert(f, n, b));\n\t        return f\n\t    }\n\t    ;\n\t    this.getUnits = function(d) {\n\t        return d.substr(d.length - 2, d.length)\n\t    }\n\t}\n\t;\n\t(function() {\n\t    function g() {\n\t        var b, f, n, g, r, k, e, l, a;\n\t        void 0 === d && (f = (b = runtime.getWindow()) && b.document,\n\t        k = f.documentElement,\n\t        e = f.body,\n\t        d = {\n\t            rangeBCRIgnoresElementBCR: !1,\n\t            unscaledRangeClientRects: !1,\n\t            elementBCRIgnoresBodyScroll: !1\n\t        },\n\t        f && (g = f.createElement(\"div\"),\n\t        g.style.position = \"absolute\",\n\t        g.style.left = \"-99999px\",\n\t        g.style.transform = \"scale(2)\",\n\t        g.style[\"-webkit-transform\"] = \"scale(2)\",\n\t        r = f.createElement(\"div\"),\n\t        g.appendChild(r),\n\t        e.appendChild(g),\n\t        b = f.createRange(),\n\t        b.selectNode(r),\n\t        d.rangeBCRIgnoresElementBCR = 0 === b.getClientRects().length,\n\t        r.appendChild(f.createTextNode(\"Rect transform test\")),\n\t        f = r.getBoundingClientRect(),\n\t        n = b.getBoundingClientRect(),\n\t        d.unscaledRangeClientRects = 2 < Math.abs(f.height - n.height),\n\t        g.style.transform = \"\",\n\t        g.style[\"-webkit-transform\"] = \"\",\n\t        f = k.style.overflow,\n\t        n = e.style.overflow,\n\t        l = e.style.height,\n\t        a = e.scrollTop,\n\t        k.style.overflow = \"visible\",\n\t        e.style.overflow = \"visible\",\n\t        e.style.height = \"200%\",\n\t        e.scrollTop = e.scrollHeight,\n\t        d.elementBCRIgnoresBodyScroll = b.getBoundingClientRect().top !== r.getBoundingClientRect().top,\n\t        e.scrollTop = a,\n\t        e.style.height = l,\n\t        e.style.overflow = n,\n\t        k.style.overflow = f,\n\t        b.detach(),\n\t        e.removeChild(g),\n\t        b = Object.keys(d).map(function(a) {\n\t            return a + \":\" + String(d[a])\n\t        }).join(\", \"),\n\t        runtime.log(\"Detected browser quirks - \" + b)));\n\t        return d\n\t    }\n\t    function k(b, d, n) {\n\t        for (b = b ? b.firstElementChild : null; b; ) {\n\t            if (b.localName === n && b.namespaceURI === d)\n\t                return b;\n\t            b = b.nextElementSibling\n\t        }\n\t        return null\n\t    }\n\t    var d;\n\t    core.DomUtilsImpl = function() {\n\t        function b(a, c) {\n\t            for (var b = 0, d; a.parentNode !== c; )\n\t                runtime.assert(null !== a.parentNode, \"parent is null\"),\n\t                a = a.parentNode;\n\t            for (d = c.firstChild; d !== a; )\n\t                b += 1,\n\t                d = d.nextSibling;\n\t            return b\n\t        }\n\t        function d(a, c) {\n\t            return 0 >= a.compareBoundaryPoints(Range.START_TO_START, c) && 0 <= a.compareBoundaryPoints(Range.END_TO_END, c)\n\t        }\n\t        function n(a, c) {\n\t            return 0 >= a.compareBoundaryPoints(Range.END_TO_START, c) && 0 <= a.compareBoundaryPoints(Range.START_TO_END, c)\n\t        }\n\t        function p(a, c) {\n\t            var b = null;\n\t            a.nodeType === Node.TEXT_NODE && (0 === a.length ? (a.parentNode.removeChild(a),\n\t            c.nodeType === Node.TEXT_NODE && (b = c)) : (c.nodeType === Node.TEXT_NODE && (a.appendData(c.data),\n\t            c.parentNode.removeChild(c)),\n\t            b = a));\n\t            return b\n\t        }\n\t        function r(a) {\n\t            for (var c = a.parentNode; a.firstChild; )\n\t                c.insertBefore(a.firstChild, a);\n\t            c.removeChild(a);\n\t            return c\n\t        }\n\t        function q(a, c) {\n\t            var b = a.parentNode, d = a.firstChild, l = c(a), e;\n\t            if (l === NodeFilter.FILTER_SKIP)\n\t                return b;\n\t            for (; d; )\n\t                e = d.nextSibling,\n\t                q(d, c),\n\t                d = e;\n\t            b && l === NodeFilter.FILTER_REJECT && r(a);\n\t            return b\n\t        }\n\t        function e(a, c) {\n\t            return a === c || Boolean(a.compareDocumentPosition(c) & Node.DOCUMENT_POSITION_CONTAINED_BY)\n\t        }\n\t        function l(a, c) {\n\t            return g().unscaledRangeClientRects ? a : a / c\n\t        }\n\t        function a(c, h, b) {\n\t            Object.keys(h).forEach(function(d) {\n\t                var l = d.split(\":\")\n\t                  , e = l[1]\n\t                  , f = b(l[0])\n\t                  , l = h[d]\n\t                  , n = typeof l;\n\t                \"object\" === n ? Object.keys(l).length && (d = f ? c.getElementsByTagNameNS(f, e)[0] || c.ownerDocument.createElementNS(f, d) : c.getElementsByTagName(e)[0] || c.ownerDocument.createElement(d),\n\t                c.appendChild(d),\n\t                a(d, l, b)) : f && (runtime.assert(\"number\" === n || \"string\" === n, \"attempting to map unsupported type '\" + n + \"' (key: \" + d + \")\"),\n\t                c.setAttributeNS(f, d, String(l)))\n\t            })\n\t        }\n\t        var c = null;\n\t        this.splitBoundaries = function(a) {\n\t            var c, d = [], l, e, f;\n\t            if (a.startContainer.nodeType === Node.TEXT_NODE || a.endContainer.nodeType === Node.TEXT_NODE) {\n\t                l = a.endContainer;\n\t                e = a.endContainer.nodeType !== Node.TEXT_NODE ? a.endOffset === a.endContainer.childNodes.length : !1;\n\t                f = a.endOffset;\n\t                c = a.endContainer;\n\t                if (f < c.childNodes.length)\n\t                    for (c = c.childNodes.item(f),\n\t                    f = 0; c.firstChild; )\n\t                        c = c.firstChild;\n\t                else\n\t                    for (; c.lastChild; )\n\t                        c = c.lastChild,\n\t                        f = c.nodeType === Node.TEXT_NODE ? c.textContent.length : c.childNodes.length;\n\t                c === l && (l = null);\n\t                a.setEnd(c, f);\n\t                f = a.endContainer;\n\t                0 !== a.endOffset && f.nodeType === Node.TEXT_NODE && (c = f,\n\t                a.endOffset !== c.length && (d.push(c.splitText(a.endOffset)),\n\t                d.push(c)));\n\t                f = a.startContainer;\n\t                0 !== a.startOffset && f.nodeType === Node.TEXT_NODE && (c = f,\n\t                a.startOffset !== c.length && (f = c.splitText(a.startOffset),\n\t                d.push(c),\n\t                d.push(f),\n\t                a.setStart(f, 0)));\n\t                if (null !== l) {\n\t                    for (f = a.endContainer; f.parentNode && f.parentNode !== l; )\n\t                        f = f.parentNode;\n\t                    e = e ? l.childNodes.length : b(f, l);\n\t                    a.setEnd(l, e)\n\t                }\n\t            }\n\t            return d\n\t        }\n\t        ;\n\t        this.containsRange = d;\n\t        this.rangesIntersect = n;\n\t        this.rangeIntersection = function(a, c) {\n\t            var b;\n\t            n(a, c) && (b = a.cloneRange(),\n\t            -1 === a.compareBoundaryPoints(Range.START_TO_START, c) && b.setStart(c.startContainer, c.startOffset),\n\t            1 === a.compareBoundaryPoints(Range.END_TO_END, c) && b.setEnd(c.endContainer, c.endOffset));\n\t            return b\n\t        }\n\t        ;\n\t        this.getNodesInRange = function(a, c, b) {\n\t            var d = []\n\t              , l = a.commonAncestorContainer\n\t              , l = l.nodeType === Node.TEXT_NODE ? l.parentNode : l;\n\t            b = a.startContainer.ownerDocument.createTreeWalker(l, b, c, !1);\n\t            var e, f;\n\t            a.endContainer.childNodes[a.endOffset - 1] ? (e = a.endContainer.childNodes[a.endOffset - 1],\n\t            f = Node.DOCUMENT_POSITION_PRECEDING | Node.DOCUMENT_POSITION_CONTAINED_BY) : (e = a.endContainer,\n\t            f = Node.DOCUMENT_POSITION_PRECEDING);\n\t            if (a.startContainer.childNodes[a.startOffset])\n\t                a = a.startContainer.childNodes[a.startOffset],\n\t                b.currentNode = a;\n\t            else {\n\t                var n = a.startContainer;\n\t                a.startOffset === (n.nodeType === Node.TEXT_NODE ? n.length : n.childNodes.length) ? (a = a.startContainer,\n\t                b.currentNode = a,\n\t                b.lastChild(),\n\t                a = b.nextNode()) : (a = a.startContainer,\n\t                b.currentNode = a)\n\t            }\n\t            if (a) {\n\t                a = b.currentNode;\n\t                if (a !== l)\n\t                    for (a = a.parentNode; a && a !== l; )\n\t                        c(a) === NodeFilter.FILTER_REJECT && (b.currentNode = a),\n\t                        a = a.parentNode;\n\t                a = b.currentNode;\n\t                switch (c(a)) {\n\t                case NodeFilter.FILTER_REJECT:\n\t                    for (a = b.nextSibling(); !a && b.parentNode(); )\n\t                        a = b.nextSibling();\n\t                    break;\n\t                case NodeFilter.FILTER_SKIP:\n\t                    a = b.nextNode()\n\t                }\n\t                for (; a; ) {\n\t                    c = e.compareDocumentPosition(a);\n\t                    if (0 !== c && 0 === (c & f))\n\t                        break;\n\t                    d.push(a);\n\t                    a = b.nextNode()\n\t                }\n\t            }\n\t            return d\n\t        }\n\t        ;\n\t        this.normalizeTextNodes = function(a) {\n\t            a && a.nextSibling && (a = p(a, a.nextSibling));\n\t            a && a.previousSibling && p(a.previousSibling, a)\n\t        }\n\t        ;\n\t        this.rangeContainsNode = function(a, c) {\n\t            var b = c.ownerDocument.createRange(), l = c.ownerDocument.createRange(), e;\n\t            b.setStart(a.startContainer, a.startOffset);\n\t            b.setEnd(a.endContainer, a.endOffset);\n\t            l.selectNodeContents(c);\n\t            e = d(b, l);\n\t            b.detach();\n\t            l.detach();\n\t            return e\n\t        }\n\t        ;\n\t        this.mergeIntoParent = r;\n\t        this.removeUnwantedNodes = q;\n\t        this.removeAllChildNodes = function(a) {\n\t            for (; a.firstChild; )\n\t                a.removeChild(a.firstChild)\n\t        }\n\t        ;\n\t        this.getElementsByTagNameNS = function(a, c, b) {\n\t            var d = [];\n\t            a = a.getElementsByTagNameNS(c, b);\n\t            d.length = b = a.length;\n\t            for (c = 0; c < b; c += 1)\n\t                d[c] = a.item(c);\n\t            return d\n\t        }\n\t        ;\n\t        this.getElementsByTagName = function(a, c) {\n\t            var b = [], d, l, e;\n\t            d = a.getElementsByTagName(c);\n\t            b.length = e = d.length;\n\t            for (l = 0; l < e; l += 1)\n\t                b[l] = d.item(l);\n\t            return b\n\t        }\n\t        ;\n\t        this.containsNode = function(a, c) {\n\t            return a === c || a.contains(c)\n\t        }\n\t        ;\n\t        this.comparePoints = function(a, c, d, l) {\n\t            if (a === d)\n\t                return l - c;\n\t            var e = a.compareDocumentPosition(d);\n\t            2 === e ? e = -1 : 4 === e ? e = 1 : 10 === e ? (c = b(a, d),\n\t            e = c < l ? 1 : -1) : (l = b(d, a),\n\t            e = l < c ? -1 : 1);\n\t            return e\n\t        }\n\t        ;\n\t        this.adaptRangeDifferenceToZoomLevel = l;\n\t        this.translateRect = function(a, c, b) {\n\t            return {\n\t                top: l(a.top - c.top, b),\n\t                left: l(a.left - c.left, b),\n\t                bottom: l(a.bottom - c.top, b),\n\t                right: l(a.right - c.left, b),\n\t                width: l(a.width, b),\n\t                height: l(a.height, b)\n\t            }\n\t        }\n\t        ;\n\t        this.getBoundingClientRect = function(a) {\n\t            var b = a.ownerDocument\n\t              , d = g()\n\t              , l = b.body;\n\t            if ((!1 === d.unscaledRangeClientRects || d.rangeBCRIgnoresElementBCR) && a.nodeType === Node.ELEMENT_NODE)\n\t                return a = a.getBoundingClientRect(),\n\t                d.elementBCRIgnoresBodyScroll ? {\n\t                    left: a.left + l.scrollLeft,\n\t                    right: a.right + l.scrollLeft,\n\t                    top: a.top + l.scrollTop,\n\t                    bottom: a.bottom + l.scrollTop,\n\t                    width: a.width,\n\t                    height: a.height\n\t                } : a;\n\t            var e;\n\t            c ? e = c : c = e = b.createRange();\n\t            d = e;\n\t            d.selectNode(a);\n\t            return d.getBoundingClientRect()\n\t        }\n\t        ;\n\t        this.mapKeyValObjOntoNode = function(a, c, b) {\n\t            Object.keys(c).forEach(function(d) {\n\t                var l = d.split(\":\")\n\t                  , e = l[1]\n\t                  , l = b(l[0])\n\t                  , f = c[d];\n\t                l ? (e = a.getElementsByTagNameNS(l, e)[0],\n\t                e || (e = a.ownerDocument.createElementNS(l, d),\n\t                a.appendChild(e)),\n\t                e.textContent = f) : runtime.log(\"Key ignored: \" + d)\n\t            })\n\t        }\n\t        ;\n\t        this.removeKeyElementsFromNode = function(a, c, b) {\n\t            c.forEach(function(c) {\n\t                var d = c.split(\":\")\n\t                  , h = d[1];\n\t                (d = b(d[0])) ? (h = a.getElementsByTagNameNS(d, h)[0]) ? h.parentNode.removeChild(h) : runtime.log(\"Element for \" + c + \" not found.\") : runtime.log(\"Property Name ignored: \" + c)\n\t            })\n\t        }\n\t        ;\n\t        this.getKeyValRepresentationOfNode = function(a, c) {\n\t            for (var b = {}, d = a.firstElementChild, l; d; ) {\n\t                if (l = c(d.namespaceURI))\n\t                    b[l + \":\" + d.localName] = d.textContent;\n\t                d = d.nextElementSibling\n\t            }\n\t            return b\n\t        }\n\t        ;\n\t        this.mapObjOntoNode = a;\n\t        this.cloneEvent = function(a) {\n\t            var c = Object.create(null);\n\t            Object.keys(a.constructor.prototype).forEach(function(b) {\n\t                c[b] = a[b]\n\t            });\n\t            c.prototype = a.constructor.prototype;\n\t            return c\n\t        }\n\t        ;\n\t        this.getDirectChild = k;\n\t        (function(a) {\n\t            var c, b;\n\t            b = runtime.getWindow();\n\t            null !== b && (c = b.navigator.appVersion.toLowerCase(),\n\t            b = -1 === c.indexOf(\"chrome\") && (-1 !== c.indexOf(\"applewebkit\") || -1 !== c.indexOf(\"safari\")),\n\t            c = -1 !== c.indexOf(\"msie\") || -1 !== c.indexOf(\"trident\"),\n\t            b || c) && (a.containsNode = e)\n\t        }\n\t        )(this)\n\t    }\n\t    ;\n\t    core.DomUtils = new core.DomUtilsImpl\n\t}\n\t)();\n\tcore.Cursor = function(g, k) {\n\t    function d(a) {\n\t        a.parentNode && (r.push(a.previousSibling),\n\t        r.push(a.nextSibling),\n\t        a.parentNode.removeChild(a))\n\t    }\n\t    function b(a, c, b) {\n\t        if (c.nodeType === Node.TEXT_NODE) {\n\t            runtime.assert(Boolean(c), \"putCursorIntoTextNode: invalid container\");\n\t            var d = c.parentNode;\n\t            runtime.assert(Boolean(d), \"putCursorIntoTextNode: container without parent\");\n\t            runtime.assert(0 <= b && b <= c.length, \"putCursorIntoTextNode: offset is out of bounds\");\n\t            0 === b ? d.insertBefore(a, c) : (b !== c.length && c.splitText(b),\n\t            d.insertBefore(a, c.nextSibling))\n\t        } else\n\t            c.nodeType === Node.ELEMENT_NODE && c.insertBefore(a, c.childNodes.item(b));\n\t        r.push(a.previousSibling);\n\t        r.push(a.nextSibling)\n\t    }\n\t    var f = g.createElementNS(\"urn:webodf:names:cursor\", \"cursor\"), n = g.createElementNS(\"urn:webodf:names:cursor\", \"anchor\"), p, r = [], q = g.createRange(), e, l = core.DomUtils;\n\t    this.getNode = function() {\n\t        return f\n\t    }\n\t    ;\n\t    this.getAnchorNode = function() {\n\t        return n.parentNode ? n : f\n\t    }\n\t    ;\n\t    this.getSelectedRange = function() {\n\t        e ? (q.setStartBefore(f),\n\t        q.collapse(!0)) : (q.setStartAfter(p ? n : f),\n\t        q.setEndBefore(p ? f : n));\n\t        return q\n\t    }\n\t    ;\n\t    this.setSelectedRange = function(a, c) {\n\t        q && q !== a && q.detach();\n\t        q = a;\n\t        p = !1 !== c;\n\t        (e = a.collapsed) ? (d(n),\n\t        d(f),\n\t        b(f, a.startContainer, a.startOffset)) : (d(n),\n\t        d(f),\n\t        b(p ? f : n, a.endContainer, a.endOffset),\n\t        b(p ? n : f, a.startContainer, a.startOffset));\n\t        r.forEach(l.normalizeTextNodes);\n\t        r.length = 0\n\t    }\n\t    ;\n\t    this.hasForwardSelection = function() {\n\t        return p\n\t    }\n\t    ;\n\t    this.remove = function() {\n\t        d(f);\n\t        r.forEach(l.normalizeTextNodes);\n\t        r.length = 0\n\t    }\n\t    ;\n\t    f.setAttributeNS(\"urn:webodf:names:cursor\", \"memberId\", k);\n\t    n.setAttributeNS(\"urn:webodf:names:cursor\", \"memberId\", k)\n\t}\n\t;\n\tcore.Destroyable = function() {}\n\t;\n\tcore.Destroyable.prototype.destroy = function(g) {}\n\t;\n\tcore.EventSource = function() {}\n\t;\n\tcore.EventSource.prototype.subscribe = function(g, k) {}\n\t;\n\tcore.EventSource.prototype.unsubscribe = function(g, k) {}\n\t;\n\tcore.EventNotifier = function(g) {\n\t    function k(b) {\n\t        runtime.assert(!d.hasOwnProperty(b), 'Duplicated event ids: \"' + b + '\" registered more than once.');\n\t        d[b] = []\n\t    }\n\t    var d = {};\n\t    this.emit = function(b, f) {\n\t        var n, g;\n\t        runtime.assert(d.hasOwnProperty(b), 'unknown event fired \"' + b + '\"');\n\t        g = d[b];\n\t        for (n = 0; n < g.length; n += 1)\n\t            g[n](f)\n\t    }\n\t    ;\n\t    this.subscribe = function(b, f) {\n\t        runtime.assert(d.hasOwnProperty(b), 'tried to subscribe to unknown event \"' + b + '\"');\n\t        d[b].push(f)\n\t    }\n\t    ;\n\t    this.unsubscribe = function(b, f) {\n\t        var n;\n\t        runtime.assert(d.hasOwnProperty(b), 'tried to unsubscribe from unknown event \"' + b + '\"');\n\t        n = d[b].indexOf(f);\n\t        runtime.assert(-1 !== n, 'tried to unsubscribe unknown callback from event \"' + b + '\"');\n\t        -1 !== n && d[b].splice(n, 1)\n\t    }\n\t    ;\n\t    this.register = k;\n\t    g && g.forEach(k)\n\t}\n\t;\n\tcore.ScheduledTask = function(g, k, d) {\n\t    function b() {\n\t        p && (d(n),\n\t        p = !1)\n\t    }\n\t    function f() {\n\t        b();\n\t        g.apply(void 0, r);\n\t        r = null\n\t    }\n\t    var n, p = !1, r = [], q = !1;\n\t    this.trigger = function() {\n\t        runtime.assert(!1 === q, \"Can't trigger destroyed ScheduledTask instance\");\n\t        r = Array.prototype.slice.call(arguments);\n\t        p || (p = !0,\n\t        n = k(f))\n\t    }\n\t    ;\n\t    this.triggerImmediate = function() {\n\t        runtime.assert(!1 === q, \"Can't trigger destroyed ScheduledTask instance\");\n\t        r = Array.prototype.slice.call(arguments);\n\t        f()\n\t    }\n\t    ;\n\t    this.processRequests = function() {\n\t        p && f()\n\t    }\n\t    ;\n\t    this.cancel = b;\n\t    this.restart = function() {\n\t        runtime.assert(!1 === q, \"Can't trigger destroyed ScheduledTask instance\");\n\t        b();\n\t        p = !0;\n\t        n = k(f)\n\t    }\n\t    ;\n\t    this.destroy = function(d) {\n\t        b();\n\t        q = !0;\n\t        d()\n\t    }\n\t}\n\t;\n\t(function() {\n\t    var g;\n\t    core.Task = {};\n\t    core.Task.SUPPRESS_MANUAL_PROCESSING = !1;\n\t    core.Task.processTasks = function() {\n\t        core.Task.SUPPRESS_MANUAL_PROCESSING || g.performRedraw()\n\t    }\n\t    ;\n\t    core.Task.createRedrawTask = function(k) {\n\t        return new core.ScheduledTask(k,g.requestRedrawTask,g.cancelRedrawTask)\n\t    }\n\t    ;\n\t    core.Task.createTimeoutTask = function(g, d) {\n\t        return new core.ScheduledTask(g,function(b) {\n\t            return runtime.setTimeout(b, d)\n\t        }\n\t        ,runtime.clearTimeout)\n\t    }\n\t    ;\n\t    g = new function() {\n\t        var g = {};\n\t        this.requestRedrawTask = function(d) {\n\t            var b = runtime.requestAnimationFrame(function() {\n\t                d();\n\t                delete g[b]\n\t            });\n\t            g[b] = d;\n\t            return b\n\t        }\n\t        ;\n\t        this.performRedraw = function() {\n\t            Object.keys(g).forEach(function(d) {\n\t                g[d]();\n\t                runtime.cancelAnimationFrame(parseInt(d, 10))\n\t            });\n\t            g = {}\n\t        }\n\t        ;\n\t        this.cancelRedrawTask = function(d) {\n\t            runtime.cancelAnimationFrame(d);\n\t            delete g[d]\n\t        }\n\t    }\n\t}\n\t)();\n\tcore.EventSubscriptions = function() {\n\t    function g(b, f, n) {\n\t        b.subscribe(f, n);\n\t        d.push({\n\t            eventSource: b,\n\t            eventid: f,\n\t            callback: n\n\t        })\n\t    }\n\t    function k() {\n\t        var n = [];\n\t        d.forEach(function(b) {\n\t            b.eventSource.unsubscribe(b.eventid, b.callback)\n\t        });\n\t        d.length = 0;\n\t        Object.keys(f).forEach(function(b) {\n\t            f[b].forEach(function(b) {\n\t                n.push(b.task.destroy)\n\t            });\n\t            delete f[b]\n\t        });\n\t        core.Async.destroyAll(n, function() {});\n\t        b = new core.EventNotifier\n\t    }\n\t    var d = []\n\t      , b = new core.EventNotifier\n\t      , f = {}\n\t      , n = 0;\n\t    this.addSubscription = g;\n\t    this.addFrameSubscription = function(d, k, q) {\n\t        var e, l, a, c;\n\t        f.hasOwnProperty(k) || (f[k] = []);\n\t        a = f[k];\n\t        for (c = 0; c < a.length; c += 1)\n\t            if (a[c].eventSource === d) {\n\t                e = a[c];\n\t                break\n\t            }\n\t        e || (l = \"s\" + n,\n\t        n += 1,\n\t        b.register(l),\n\t        e = {\n\t            frameEventId: l,\n\t            eventSource: d,\n\t            task: core.Task.createRedrawTask(function() {\n\t                b.emit(l, void 0)\n\t            })\n\t        },\n\t        a.push(e),\n\t        g(d, k, e.task.trigger));\n\t        b.subscribe(e.frameEventId, q)\n\t    }\n\t    ;\n\t    this.unsubscribeAll = k;\n\t    this.destroy = function(b) {\n\t        k();\n\t        b()\n\t    }\n\t}\n\t;\n\tcore.LazyProperty = function(g) {\n\t    var k, d = !1;\n\t    this.value = function() {\n\t        d || (k = g(),\n\t        d = !0);\n\t        return k\n\t    }\n\t    ;\n\t    this.reset = function() {\n\t        d = !1\n\t    }\n\t}\n\t;\n\tcore.LoopWatchDog = function(g, k) {\n\t    var d = Date.now()\n\t      , b = 0;\n\t    this.check = function() {\n\t        var f;\n\t        if (g && (f = Date.now(),\n\t        f - d > g))\n\t            throw runtime.log(\"alert\", \"watchdog timeout\"),\n\t            \"timeout!\";\n\t        if (0 < k && (b += 1,\n\t        b > k))\n\t            throw runtime.log(\"alert\", \"watchdog loop overflow\"),\n\t            \"loop overflow\";\n\t    }\n\t}\n\t;\n\tcore.NodeFilterChain = function(g) {\n\t    var k = NodeFilter.FILTER_REJECT\n\t      , d = NodeFilter.FILTER_ACCEPT;\n\t    this.acceptNode = function(b) {\n\t        var f;\n\t        for (f = 0; f < g.length; f += 1)\n\t            if (g[f].acceptNode(b) === k)\n\t                return k;\n\t        return d\n\t    }\n\t}\n\t;\n\tcore.PositionIterator = function(g, k, d, b) {\n\t    function f() {\n\t        this.acceptNode = function(a) {\n\t            return !a || a.nodeType === m && 0 === a.length ? x : y\n\t        }\n\t    }\n\t    function n(a) {\n\t        this.acceptNode = function(c) {\n\t            return !c || c.nodeType === m && 0 === c.length ? x : a.acceptNode(c)\n\t        }\n\t    }\n\t    function p() {\n\t        var c = l.currentNode\n\t          , b = c.nodeType;\n\t        a = b === m ? c.length - 1 : b === h ? 1 : 0\n\t    }\n\t    function r() {\n\t        if (null === l.previousSibling()) {\n\t            if (!l.parentNode() || l.currentNode === g)\n\t                return l.firstChild(),\n\t                !1;\n\t            a = 0\n\t        } else\n\t            p();\n\t        return !0\n\t    }\n\t    function q() {\n\t        var b = l.currentNode, d;\n\t        d = c(b);\n\t        if (b !== g)\n\t            for (b = b.parentNode; b && b !== g; )\n\t                c(b) === x && (l.currentNode = b,\n\t                d = x),\n\t                b = b.parentNode;\n\t        d === x ? (a = l.currentNode.nodeType === m ? b.length : 1,\n\t        b = e.nextPosition()) : b = d === y ? !0 : e.nextPosition();\n\t        b && runtime.assert(c(l.currentNode) === y, \"moveToAcceptedNode did not result in walker being on an accepted node\");\n\t        return b\n\t    }\n\t    var e = this, l, a, c, m = Node.TEXT_NODE, h = Node.ELEMENT_NODE, y = NodeFilter.FILTER_ACCEPT, x = NodeFilter.FILTER_REJECT;\n\t    this.nextPosition = function() {\n\t        var c = l.currentNode\n\t          , b = c.nodeType;\n\t        if (c === g)\n\t            return !1;\n\t        if (0 === a && b === h)\n\t            null === l.firstChild() && (a = 1);\n\t        else if (b === m && a + 1 < c.length)\n\t            a += 1;\n\t        else if (null !== l.nextSibling())\n\t            a = 0;\n\t        else if (l.parentNode())\n\t            a = 1;\n\t        else\n\t            return !1;\n\t        return !0\n\t    }\n\t    ;\n\t    this.previousPosition = function() {\n\t        var c = !0\n\t          , b = l.currentNode;\n\t        0 === a ? c = r() : b.nodeType === m ? --a : null !== l.lastChild() ? p() : b === g ? c = !1 : a = 0;\n\t        return c\n\t    }\n\t    ;\n\t    this.previousNode = r;\n\t    this.container = function() {\n\t        var c = l.currentNode\n\t          , b = c.nodeType;\n\t        0 === a && b !== m && (c = c.parentNode);\n\t        return c\n\t    }\n\t    ;\n\t    this.rightNode = function() {\n\t        var b = l.currentNode\n\t          , d = b.nodeType;\n\t        if (d === m && a === b.length)\n\t            for (b = b.nextSibling; b && c(b) !== y; )\n\t                b = b.nextSibling;\n\t        else\n\t            d === h && 1 === a && (b = null);\n\t        return b\n\t    }\n\t    ;\n\t    this.leftNode = function() {\n\t        var b = l.currentNode;\n\t        if (0 === a)\n\t            for (b = b.previousSibling; b && c(b) !== y; )\n\t                b = b.previousSibling;\n\t        else if (b.nodeType === h)\n\t            for (b = b.lastChild; b && c(b) !== y; )\n\t                b = b.previousSibling;\n\t        return b\n\t    }\n\t    ;\n\t    this.getCurrentNode = function() {\n\t        return l.currentNode\n\t    }\n\t    ;\n\t    this.unfilteredDomOffset = function() {\n\t        if (l.currentNode.nodeType === m)\n\t            return a;\n\t        for (var c = 0, b = l.currentNode, b = 1 === a ? b.lastChild : b.previousSibling; b; )\n\t            c += 1,\n\t            b = b.previousSibling;\n\t        return c\n\t    }\n\t    ;\n\t    this.getPreviousSibling = function() {\n\t        var a = l.currentNode\n\t          , c = l.previousSibling();\n\t        l.currentNode = a;\n\t        return c\n\t    }\n\t    ;\n\t    this.getNextSibling = function() {\n\t        var a = l.currentNode\n\t          , c = l.nextSibling();\n\t        l.currentNode = a;\n\t        return c\n\t    }\n\t    ;\n\t    this.setPositionBeforeElement = function(c) {\n\t        runtime.assert(Boolean(c), \"setPositionBeforeElement called without element\");\n\t        l.currentNode = c;\n\t        a = 0;\n\t        return q()\n\t    }\n\t    ;\n\t    this.setUnfilteredPosition = function(c, b) {\n\t        runtime.assert(Boolean(c), \"PositionIterator.setUnfilteredPosition called without container\");\n\t        l.currentNode = c;\n\t        c.nodeType === m ? (a = b,\n\t        runtime.assert(b <= c.length, \"Error in setPosition: \" + b + \" > \" + c.length),\n\t        runtime.assert(0 <= b, \"Error in setPosition: \" + b + \" < 0\"),\n\t        b === c.length && (l.nextSibling() ? a = 0 : l.parentNode() ? a = 1 : runtime.assert(!1, \"Error in setUnfilteredPosition: position not valid.\"))) : b < c.childNodes.length ? (l.currentNode = c.childNodes.item(b),\n\t        a = 0) : a = 1;\n\t        return q()\n\t    }\n\t    ;\n\t    this.moveToEnd = function() {\n\t        l.currentNode = g;\n\t        a = 1\n\t    }\n\t    ;\n\t    this.moveToEndOfNode = function(c) {\n\t        c.nodeType === m ? e.setUnfilteredPosition(c, c.length) : (l.currentNode = c,\n\t        a = 1)\n\t    }\n\t    ;\n\t    this.isBeforeNode = function() {\n\t        return 0 === a\n\t    }\n\t    ;\n\t    this.getNodeFilter = function() {\n\t        return c\n\t    }\n\t    ;\n\t    c = (d ? new n(d) : new f).acceptNode;\n\t    c.acceptNode = c;\n\t    k = k || NodeFilter.SHOW_ALL;\n\t    runtime.assert(g.nodeType !== Node.TEXT_NODE, \"Internet Explorer doesn't allow tree walker roots to be text nodes\");\n\t    l = g.ownerDocument.createTreeWalker(g, k, c, b);\n\t    a = 0;\n\t    null === l.firstChild() && (a = 1)\n\t}\n\t;\n\tcore.PositionFilter = function() {}\n\t;\n\tcore.PositionFilter.FilterResult = {\n\t    FILTER_ACCEPT: 1,\n\t    FILTER_REJECT: 2,\n\t    FILTER_SKIP: 3\n\t};\n\tcore.PositionFilter.prototype.acceptPosition = function(g) {}\n\t;\n\tcore.PositionFilterChain = function() {\n\t    var g = []\n\t      , k = core.PositionFilter.FilterResult.FILTER_ACCEPT\n\t      , d = core.PositionFilter.FilterResult.FILTER_REJECT;\n\t    this.acceptPosition = function(b) {\n\t        var f;\n\t        for (f = 0; f < g.length; f += 1)\n\t            if (g[f].acceptPosition(b) === d)\n\t                return d;\n\t        return k\n\t    }\n\t    ;\n\t    this.addFilter = function(b) {\n\t        g.push(b)\n\t    }\n\t}\n\t;\n\tcore.StepDirection = {\n\t    PREVIOUS: 1,\n\t    NEXT: 2\n\t};\n\tcore.StepIterator = function(g, k) {\n\t    function d() {\n\t        a = null;\n\t        m = c = void 0\n\t    }\n\t    function b() {\n\t        void 0 === m && (m = g.acceptPosition(k) === e);\n\t        return m\n\t    }\n\t    function f(a, c) {\n\t        d();\n\t        return k.setUnfilteredPosition(a, c)\n\t    }\n\t    function n() {\n\t        a || (a = k.container());\n\t        return a\n\t    }\n\t    function p() {\n\t        void 0 === c && (c = k.unfilteredDomOffset());\n\t        return c\n\t    }\n\t    function r() {\n\t        for (d(); k.nextPosition(); )\n\t            if (d(),\n\t            b())\n\t                return !0;\n\t        return !1\n\t    }\n\t    function q() {\n\t        for (d(); k.previousPosition(); )\n\t            if (d(),\n\t            b())\n\t                return !0;\n\t        return !1\n\t    }\n\t    var e = core.PositionFilter.FilterResult.FILTER_ACCEPT, l = core.StepDirection.NEXT, a, c, m;\n\t    this.isStep = b;\n\t    this.setPosition = f;\n\t    this.container = n;\n\t    this.offset = p;\n\t    this.nextStep = r;\n\t    this.previousStep = q;\n\t    this.advanceStep = function(a) {\n\t        return a === l ? r() : q()\n\t    }\n\t    ;\n\t    this.roundToClosestStep = function() {\n\t        var a, c, d = b();\n\t        d || (a = n(),\n\t        c = p(),\n\t        d = q(),\n\t        d || (f(a, c),\n\t        d = r()));\n\t        return d\n\t    }\n\t    ;\n\t    this.roundToPreviousStep = function() {\n\t        var a = b();\n\t        a || (a = q());\n\t        return a\n\t    }\n\t    ;\n\t    this.roundToNextStep = function() {\n\t        var a = b();\n\t        a || (a = r());\n\t        return a\n\t    }\n\t    ;\n\t    this.leftNode = function() {\n\t        return k.leftNode()\n\t    }\n\t    ;\n\t    this.snapshot = function() {\n\t        return new core.StepIterator.StepSnapshot(n(),p())\n\t    }\n\t    ;\n\t    this.restore = function(a) {\n\t        f(a.container, a.offset)\n\t    }\n\t}\n\t;\n\tcore.StepIterator.StepSnapshot = function(g, k) {\n\t    this.container = g;\n\t    this.offset = k\n\t}\n\t;\n\tcore.Utils = function() {\n\t    function g(k, d) {\n\t        if (d && Array.isArray(d)) {\n\t            k = k || [];\n\t            if (!Array.isArray(k))\n\t                throw \"Destination is not an array.\";\n\t            k = k.concat(d.map(function(b) {\n\t                return g(null, b)\n\t            }))\n\t        } else if (d && \"object\" === typeof d) {\n\t            k = k || {};\n\t            if (\"object\" !== typeof k)\n\t                throw \"Destination is not an object.\";\n\t            Object.keys(d).forEach(function(b) {\n\t                k[b] = g(k[b], d[b])\n\t            })\n\t        } else\n\t            k = d;\n\t        return k\n\t    }\n\t    this.hashString = function(g) {\n\t        var d = 0, b, f;\n\t        b = 0;\n\t        for (f = g.length; b < f; b += 1)\n\t            d = (d << 5) - d + g.charCodeAt(b),\n\t            d |= 0;\n\t        return d\n\t    }\n\t    ;\n\t    this.mergeObjects = function(k, d) {\n\t        Object.keys(d).forEach(function(b) {\n\t            k[b] = g(k[b], d[b])\n\t        });\n\t        return k\n\t    }\n\t}\n\t;\n\tcore.Zip = function(g, k) {\n\t    function d(b, d) {\n\t        var a = r.file(b);\n\t        a ? d(null, a.asUint8Array()) : d(b + \" not found.\", null)\n\t    }\n\t    function b(b, l) {\n\t        d(b, function(a, c) {\n\t            if (a || null === c)\n\t                return l(a, null);\n\t            var b = runtime.byteArrayToString(c, \"utf8\");\n\t            l(null, b)\n\t        })\n\t    }\n\t    function f(b, d) {\n\t        try {\n\t            b(r.generate({\n\t                type: \"uint8array\",\n\t                compression: \"STORE\"\n\t            }))\n\t        } catch (a) {\n\t            d(a.message)\n\t        }\n\t    }\n\t    function n(b, d) {\n\t        f(function(a) {\n\t            runtime.writeFile(b, a, d)\n\t        }, d)\n\t    }\n\t    var p = this, r, q = new core.Base64;\n\t    this.load = d;\n\t    this.save = function(b, d, a, c) {\n\t        r.file(b, d, {\n\t            date: c,\n\t            compression: a ? \"DEFLATE\" : \"STORE\"\n\t        })\n\t    }\n\t    ;\n\t    this.remove = function(b) {\n\t        var d = null !== r.file(b);\n\t        r.remove(b);\n\t        return d\n\t    }\n\t    ;\n\t    this.write = function(b) {\n\t        n(g, b)\n\t    }\n\t    ;\n\t    this.writeAs = n;\n\t    this.createByteArray = f;\n\t    this.loadContentXmlAsFragments = function(d, l) {\n\t        b(d, function(a, c) {\n\t            if (a)\n\t                return l.rootElementReady(a);\n\t            l.rootElementReady(null, c, !0)\n\t        })\n\t    }\n\t    ;\n\t    this.loadAsString = b;\n\t    this.loadAsDOM = function(d, l) {\n\t        b(d, function(a, c) {\n\t            if (a || null === c)\n\t                l(a, null);\n\t            else {\n\t                var b = (new DOMParser).parseFromString(c, \"text/xml\");\n\t                l(null, b)\n\t            }\n\t        })\n\t    }\n\t    ;\n\t    this.loadAsDataURL = function(b, l, a) {\n\t        d(b, function(c, b) {\n\t            if (c || !b)\n\t                return a(c, null);\n\t            var d = 0, e;\n\t            l || (l = 80 === b[1] && 78 === b[2] && 71 === b[3] ? \"image/png\" : 255 === b[0] && 216 === b[1] && 255 === b[2] ? \"image/jpeg\" : 71 === b[0] && 73 === b[1] && 70 === b[2] ? \"image/gif\" : \"\");\n\t            for (e = \"data:\" + l + \";base64,\"; d < b.length; )\n\t                e += q.convertUTF8ArrayToBase64(b.subarray(d, Math.min(d + 45E3, b.length))),\n\t                d += 45E3;\n\t            a(null, e)\n\t        })\n\t    }\n\t    ;\n\t    this.getEntries = function() {\n\t        return Object.keys(r.files).map(function(b) {\n\t            return {\n\t                filename: b,\n\t                date: r.files[b].date\n\t            }\n\t        })\n\t    }\n\t    ;\n\t    r = new externs.JSZip;\n\t    null !== k && runtime.readFile(g, \"binary\", function(b, d) {\n\t        \"string\" === typeof d && (b = \"file was read as a string. Should be Uint8Array.\");\n\t        if (b || !d || 0 === d.length)\n\t            k(\"File '\" + g + \"' cannot be read. Err: \" + (b || \"[none]\"), p);\n\t        else\n\t            try {\n\t                r.load(d, {\n\t                    checkCRC32: !1\n\t                }),\n\t                k(null, p)\n\t            } catch (a) {\n\t                k(a.message, p)\n\t            }\n\t    })\n\t}\n\t;\n\tcore.SimpleClientRect = null;\n\tgui.CommonConstraints = {\n\t    EDIT: {\n\t        ANNOTATIONS: {\n\t            ONLY_DELETE_OWN: \"onlyDeleteOwn\"\n\t        },\n\t        REVIEW_MODE: \"reviewMode\"\n\t    }\n\t};\n\tgui.SessionConstraints = function() {\n\t    function g(b) {\n\t        k.hasOwnProperty(b) || (k[b] = !1,\n\t        d.register(b))\n\t    }\n\t    var k = {}\n\t      , d = new core.EventNotifier;\n\t    this.registerConstraint = g;\n\t    this.subscribe = function(b, f) {\n\t        g(b);\n\t        d.subscribe(b, f)\n\t    }\n\t    ;\n\t    this.unsubscribe = function(b, f) {\n\t        d.unsubscribe(b, f)\n\t    }\n\t    ;\n\t    this.setState = function(b, f) {\n\t        runtime.assert(!0 === k.hasOwnProperty(b), \"No such constraint\");\n\t        k[b] !== f && (k[b] = f,\n\t        d.emit(b, f))\n\t    }\n\t    ;\n\t    this.getState = function(b) {\n\t        runtime.assert(!0 === k.hasOwnProperty(b), \"No such constraint\");\n\t        return k[b]\n\t    }\n\t}\n\t;\n\tgui.BlacklistNamespaceNodeFilter = function(g) {\n\t    var k = {}\n\t      , d = NodeFilter.FILTER_REJECT\n\t      , b = NodeFilter.FILTER_ACCEPT;\n\t    this.acceptNode = function(f) {\n\t        return !f || k.hasOwnProperty(f.namespaceURI) ? d : b\n\t    }\n\t    ;\n\t    (function() {\n\t        g.forEach(function(b) {\n\t            k[b] = !0\n\t        })\n\t    }\n\t    )()\n\t}\n\t;\n\todf.Namespaces = {\n\t    namespaceMap: {\n\t        config: \"urn:oasis:names:tc:opendocument:xmlns:config:1.0\",\n\t        db: \"urn:oasis:names:tc:opendocument:xmlns:database:1.0\",\n\t        dc: \"http://purl.org/dc/elements/1.1/\",\n\t        dr3d: \"urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0\",\n\t        draw: \"urn:oasis:names:tc:opendocument:xmlns:drawing:1.0\",\n\t        chart: \"urn:oasis:names:tc:opendocument:xmlns:chart:1.0\",\n\t        fo: \"urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0\",\n\t        form: \"urn:oasis:names:tc:opendocument:xmlns:form:1.0\",\n\t        math: \"http://www.w3.org/1998/Math/MathML\",\n\t        meta: \"urn:oasis:names:tc:opendocument:xmlns:meta:1.0\",\n\t        number: \"urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0\",\n\t        office: \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\",\n\t        presentation: \"urn:oasis:names:tc:opendocument:xmlns:presentation:1.0\",\n\t        style: \"urn:oasis:names:tc:opendocument:xmlns:style:1.0\",\n\t        svg: \"urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0\",\n\t        table: \"urn:oasis:names:tc:opendocument:xmlns:table:1.0\",\n\t        text: \"urn:oasis:names:tc:opendocument:xmlns:text:1.0\",\n\t        xforms: \"http://www.w3.org/2002/xforms\",\n\t        xlink: \"http://www.w3.org/1999/xlink\",\n\t        xml: \"http://www.w3.org/XML/1998/namespace\"\n\t    },\n\t    prefixMap: {},\n\t    configns: \"urn:oasis:names:tc:opendocument:xmlns:config:1.0\",\n\t    dbns: \"urn:oasis:names:tc:opendocument:xmlns:database:1.0\",\n\t    dcns: \"http://purl.org/dc/elements/1.1/\",\n\t    dr3dns: \"urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0\",\n\t    drawns: \"urn:oasis:names:tc:opendocument:xmlns:drawing:1.0\",\n\t    chartns: \"urn:oasis:names:tc:opendocument:xmlns:chart:1.0\",\n\t    fons: \"urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0\",\n\t    formns: \"urn:oasis:names:tc:opendocument:xmlns:form:1.0\",\n\t    mathns: \"http://www.w3.org/1998/Math/MathML\",\n\t    metans: \"urn:oasis:names:tc:opendocument:xmlns:meta:1.0\",\n\t    numberns: \"urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0\",\n\t    officens: \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\",\n\t    presentationns: \"urn:oasis:names:tc:opendocument:xmlns:presentation:1.0\",\n\t    stylens: \"urn:oasis:names:tc:opendocument:xmlns:style:1.0\",\n\t    svgns: \"urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0\",\n\t    tablens: \"urn:oasis:names:tc:opendocument:xmlns:table:1.0\",\n\t    textns: \"urn:oasis:names:tc:opendocument:xmlns:text:1.0\",\n\t    xformsns: \"http://www.w3.org/2002/xforms\",\n\t    xlinkns: \"http://www.w3.org/1999/xlink\",\n\t    xmlns: \"http://www.w3.org/XML/1998/namespace\"\n\t};\n\t(function() {\n\t    var g = odf.Namespaces.namespaceMap, k = odf.Namespaces.prefixMap, d;\n\t    for (d in g)\n\t        g.hasOwnProperty(d) && (k[g[d]] = d)\n\t}\n\t)();\n\todf.Namespaces.forEachPrefix = function(g) {\n\t    var k = odf.Namespaces.namespaceMap, d;\n\t    for (d in k)\n\t        k.hasOwnProperty(d) && g(d, k[d])\n\t}\n\t;\n\todf.Namespaces.lookupNamespaceURI = function(g) {\n\t    var k = null;\n\t    odf.Namespaces.namespaceMap.hasOwnProperty(g) && (k = odf.Namespaces.namespaceMap[g]);\n\t    return k\n\t}\n\t;\n\todf.Namespaces.lookupPrefix = function(g) {\n\t    var k = odf.Namespaces.prefixMap;\n\t    return k.hasOwnProperty(g) ? k[g] : null\n\t}\n\t;\n\todf.Namespaces.lookupNamespaceURI.lookupNamespaceURI = odf.Namespaces.lookupNamespaceURI;\n\t(function() {\n\t    odf.OdfSchemaImpl = function() {\n\t        var g = [[\"config:config-item\", \"uncategorized\"], [\"form:item\", \"object\"], [\"form:option\", \"uncategorized\"], [\"math:math\", \"field\"], [\"meta:user-defined\", \"uncategorized\"], [\"number:currency-symbol\", \"uncategorized\"], [\"number:embedded-text\", \"uncategorized\"], [\"number:text\", \"uncategorized\"], [\"presentation:date-time-decl\", \"uncategorized\"], [\"presentation:footer-decl\", \"uncategorized\"], [\"presentation:header-decl\", \"uncategorized\"], [\"svg:desc\", \"text\"], [\"svg:title\", \"text\"], [\"table:desc\", \"uncategorized\"], [\"table:title\", \"uncategorized\"], [\"text:a\", \"text\"], [\"text:author-initials\", \"field\"], [\"text:author-name\", \"field\"], [\"text:bibliography-mark\", \"field\"], [\"text:bookmark-ref\", \"field\"], [\"text:chapter\", \"field\"], [\"text:character-count\", \"field\"], [\"text:conditional-text\", \"field\"], [\"text:creation-date\", \"field\"], [\"text:creation-time\", \"field\"], [\"text:creator\", \"field\"], [\"text:database-display\", \"field\"], [\"text:database-name\", \"field\"], [\"text:database-row-number\", \"field\"], [\"text:date\", \"field\"], [\"text:dde-connection\", \"field\"], [\"text:description\", \"field\"], [\"text:editing-cycles\", \"field\"], [\"text:editing-duration\", \"field\"], [\"text:execute-macro\", \"uncategorized\"], [\"text:expression\", \"uncategorized\"], [\"text:file-name\", \"field\"], [\"text:h\", \"text\"], [\"text:hidden-paragraph\", \"text\"], [\"text:hidden-text\", \"text\"], [\"text:image-count\", \"field\"], [\"text:index-entry-span\", \"uncategorized\"], [\"text:index-title-template\", \"uncategorized\"], [\"text:initial-creator\", \"field\"], [\"text:keywords\", \"field\"], [\"text:linenumbering-separator\", \"style\"], [\"text:measure\", \"uncategorized\"], [\"text:meta\", \"uncategorized\"], [\"text:meta-field\", \"uncategorized\"], [\"text:modification-date\", \"field\"], [\"text:modification-time\", \"field\"], [\"text:note-citation\", \"field\"], [\"text:note-continuation-notice-backward\", \"style\"], [\"text:note-continuation-notice-forward\", \"style\"], [\"text:note-ref\", \"field\"], [\"text:object-count\", \"field\"], [\"text:p\", \"text\"], [\"text:page-continuation\", \"uncategorized\"], [\"text:page-count\", \"field\"], [\"text:page-number\", \"field\"], [\"text:page-variable-get\", \"field\"], [\"text:page-variable-set\", \"field\"], [\"text:paragraph-count\", \"field\"], [\"text:placeholder\", \"field\"], [\"text:print-date\", \"field\"], [\"text:print-time\", \"field\"], [\"text:printed-by\", \"field\"], [\"text:reference-ref\", \"field\"], [\"text:ruby-base\", \"text\"], [\"text:ruby-text\", \"text\"], [\"text:script\", \"text\"], [\"text:sender-city\", \"field\"], [\"text:sender-company\", \"field\"], [\"text:sender-country\", \"field\"], [\"text:sender-email\", \"field\"], [\"text:sender-fax\", \"field\"], [\"text:sender-firstname\", \"field\"], [\"text:sender-initials\", \"field\"], [\"text:sender-lastname\", \"field\"], [\"text:sender-phone-private\", \"field\"], [\"text:sender-phone-work\", \"field\"], [\"text:sender-position\", \"field\"], [\"text:sender-postal-code\", \"field\"], [\"text:sender-state-or-province\", \"field\"], [\"text:sender-street\", \"field\"], [\"text:sender-title\", \"field\"], [\"text:sequence\", \"uncategorized\"], [\"text:sequence-ref\", \"uncategorized\"], [\"text:sheet-name\", \"uncategorized\"], [\"text:span\", \"text\"], [\"text:subject\", \"field\"], [\"text:table-count\", \"field\"], [\"text:table-formula\", \"deprecated\"], [\"text:template-name\", \"uncategorized\"], [\"text:text-input\", \"field\"], [\"text:time\", \"field\"], [\"text:title\", \"field\"], [\"text:user-defined\", \"field\"], [\"text:user-field-get\", \"field\"], [\"text:user-field-input\", \"field\"], [\"text:variable-get\", \"field\"], [\"text:variable-input\", \"field\"], [\"text:variable-set\", \"field\"], [\"text:word-count\", \"field\"], [\"xforms:model\", \"uncategorized\"]]\n\t          , k = {};\n\t        this.isTextContainer = function(d, b) {\n\t            return \"text\" === k[d + \":\" + b]\n\t        }\n\t        ;\n\t        this.isField = function(d, b) {\n\t            return \"field\" === k[d + \":\" + b]\n\t        }\n\t        ;\n\t        this.getFields = function() {\n\t            return g.filter(function(d) {\n\t                return \"field\" === d[1]\n\t            }).map(function(d) {\n\t                return d[0]\n\t            })\n\t        }\n\t        ;\n\t        (function() {\n\t            g.forEach(function(d) {\n\t                var b = d[1]\n\t                  , f = d[0].split(\":\");\n\t                d = f[0];\n\t                var f = f[1]\n\t                  , n = odf.Namespaces.lookupNamespaceURI(d);\n\t                n ? k[n + \":\" + f] = b : runtime.log(\"DEBUG: OdfSchema - unknown prefix '\" + d + \"'\")\n\t            })\n\t        }\n\t        )()\n\t    }\n\t    ;\n\t    odf.OdfSchema = new odf.OdfSchemaImpl\n\t}\n\t)();\n\todf.OdfUtilsImpl = function() {\n\t    function g(a) {\n\t        return \"image\" === (a && a.localName) && a.namespaceURI === R\n\t    }\n\t    function k(a) {\n\t        return null !== a && a.nodeType === Node.ELEMENT_NODE && \"frame\" === a.localName && a.namespaceURI === R && \"as-char\" === a.getAttributeNS(J, \"anchor-type\")\n\t    }\n\t    function d(a) {\n\t        var c;\n\t        (c = \"annotation\" === (a && a.localName) && a.namespaceURI === odf.Namespaces.officens) || (c = \"div\" === (a && a.localName) && \"annotationWrapper\" === a.className);\n\t        return c\n\t    }\n\t    function b(a) {\n\t        return \"a\" === (a && a.localName) && a.namespaceURI === J\n\t    }\n\t    function f(a) {\n\t        var c = a && a.localName;\n\t        return (\"p\" === c || \"h\" === c) && a.namespaceURI === J\n\t    }\n\t    function n(a, c) {\n\t        for (a && void 0 !== c && !f(a) && a.childNodes.item(c) && (a = a.childNodes.item(c)); a && !f(a); )\n\t            a = a.parentNode;\n\t        return a\n\t    }\n\t    function p(a, c) {\n\t        for (; a && a !== c; ) {\n\t            if (a.namespaceURI === odf.Namespaces.officens && \"annotation\" === a.localName)\n\t                return a;\n\t            a = a.parentNode\n\t        }\n\t        return null\n\t    }\n\t    function r(a) {\n\t        return /^[ \\t\\r\\n]+$/.test(a)\n\t    }\n\t    function q(a) {\n\t        if (null === a || a.nodeType !== Node.ELEMENT_NODE)\n\t            return !1;\n\t        var c = a.localName;\n\t        return fa.isTextContainer(a.namespaceURI, c) || \"span\" === c && \"webodf-annotationHighlight\" === a.className\n\t    }\n\t    function e(a) {\n\t        return null === a || a.nodeType !== Node.ELEMENT_NODE ? !1 : fa.isField(a.namespaceURI, a.localName)\n\t    }\n\t    function l(a) {\n\t        var c = a && a.localName\n\t          , b = !1;\n\t        c && (a = a.namespaceURI,\n\t        a === J && (b = \"s\" === c || \"tab\" === c || \"line-break\" === c));\n\t        return b\n\t    }\n\t    function a(a) {\n\t        return l(a) || e(a) || k(a) || d(a)\n\t    }\n\t    function c(a) {\n\t        var c = a && a.localName\n\t          , b = !1;\n\t        c && (a = a.namespaceURI,\n\t        a === J && (b = \"s\" === c));\n\t        return b\n\t    }\n\t    function m(a) {\n\t        return -1 !== S.indexOf(a.namespaceURI)\n\t    }\n\t    function h(a) {\n\t        if (l(a) || e(a))\n\t            return !1;\n\t        if (q(a.parentNode) && a.nodeType === Node.TEXT_NODE)\n\t            return 0 === a.textContent.length;\n\t        for (a = a.firstChild; a; ) {\n\t            if (m(a) || !h(a))\n\t                return !1;\n\t            a = a.nextSibling\n\t        }\n\t        return !0\n\t    }\n\t    function y(a) {\n\t        for (; null !== a.firstChild && q(a); )\n\t            a = a.firstChild;\n\t        return a\n\t    }\n\t    function x(a) {\n\t        for (; null !== a.lastChild && q(a); )\n\t            a = a.lastChild;\n\t        return a\n\t    }\n\t    function z(a) {\n\t        for (; !f(a) && null === a.previousSibling; )\n\t            a = a.parentNode;\n\t        return f(a) ? null : x(a.previousSibling)\n\t    }\n\t    function w(a) {\n\t        for (; !f(a) && null === a.nextSibling; )\n\t            a = a.parentNode;\n\t        return f(a) ? null : y(a.nextSibling)\n\t    }\n\t    function v(b) {\n\t        for (var d = !1; b; )\n\t            if (b.nodeType === Node.TEXT_NODE)\n\t                if (0 === b.length)\n\t                    b = z(b);\n\t                else\n\t                    return !r(b.data.substr(b.length - 1, 1));\n\t            else\n\t                a(b) ? (d = !1 === c(b),\n\t                b = null) : b = z(b);\n\t        return d\n\t    }\n\t    function u(c) {\n\t        var b = !1, d;\n\t        for (c = c && y(c); c; ) {\n\t            d = c.nodeType === Node.TEXT_NODE ? c.length : 0;\n\t            if (0 < d && !r(c.data)) {\n\t                b = !0;\n\t                break\n\t            }\n\t            if (a(c)) {\n\t                b = !0;\n\t                break\n\t            }\n\t            c = w(c)\n\t        }\n\t        return b\n\t    }\n\t    function t(a, c) {\n\t        return r(a.data.substr(c)) ? !u(w(a)) : !1\n\t    }\n\t    function A(c, b) {\n\t        var d = c.data, m;\n\t        if (!r(d[b]) || a(c.parentNode))\n\t            return !1;\n\t        0 < b ? r(d[b - 1]) || (m = !0) : v(z(c)) && (m = !0);\n\t        return !0 === m ? t(c, b) ? !1 : !0 : !1\n\t    }\n\t    function I(a) {\n\t        return (a = /(-?[0-9]*[0-9][0-9]*(\\.[0-9]*)?|0+\\.[0-9]*[1-9][0-9]*|\\.[0-9]*[1-9][0-9]*)((cm)|(mm)|(in)|(pt)|(pc)|(px)|(%))/.exec(a)) ? {\n\t            value: parseFloat(a[1]),\n\t            unit: a[3]\n\t        } : null\n\t    }\n\t    function K(a) {\n\t        return (a = I(a)) && (0 > a.value || \"%\" === a.unit) ? null : a\n\t    }\n\t    function L(a) {\n\t        return (a = I(a)) && \"%\" !== a.unit ? null : a\n\t    }\n\t    function E(a) {\n\t        switch (a.namespaceURI) {\n\t        case odf.Namespaces.drawns:\n\t        case odf.Namespaces.svgns:\n\t        case odf.Namespaces.dr3dns:\n\t            return !1;\n\t        case odf.Namespaces.textns:\n\t            switch (a.localName) {\n\t            case \"note-body\":\n\t            case \"ruby-text\":\n\t                return !1\n\t            }\n\t            break;\n\t        case odf.Namespaces.officens:\n\t            switch (a.localName) {\n\t            case \"annotation\":\n\t            case \"binary-data\":\n\t            case \"event-listeners\":\n\t                return !1\n\t            }\n\t            break;\n\t        default:\n\t            switch (a.localName) {\n\t            case \"cursor\":\n\t            case \"editinfo\":\n\t                return !1\n\t            }\n\t        }\n\t        return !0\n\t    }\n\t    function N(a) {\n\t        return Boolean(n(a) && (!r(a.textContent) || A(a, 0)))\n\t    }\n\t    function O(a, c) {\n\t        for (; 0 < c.length && !aa.rangeContainsNode(a, c[0]); )\n\t            c.shift();\n\t        for (; 0 < c.length && !aa.rangeContainsNode(a, c[c.length - 1]); )\n\t            c.pop()\n\t    }\n\t    function D(c, b, m) {\n\t        var h;\n\t        h = aa.getNodesInRange(c, function(c) {\n\t            var b = NodeFilter.FILTER_REJECT;\n\t            if (l(c.parentNode) || e(c.parentNode) || d(c))\n\t                b = NodeFilter.FILTER_REJECT;\n\t            else if (c.nodeType === Node.TEXT_NODE) {\n\t                if (m || N(c))\n\t                    b = NodeFilter.FILTER_ACCEPT\n\t            } else if (a(c))\n\t                b = NodeFilter.FILTER_ACCEPT;\n\t            else if (E(c) || q(c))\n\t                b = NodeFilter.FILTER_SKIP;\n\t            return b\n\t        }, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT);\n\t        b || O(c, h);\n\t        return h\n\t    }\n\t    function V(a, c, b) {\n\t        for (; a; ) {\n\t            if (b(a)) {\n\t                c[0] !== a && c.unshift(a);\n\t                break\n\t            }\n\t            if (d(a))\n\t                break;\n\t            a = a.parentNode\n\t        }\n\t    }\n\t    function W(a, c) {\n\t        var b = a;\n\t        if (c < b.childNodes.length - 1)\n\t            b = b.childNodes[c + 1];\n\t        else {\n\t            for (; !b.nextSibling; )\n\t                b = b.parentNode;\n\t            b = b.nextSibling\n\t        }\n\t        for (; b.firstChild; )\n\t            b = b.firstChild;\n\t        return b\n\t    }\n\t    var J = odf.Namespaces.textns\n\t      , R = odf.Namespaces.drawns\n\t      , P = odf.Namespaces.xlinkns\n\t      , aa = core.DomUtils\n\t      , S = [odf.Namespaces.dbns, odf.Namespaces.dcns, odf.Namespaces.dr3dns, odf.Namespaces.drawns, odf.Namespaces.chartns, odf.Namespaces.formns, odf.Namespaces.numberns, odf.Namespaces.officens, odf.Namespaces.presentationns, odf.Namespaces.stylens, odf.Namespaces.svgns, odf.Namespaces.tablens, odf.Namespaces.textns]\n\t      , fa = odf.OdfSchema;\n\t    this.isImage = g;\n\t    this.isCharacterFrame = k;\n\t    this.isInlineRoot = d;\n\t    this.isTextSpan = function(a) {\n\t        return \"span\" === (a && a.localName) && a.namespaceURI === J\n\t    }\n\t    ;\n\t    this.isHyperlink = b;\n\t    this.getHyperlinkTarget = function(a) {\n\t        return a.getAttributeNS(P, \"href\") || \"\"\n\t    }\n\t    ;\n\t    this.isParagraph = f;\n\t    this.getParagraphElement = n;\n\t    this.getParentAnnotation = p;\n\t    this.isWithinAnnotation = function(a, c) {\n\t        return Boolean(p(a, c))\n\t    }\n\t    ;\n\t    this.getAnnotationCreator = function(a) {\n\t        return a.getElementsByTagNameNS(odf.Namespaces.dcns, \"creator\")[0].textContent\n\t    }\n\t    ;\n\t    this.isListItem = function(a) {\n\t        return \"list-item\" === (a && a.localName) && a.namespaceURI === J\n\t    }\n\t    ;\n\t    this.isLineBreak = function(a) {\n\t        return \"line-break\" === (a && a.localName) && a.namespaceURI === J\n\t    }\n\t    ;\n\t    this.isODFWhitespace = r;\n\t    this.isGroupingElement = q;\n\t    this.isFieldElement = e;\n\t    this.isCharacterElement = l;\n\t    this.isAnchoredAsCharacterElement = a;\n\t    this.isSpaceElement = c;\n\t    this.isODFNode = m;\n\t    this.hasNoODFContent = h;\n\t    this.firstChild = y;\n\t    this.lastChild = x;\n\t    this.previousNode = z;\n\t    this.nextNode = w;\n\t    this.scanLeftForNonSpace = v;\n\t    this.lookLeftForCharacter = function(c) {\n\t        var b, d = b = 0;\n\t        c.nodeType === Node.TEXT_NODE && (d = c.length);\n\t        0 < d ? (b = c.data,\n\t        b = r(b.substr(d - 1, 1)) ? 1 === d ? v(z(c)) ? 2 : 0 : r(b.substr(d - 2, 1)) ? 0 : 2 : 1) : a(c) && (b = 1);\n\t        return b\n\t    }\n\t    ;\n\t    this.lookRightForCharacter = function(c) {\n\t        var b = !1\n\t          , d = 0;\n\t        c && c.nodeType === Node.TEXT_NODE && (d = c.length);\n\t        0 < d ? b = !r(c.data.substr(0, 1)) : a(c) && (b = !0);\n\t        return b\n\t    }\n\t    ;\n\t    this.scanLeftForAnyCharacter = function(c) {\n\t        var b = !1, d;\n\t        for (c = c && x(c); c; ) {\n\t            d = c.nodeType === Node.TEXT_NODE ? c.length : 0;\n\t            if (0 < d && !r(c.data)) {\n\t                b = !0;\n\t                break\n\t            }\n\t            if (a(c)) {\n\t                b = !0;\n\t                break\n\t            }\n\t            c = z(c)\n\t        }\n\t        return b\n\t    }\n\t    ;\n\t    this.scanRightForAnyCharacter = u;\n\t    this.isTrailingWhitespace = t;\n\t    this.isSignificantWhitespace = A;\n\t    this.isDowngradableSpaceElement = function(a) {\n\t        return c(a) ? v(z(a)) && u(w(a)) : !1\n\t    }\n\t    ;\n\t    this.parseLength = I;\n\t    this.parseNonNegativeLength = K;\n\t    this.parseFoFontSize = function(a) {\n\t        var c;\n\t        c = (c = I(a)) && (0 >= c.value || \"%\" === c.unit) ? null : c;\n\t        return c || L(a)\n\t    }\n\t    ;\n\t    this.parseFoLineHeight = function(a) {\n\t        return K(a) || L(a)\n\t    }\n\t    ;\n\t    this.isTextContentContainingNode = E;\n\t    this.getTextNodes = function(a, c) {\n\t        var b;\n\t        b = aa.getNodesInRange(a, function(a) {\n\t            var c = NodeFilter.FILTER_REJECT;\n\t            a.nodeType === Node.TEXT_NODE ? N(a) && (c = NodeFilter.FILTER_ACCEPT) : E(a) && (c = NodeFilter.FILTER_SKIP);\n\t            return c\n\t        }, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT);\n\t        c || O(a, b);\n\t        return b\n\t    }\n\t    ;\n\t    this.getTextElements = D;\n\t    this.getParagraphElements = function(a) {\n\t        var c;\n\t        c = aa.getNodesInRange(a, function(a) {\n\t            var c = NodeFilter.FILTER_REJECT;\n\t            if (f(a))\n\t                c = NodeFilter.FILTER_ACCEPT;\n\t            else if (E(a) || q(a))\n\t                c = NodeFilter.FILTER_SKIP;\n\t            return c\n\t        }, NodeFilter.SHOW_ELEMENT);\n\t        V(a.startContainer, c, f);\n\t        return c\n\t    }\n\t    ;\n\t    this.getImageElements = function(a) {\n\t        var c;\n\t        c = aa.getNodesInRange(a, function(a) {\n\t            var c = NodeFilter.FILTER_SKIP;\n\t            g(a) && (c = NodeFilter.FILTER_ACCEPT);\n\t            return c\n\t        }, NodeFilter.SHOW_ELEMENT);\n\t        V(a.startContainer, c, g);\n\t        return c\n\t    }\n\t    ;\n\t    this.getHyperlinkElements = function(a) {\n\t        var c = []\n\t          , d = a.cloneRange();\n\t        a.collapsed && a.endContainer.nodeType === Node.ELEMENT_NODE && (a = W(a.endContainer, a.endOffset),\n\t        a.nodeType === Node.TEXT_NODE && d.setEnd(a, 1));\n\t        D(d, !0, !1).forEach(function(a) {\n\t            for (a = a.parentNode; !f(a); ) {\n\t                if (b(a) && -1 === c.indexOf(a)) {\n\t                    c.push(a);\n\t                    break\n\t                }\n\t                a = a.parentNode\n\t            }\n\t        });\n\t        d.detach();\n\t        return c\n\t    }\n\t    ;\n\t    this.getNormalizedFontFamilyName = function(a) {\n\t        /^([\"'])(?:.|[\\n\\r])*?\\1$/.test(a) || (a = a.replace(/^[ \\t\\r\\n\\f]*((?:.|[\\n\\r])*?)[ \\t\\r\\n\\f]*$/, \"$1\"),\n\t        /[ \\t\\r\\n\\f]/.test(a) && (a = \"'\" + a.replace(/[ \\t\\r\\n\\f]+/g, \" \") + \"'\"));\n\t        return a\n\t    }\n\t}\n\t;\n\todf.OdfUtils = new odf.OdfUtilsImpl;\n\tgui.OdfTextBodyNodeFilter = function() {\n\t    var g = odf.OdfUtils\n\t      , k = Node.TEXT_NODE\n\t      , d = NodeFilter.FILTER_REJECT\n\t      , b = NodeFilter.FILTER_ACCEPT\n\t      , f = odf.Namespaces.textns;\n\t    this.acceptNode = function(n) {\n\t        if (n.nodeType === k) {\n\t            if (!g.isGroupingElement(n.parentNode))\n\t                return d\n\t        } else if (n.namespaceURI === f && \"tracked-changes\" === n.localName)\n\t            return d;\n\t        return b\n\t    }\n\t}\n\t;\n\txmldom.LSSerializerFilter = function() {}\n\t;\n\txmldom.LSSerializerFilter.prototype.acceptNode = function(g) {}\n\t;\n\todf.OdfNodeFilter = function() {\n\t    this.acceptNode = function(g) {\n\t        return \"http://www.w3.org/1999/xhtml\" === g.namespaceURI ? NodeFilter.FILTER_SKIP : g.namespaceURI && g.namespaceURI.match(/^urn:webodf:/) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT\n\t    }\n\t}\n\t;\n\txmldom.XPathIterator = function() {}\n\t;\n\txmldom.XPathIterator.prototype.next = function() {}\n\t;\n\txmldom.XPathIterator.prototype.reset = function() {}\n\t;\n\tfunction createXPathSingleton() {\n\t    function g(b, a, c) {\n\t        return -1 !== b && (b < a || -1 === a) && (b < c || -1 === c)\n\t    }\n\t    function k(b) {\n\t        for (var a = [], c = 0, d = b.length, h; c < d; ) {\n\t            var f = b\n\t              , n = d\n\t              , k = a\n\t              , r = \"\"\n\t              , p = []\n\t              , q = f.indexOf(\"[\", c)\n\t              , t = f.indexOf(\"/\", c)\n\t              , A = f.indexOf(\"=\", c);\n\t            g(t, q, A) ? (r = f.substring(c, t),\n\t            c = t + 1) : g(q, t, A) ? (r = f.substring(c, q),\n\t            c = e(f, q, p)) : g(A, t, q) ? (r = f.substring(c, A),\n\t            c = A) : (r = f.substring(c, n),\n\t            c = n);\n\t            k.push({\n\t                location: r,\n\t                predicates: p\n\t            });\n\t            if (c < d && \"=\" === b[c]) {\n\t                h = b.substring(c + 1, d);\n\t                if (2 < h.length && (\"'\" === h[0] || '\"' === h[0]))\n\t                    h = h.slice(1, h.length - 1);\n\t                else\n\t                    try {\n\t                        h = parseInt(h, 10)\n\t                    } catch (I) {}\n\t                c = d\n\t            }\n\t        }\n\t        return {\n\t            steps: a,\n\t            value: h\n\t        }\n\t    }\n\t    function d() {\n\t        var b = null\n\t          , a = !1;\n\t        this.setNode = function(a) {\n\t            b = a\n\t        }\n\t        ;\n\t        this.reset = function() {\n\t            a = !1\n\t        }\n\t        ;\n\t        this.next = function() {\n\t            var c = a ? null : b;\n\t            a = !0;\n\t            return c\n\t        }\n\t    }\n\t    function b(b, a, c) {\n\t        this.reset = function() {\n\t            b.reset()\n\t        }\n\t        ;\n\t        this.next = function() {\n\t            for (var d = b.next(); d; ) {\n\t                d.nodeType === Node.ELEMENT_NODE && (d = d.getAttributeNodeNS(a, c));\n\t                if (d)\n\t                    break;\n\t                d = b.next()\n\t            }\n\t            return d\n\t        }\n\t    }\n\t    function f(b, a) {\n\t        var c = b.next()\n\t          , d = null;\n\t        this.reset = function() {\n\t            b.reset();\n\t            c = b.next();\n\t            d = null\n\t        }\n\t        ;\n\t        this.next = function() {\n\t            for (; c; ) {\n\t                if (d)\n\t                    if (a && d.firstChild)\n\t                        d = d.firstChild;\n\t                    else {\n\t                        for (; !d.nextSibling && d !== c; )\n\t                            d = d.parentNode;\n\t                        d === c ? c = b.next() : d = d.nextSibling\n\t                    }\n\t                else {\n\t                    do\n\t                        (d = c.firstChild) || (c = b.next());\n\t                    while (c && !d)\n\t                }\n\t                if (d && d.nodeType === Node.ELEMENT_NODE)\n\t                    return d\n\t            }\n\t            return null\n\t        }\n\t    }\n\t    function n(b, a) {\n\t        this.reset = function() {\n\t            b.reset()\n\t        }\n\t        ;\n\t        this.next = function() {\n\t            for (var c = b.next(); c && !a(c); )\n\t                c = b.next();\n\t            return c\n\t        }\n\t    }\n\t    function p(b, a, c) {\n\t        a = a.split(\":\", 2);\n\t        var d = c(a[0])\n\t          , h = a[1];\n\t        return new n(b,function(a) {\n\t            return a.localName === h && a.namespaceURI === d\n\t        }\n\t        )\n\t    }\n\t    function r(b, a, c) {\n\t        var m = new d\n\t          , h = q(m, a, c)\n\t          , e = a.value;\n\t        return void 0 === e ? new n(b,function(a) {\n\t            m.setNode(a);\n\t            h.reset();\n\t            return null !== h.next()\n\t        }\n\t        ) : new n(b,function(a) {\n\t            m.setNode(a);\n\t            h.reset();\n\t            return (a = h.next()) ? a.nodeValue === e : !1\n\t        }\n\t        )\n\t    }\n\t    var q, e;\n\t    e = function(b, a, c) {\n\t        for (var d = a, h = b.length, e = 0; d < h; )\n\t            \"]\" === b[d] ? (--e,\n\t            0 >= e && c.push(k(b.substring(a, d)))) : \"[\" === b[d] && (0 >= e && (a = d + 1),\n\t            e += 1),\n\t            d += 1;\n\t        return d\n\t    }\n\t    ;\n\t    q = function(d, a, c) {\n\t        var m, h, e, n;\n\t        for (m = 0; m < a.steps.length; m += 1) {\n\t            e = a.steps[m];\n\t            h = e.location;\n\t            if (\"\" === h)\n\t                d = new f(d,!1);\n\t            else if (\"@\" === h[0]) {\n\t                h = h.substr(1).split(\":\", 2);\n\t                n = c(h[0]);\n\t                if (!n)\n\t                    throw \"No namespace associated with the prefix \" + h[0];\n\t                d = new b(d,n,h[1])\n\t            } else\n\t                \".\" !== h && (d = new f(d,!1),\n\t                -1 !== h.indexOf(\":\") && (d = p(d, h, c)));\n\t            for (h = 0; h < e.predicates.length; h += 1)\n\t                n = e.predicates[h],\n\t                d = r(d, n, c)\n\t        }\n\t        return d\n\t    }\n\t    ;\n\t    return {\n\t        getODFElementsWithXPath: function(b, a, c) {\n\t            var m = b.ownerDocument\n\t              , h = []\n\t              , e = null;\n\t            if (m && \"function\" === typeof m.evaluate)\n\t                for (c = m.evaluate(a, b, c, XPathResult.UNORDERED_NODE_ITERATOR_TYPE, null),\n\t                e = c.iterateNext(); null !== e; )\n\t                    e.nodeType === Node.ELEMENT_NODE && h.push(e),\n\t                    e = c.iterateNext();\n\t            else {\n\t                h = new d;\n\t                h.setNode(b);\n\t                b = k(a);\n\t                h = q(h, b, c);\n\t                b = [];\n\t                for (c = h.next(); c; )\n\t                    b.push(c),\n\t                    c = h.next();\n\t                h = b\n\t            }\n\t            return h\n\t        }\n\t    }\n\t}\n\txmldom.XPath = createXPathSingleton();\n\todf.StyleInfo = function() {\n\t    function g(a, c) {\n\t        var b, d, h, m, e, l = 0;\n\t        if (b = K[a.localName])\n\t            if (h = b[a.namespaceURI])\n\t                l = h.length;\n\t        for (b = 0; b < l; b += 1)\n\t            d = h[b],\n\t            m = d.ns,\n\t            e = d.localname,\n\t            (d = a.getAttributeNS(m, e)) && a.setAttributeNS(m, A[m] + e, c + d);\n\t        for (h = a.firstElementChild; h; )\n\t            g(h, c),\n\t            h = h.nextElementSibling\n\t    }\n\t    function k(a, c) {\n\t        var b, d, h, m, e, l = 0;\n\t        if (b = K[a.localName])\n\t            if (h = b[a.namespaceURI])\n\t                l = h.length;\n\t        for (b = 0; b < l; b += 1)\n\t            if (d = h[b],\n\t            m = d.ns,\n\t            e = d.localname,\n\t            d = a.getAttributeNS(m, e))\n\t                d = d.replace(c, \"\"),\n\t                a.setAttributeNS(m, A[m] + e, d);\n\t        for (h = a.firstElementChild; h; )\n\t            k(h, c),\n\t            h = h.nextElementSibling\n\t    }\n\t    function d(a, c) {\n\t        var b, d, h, m, e, l = 0;\n\t        if (b = K[a.localName])\n\t            if (h = b[a.namespaceURI])\n\t                l = h.length;\n\t        for (b = 0; b < l; b += 1)\n\t            if (m = h[b],\n\t            d = m.ns,\n\t            e = m.localname,\n\t            d = a.getAttributeNS(d, e))\n\t                c = c || {},\n\t                m = m.keyname,\n\t                c.hasOwnProperty(m) ? c[m][d] = 1 : (e = {},\n\t                e[d] = 1,\n\t                c[m] = e);\n\t        return c\n\t    }\n\t    function b(a, c) {\n\t        var h, m;\n\t        d(a, c);\n\t        for (h = a.firstChild; h; )\n\t            h.nodeType === Node.ELEMENT_NODE && (m = h,\n\t            b(m, c)),\n\t            h = h.nextSibling\n\t    }\n\t    function f(a, c, b) {\n\t        this.key = a;\n\t        this.name = c;\n\t        this.family = b;\n\t        this.requires = {}\n\t    }\n\t    function n(a, c, b) {\n\t        var d = a + '\"' + c\n\t          , h = b[d];\n\t        h || (h = b[d] = new f(d,a,c));\n\t        return h\n\t    }\n\t    function p(a, c, b) {\n\t        var d, h, m, e, l, f = 0;\n\t        d = a.getAttributeNS(v, \"name\");\n\t        e = a.getAttributeNS(v, \"family\");\n\t        d && e && (c = n(d, e, b));\n\t        if (c) {\n\t            if (d = K[a.localName])\n\t                if (m = d[a.namespaceURI])\n\t                    f = m.length;\n\t            for (d = 0; d < f; d += 1)\n\t                if (e = m[d],\n\t                h = e.ns,\n\t                l = e.localname,\n\t                h = a.getAttributeNS(h, l))\n\t                    e = e.keyname,\n\t                    e = n(h, e, b),\n\t                    c.requires[e.key] = e\n\t        }\n\t        for (a = a.firstElementChild; a; )\n\t            p(a, c, b),\n\t            a = a.nextElementSibling;\n\t        return b\n\t    }\n\t    function r(a, c) {\n\t        var b = c[a.family];\n\t        b || (b = c[a.family] = {});\n\t        b[a.name] = 1;\n\t        Object.keys(a.requires).forEach(function(b) {\n\t            r(a.requires[b], c)\n\t        })\n\t    }\n\t    function q(a, c) {\n\t        var b = p(a, null, {});\n\t        Object.keys(b).forEach(function(a) {\n\t            a = b[a];\n\t            var d = c[a.family];\n\t            d && d.hasOwnProperty(a.name) && r(a, c)\n\t        })\n\t    }\n\t    function e(a, c) {\n\t        function b(c) {\n\t            (c = m.getAttributeNS(v, c)) && (a[c] = !0)\n\t        }\n\t        var d = [\"font-name\", \"font-name-asian\", \"font-name-complex\"], h, m;\n\t        for (h = c && c.firstElementChild; h; )\n\t            m = h,\n\t            d.forEach(b),\n\t            e(a, m),\n\t            h = h.nextElementSibling\n\t    }\n\t    function l(a, c) {\n\t        function b(a) {\n\t            var d = m.getAttributeNS(v, a);\n\t            d && c.hasOwnProperty(d) && m.setAttributeNS(v, \"style:\" + a, c[d])\n\t        }\n\t        var d = [\"font-name\", \"font-name-asian\", \"font-name-complex\"], h, m;\n\t        for (h = a && a.firstElementChild; h; )\n\t            m = h,\n\t            d.forEach(b),\n\t            l(m, c),\n\t            h = h.nextElementSibling\n\t    }\n\t    var a = odf.Namespaces.chartns, c = odf.Namespaces.dbns, m = odf.Namespaces.dr3dns, h = odf.Namespaces.drawns, y = odf.Namespaces.formns, x = odf.Namespaces.numberns, z = odf.Namespaces.officens, w = odf.Namespaces.presentationns, v = odf.Namespaces.stylens, u = odf.Namespaces.tablens, t = odf.Namespaces.textns, A = {\n\t        \"urn:oasis:names:tc:opendocument:xmlns:chart:1.0\": \"chart:\",\n\t        \"urn:oasis:names:tc:opendocument:xmlns:database:1.0\": \"db:\",\n\t        \"urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0\": \"dr3d:\",\n\t        \"urn:oasis:names:tc:opendocument:xmlns:drawing:1.0\": \"draw:\",\n\t        \"urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0\": \"fo:\",\n\t        \"urn:oasis:names:tc:opendocument:xmlns:form:1.0\": \"form:\",\n\t        \"urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0\": \"number:\",\n\t        \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\": \"office:\",\n\t        \"urn:oasis:names:tc:opendocument:xmlns:presentation:1.0\": \"presentation:\",\n\t        \"urn:oasis:names:tc:opendocument:xmlns:style:1.0\": \"style:\",\n\t        \"urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0\": \"svg:\",\n\t        \"urn:oasis:names:tc:opendocument:xmlns:table:1.0\": \"table:\",\n\t        \"urn:oasis:names:tc:opendocument:xmlns:text:1.0\": \"chart:\",\n\t        \"http://www.w3.org/XML/1998/namespace\": \"xml:\"\n\t    }, I = {\n\t        text: [{\n\t            ens: v,\n\t            en: \"tab-stop\",\n\t            ans: v,\n\t            a: \"leader-text-style\"\n\t        }, {\n\t            ens: v,\n\t            en: \"drop-cap\",\n\t            ans: v,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"notes-configuration\",\n\t            ans: t,\n\t            a: \"citation-body-style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"notes-configuration\",\n\t            ans: t,\n\t            a: \"citation-style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"a\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"alphabetical-index\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"linenumbering-configuration\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"list-level-style-number\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"ruby-text\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"span\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"a\",\n\t            ans: t,\n\t            a: \"visited-style-name\"\n\t        }, {\n\t            ens: v,\n\t            en: \"text-properties\",\n\t            ans: v,\n\t            a: \"text-line-through-text-style\"\n\t        }, {\n\t            ens: t,\n\t            en: \"alphabetical-index-source\",\n\t            ans: t,\n\t            a: \"main-entry-style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"index-entry-bibliography\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"index-entry-chapter\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"index-entry-link-end\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"index-entry-link-start\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"index-entry-page-number\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"index-entry-span\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"index-entry-tab-stop\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"index-entry-text\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"index-title-template\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"list-level-style-bullet\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"outline-level-style\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }],\n\t        paragraph: [{\n\t            ens: h,\n\t            en: \"caption\",\n\t            ans: h,\n\t            a: \"text-style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"circle\",\n\t            ans: h,\n\t            a: \"text-style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"connector\",\n\t            ans: h,\n\t            a: \"text-style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"control\",\n\t            ans: h,\n\t            a: \"text-style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"custom-shape\",\n\t            ans: h,\n\t            a: \"text-style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"ellipse\",\n\t            ans: h,\n\t            a: \"text-style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"frame\",\n\t            ans: h,\n\t            a: \"text-style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"line\",\n\t            ans: h,\n\t            a: \"text-style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"measure\",\n\t            ans: h,\n\t            a: \"text-style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"path\",\n\t            ans: h,\n\t            a: \"text-style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"polygon\",\n\t            ans: h,\n\t            a: \"text-style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"polyline\",\n\t            ans: h,\n\t            a: \"text-style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"rect\",\n\t            ans: h,\n\t            a: \"text-style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"regular-polygon\",\n\t            ans: h,\n\t            a: \"text-style-name\"\n\t        }, {\n\t            ens: z,\n\t            en: \"annotation\",\n\t            ans: h,\n\t            a: \"text-style-name\"\n\t        }, {\n\t            ens: y,\n\t            en: \"column\",\n\t            ans: y,\n\t            a: \"text-style-name\"\n\t        }, {\n\t            ens: v,\n\t            en: \"style\",\n\t            ans: v,\n\t            a: \"next-style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"body\",\n\t            ans: u,\n\t            a: \"paragraph-style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"even-columns\",\n\t            ans: u,\n\t            a: \"paragraph-style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"even-rows\",\n\t            ans: u,\n\t            a: \"paragraph-style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"first-column\",\n\t            ans: u,\n\t            a: \"paragraph-style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"first-row\",\n\t            ans: u,\n\t            a: \"paragraph-style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"last-column\",\n\t            ans: u,\n\t            a: \"paragraph-style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"last-row\",\n\t            ans: u,\n\t            a: \"paragraph-style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"odd-columns\",\n\t            ans: u,\n\t            a: \"paragraph-style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"odd-rows\",\n\t            ans: u,\n\t            a: \"paragraph-style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"notes-configuration\",\n\t            ans: t,\n\t            a: \"default-style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"alphabetical-index-entry-template\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"bibliography-entry-template\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"h\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"illustration-index-entry-template\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"index-source-style\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"object-index-entry-template\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"p\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"table-index-entry-template\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"table-of-content-entry-template\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"table-index-entry-template\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"user-index-entry-template\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: v,\n\t            en: \"page-layout-properties\",\n\t            ans: v,\n\t            a: \"register-truth-ref-style-name\"\n\t        }],\n\t        chart: [{\n\t            ens: a,\n\t            en: \"axis\",\n\t            ans: a,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: a,\n\t            en: \"chart\",\n\t            ans: a,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: a,\n\t            en: \"data-label\",\n\t            ans: a,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: a,\n\t            en: \"data-point\",\n\t            ans: a,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: a,\n\t            en: \"equation\",\n\t            ans: a,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: a,\n\t            en: \"error-indicator\",\n\t            ans: a,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: a,\n\t            en: \"floor\",\n\t            ans: a,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: a,\n\t            en: \"footer\",\n\t            ans: a,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: a,\n\t            en: \"grid\",\n\t            ans: a,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: a,\n\t            en: \"legend\",\n\t            ans: a,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: a,\n\t            en: \"mean-value\",\n\t            ans: a,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: a,\n\t            en: \"plot-area\",\n\t            ans: a,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: a,\n\t            en: \"regression-curve\",\n\t            ans: a,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: a,\n\t            en: \"series\",\n\t            ans: a,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: a,\n\t            en: \"stock-gain-marker\",\n\t            ans: a,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: a,\n\t            en: \"stock-loss-marker\",\n\t            ans: a,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: a,\n\t            en: \"stock-range-line\",\n\t            ans: a,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: a,\n\t            en: \"subtitle\",\n\t            ans: a,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: a,\n\t            en: \"title\",\n\t            ans: a,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: a,\n\t            en: \"wall\",\n\t            ans: a,\n\t            a: \"style-name\"\n\t        }],\n\t        section: [{\n\t            ens: t,\n\t            en: \"alphabetical-index\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"bibliography\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"illustration-index\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"index-title\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"object-index\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"section\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"table-of-content\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"table-index\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"user-index\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }],\n\t        ruby: [{\n\t            ens: t,\n\t            en: \"ruby\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }],\n\t        table: [{\n\t            ens: c,\n\t            en: \"query\",\n\t            ans: c,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: c,\n\t            en: \"table-representation\",\n\t            ans: c,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"background\",\n\t            ans: u,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"table\",\n\t            ans: u,\n\t            a: \"style-name\"\n\t        }],\n\t        \"table-column\": [{\n\t            ens: c,\n\t            en: \"column\",\n\t            ans: c,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"table-column\",\n\t            ans: u,\n\t            a: \"style-name\"\n\t        }],\n\t        \"table-row\": [{\n\t            ens: c,\n\t            en: \"query\",\n\t            ans: c,\n\t            a: \"default-row-style-name\"\n\t        }, {\n\t            ens: c,\n\t            en: \"table-representation\",\n\t            ans: c,\n\t            a: \"default-row-style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"table-row\",\n\t            ans: u,\n\t            a: \"style-name\"\n\t        }],\n\t        \"table-cell\": [{\n\t            ens: c,\n\t            en: \"column\",\n\t            ans: c,\n\t            a: \"default-cell-style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"table-column\",\n\t            ans: u,\n\t            a: \"default-cell-style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"table-row\",\n\t            ans: u,\n\t            a: \"default-cell-style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"body\",\n\t            ans: u,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"covered-table-cell\",\n\t            ans: u,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"even-columns\",\n\t            ans: u,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"covered-table-cell\",\n\t            ans: u,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"even-columns\",\n\t            ans: u,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"even-rows\",\n\t            ans: u,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"first-column\",\n\t            ans: u,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"first-row\",\n\t            ans: u,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"last-column\",\n\t            ans: u,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"last-row\",\n\t            ans: u,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"odd-columns\",\n\t            ans: u,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"odd-rows\",\n\t            ans: u,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: u,\n\t            en: \"table-cell\",\n\t            ans: u,\n\t            a: \"style-name\"\n\t        }],\n\t        graphic: [{\n\t            ens: m,\n\t            en: \"cube\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: m,\n\t            en: \"extrude\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: m,\n\t            en: \"rotate\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: m,\n\t            en: \"scene\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: m,\n\t            en: \"sphere\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"caption\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"circle\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"connector\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"control\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"custom-shape\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"ellipse\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"frame\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"g\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"line\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"measure\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"page-thumbnail\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"path\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"polygon\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"polyline\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"rect\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"regular-polygon\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: z,\n\t            en: \"annotation\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }],\n\t        presentation: [{\n\t            ens: m,\n\t            en: \"cube\",\n\t            ans: w,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: m,\n\t            en: \"extrude\",\n\t            ans: w,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: m,\n\t            en: \"rotate\",\n\t            ans: w,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: m,\n\t            en: \"scene\",\n\t            ans: w,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: m,\n\t            en: \"sphere\",\n\t            ans: w,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"caption\",\n\t            ans: w,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"circle\",\n\t            ans: w,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"connector\",\n\t            ans: w,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"control\",\n\t            ans: w,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"custom-shape\",\n\t            ans: w,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"ellipse\",\n\t            ans: w,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"frame\",\n\t            ans: w,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"g\",\n\t            ans: w,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"line\",\n\t            ans: w,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"measure\",\n\t            ans: w,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"page-thumbnail\",\n\t            ans: w,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"path\",\n\t            ans: w,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"polygon\",\n\t            ans: w,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"polyline\",\n\t            ans: w,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"rect\",\n\t            ans: w,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: h,\n\t            en: \"regular-polygon\",\n\t            ans: w,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: z,\n\t            en: \"annotation\",\n\t            ans: w,\n\t            a: \"style-name\"\n\t        }],\n\t        \"drawing-page\": [{\n\t            ens: h,\n\t            en: \"page\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: w,\n\t            en: \"notes\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: v,\n\t            en: \"handout-master\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: v,\n\t            en: \"master-page\",\n\t            ans: h,\n\t            a: \"style-name\"\n\t        }],\n\t        \"list-style\": [{\n\t            ens: t,\n\t            en: \"list\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"numbered-paragraph\",\n\t            ans: t,\n\t            a: \"style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"list-item\",\n\t            ans: t,\n\t            a: \"style-override\"\n\t        }, {\n\t            ens: v,\n\t            en: \"style\",\n\t            ans: v,\n\t            a: \"list-style-name\"\n\t        }],\n\t        data: [{\n\t            ens: v,\n\t            en: \"style\",\n\t            ans: v,\n\t            a: \"data-style-name\"\n\t        }, {\n\t            ens: v,\n\t            en: \"style\",\n\t            ans: v,\n\t            a: \"percentage-data-style-name\"\n\t        }, {\n\t            ens: w,\n\t            en: \"date-time-decl\",\n\t            ans: v,\n\t            a: \"data-style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"creation-date\",\n\t            ans: v,\n\t            a: \"data-style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"creation-time\",\n\t            ans: v,\n\t            a: \"data-style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"database-display\",\n\t            ans: v,\n\t            a: \"data-style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"date\",\n\t            ans: v,\n\t            a: \"data-style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"editing-duration\",\n\t            ans: v,\n\t            a: \"data-style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"expression\",\n\t            ans: v,\n\t            a: \"data-style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"meta-field\",\n\t            ans: v,\n\t            a: \"data-style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"modification-date\",\n\t            ans: v,\n\t            a: \"data-style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"modification-time\",\n\t            ans: v,\n\t            a: \"data-style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"print-date\",\n\t            ans: v,\n\t            a: \"data-style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"print-time\",\n\t            ans: v,\n\t            a: \"data-style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"table-formula\",\n\t            ans: v,\n\t            a: \"data-style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"time\",\n\t            ans: v,\n\t            a: \"data-style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"user-defined\",\n\t            ans: v,\n\t            a: \"data-style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"user-field-get\",\n\t            ans: v,\n\t            a: \"data-style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"user-field-input\",\n\t            ans: v,\n\t            a: \"data-style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"variable-get\",\n\t            ans: v,\n\t            a: \"data-style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"variable-input\",\n\t            ans: v,\n\t            a: \"data-style-name\"\n\t        }, {\n\t            ens: t,\n\t            en: \"variable-set\",\n\t            ans: v,\n\t            a: \"data-style-name\"\n\t        }],\n\t        \"page-layout\": [{\n\t            ens: w,\n\t            en: \"notes\",\n\t            ans: v,\n\t            a: \"page-layout-name\"\n\t        }, {\n\t            ens: v,\n\t            en: \"handout-master\",\n\t            ans: v,\n\t            a: \"page-layout-name\"\n\t        }, {\n\t            ens: v,\n\t            en: \"master-page\",\n\t            ans: v,\n\t            a: \"page-layout-name\"\n\t        }]\n\t    }, K, L = xmldom.XPath;\n\t    this.collectUsedFontFaces = e;\n\t    this.changeFontFaceNames = l;\n\t    this.UsedStyleList = function(a, c) {\n\t        var d = {};\n\t        this.uses = function(a) {\n\t            var c = a.localName\n\t              , b = a.getAttributeNS(h, \"name\") || a.getAttributeNS(v, \"name\");\n\t            a = \"style\" === c ? a.getAttributeNS(v, \"family\") : a.namespaceURI === x ? \"data\" : c;\n\t            return (a = d[a]) ? 0 < a[b] : !1\n\t        }\n\t        ;\n\t        b(a, d);\n\t        c && q(c, d)\n\t    }\n\t    ;\n\t    this.getStyleName = function(a, c) {\n\t        var b, d, h = K[c.localName];\n\t        if (h && (h = h[c.namespaceURI]))\n\t            for (d = 0; d < h.length; d += 1)\n\t                if (h[d].keyname === a && (h = h[d],\n\t                c.hasAttributeNS(h.ns, h.localname))) {\n\t                    b = c.getAttributeNS(h.ns, h.localname);\n\t                    break\n\t                }\n\t        return b\n\t    }\n\t    ;\n\t    this.hasDerivedStyles = function(a, c, b) {\n\t        var d = b.getAttributeNS(v, \"name\");\n\t        b = b.getAttributeNS(v, \"family\");\n\t        return L.getODFElementsWithXPath(a, '//style:*[@style:parent-style-name=\"' + d + '\"][@style:family=\"' + b + '\"]', c).length ? !0 : !1\n\t    }\n\t    ;\n\t    this.prefixStyleNames = function(a, c, b) {\n\t        var d;\n\t        if (a) {\n\t            for (d = a.firstChild; d; ) {\n\t                if (d.nodeType === Node.ELEMENT_NODE) {\n\t                    var m = d\n\t                      , e = c\n\t                      , l = m.getAttributeNS(h, \"name\")\n\t                      , f = void 0;\n\t                    l ? f = h : (l = m.getAttributeNS(v, \"name\")) && (f = v);\n\t                    f && m.setAttributeNS(f, A[f] + \"name\", e + l)\n\t                }\n\t                d = d.nextSibling\n\t            }\n\t            g(a, c);\n\t            b && g(b, c)\n\t        }\n\t    }\n\t    ;\n\t    this.removePrefixFromStyleNames = function(a, c, b) {\n\t        var d = new RegExp(\"^\" + c);\n\t        if (a) {\n\t            for (c = a.firstChild; c; ) {\n\t                if (c.nodeType === Node.ELEMENT_NODE) {\n\t                    var m = c\n\t                      , e = d\n\t                      , l = m.getAttributeNS(h, \"name\")\n\t                      , f = void 0;\n\t                    l ? f = h : (l = m.getAttributeNS(v, \"name\")) && (f = v);\n\t                    f && (l = l.replace(e, \"\"),\n\t                    m.setAttributeNS(f, A[f] + \"name\", l))\n\t                }\n\t                c = c.nextSibling\n\t            }\n\t            k(a, d);\n\t            b && k(b, d)\n\t        }\n\t    }\n\t    ;\n\t    this.determineStylesForNode = d;\n\t    K = function() {\n\t        var a, c, b, d, h, m = {}, e, l, f, n;\n\t        for (b in I)\n\t            if (I.hasOwnProperty(b))\n\t                for (d = I[b],\n\t                c = d.length,\n\t                a = 0; a < c; a += 1)\n\t                    h = d[a],\n\t                    f = h.en,\n\t                    n = h.ens,\n\t                    m.hasOwnProperty(f) ? e = m[f] : m[f] = e = {},\n\t                    e.hasOwnProperty(n) ? l = e[n] : e[n] = l = [],\n\t                    l.push({\n\t                        ns: h.ans,\n\t                        localname: h.a,\n\t                        keyname: b\n\t                    });\n\t        return m\n\t    }()\n\t}\n\t;\n\t\"function\" !== typeof Object.create && (Object.create = function(g) {\n\t    var k = function() {};\n\t    k.prototype = g;\n\t    return new k\n\t}\n\t);\n\txmldom.LSSerializer = function() {\n\t    function g(b) {\n\t        var d = b || {}\n\t          , g = function(b) {\n\t            var a = {}, c;\n\t            for (c in b)\n\t                b.hasOwnProperty(c) && (a[b[c]] = c);\n\t            return a\n\t        }(b)\n\t          , k = [d]\n\t          , q = [g]\n\t          , e = 0;\n\t        this.push = function() {\n\t            e += 1;\n\t            d = k[e] = Object.create(d);\n\t            g = q[e] = Object.create(g)\n\t        }\n\t        ;\n\t        this.pop = function() {\n\t            k.pop();\n\t            q.pop();\n\t            --e;\n\t            d = k[e];\n\t            g = q[e]\n\t        }\n\t        ;\n\t        this.getLocalNamespaceDefinitions = function() {\n\t            return g\n\t        }\n\t        ;\n\t        this.getQName = function(b) {\n\t            var a = b.namespaceURI, c = 0, m;\n\t            if (!a)\n\t                return b.localName;\n\t            if (m = g[a])\n\t                return m + \":\" + b.localName;\n\t            do {\n\t                m || !b.prefix ? (m = \"ns\" + c,\n\t                c += 1) : m = b.prefix;\n\t                if (d[m] === a)\n\t                    break;\n\t                if (!d[m]) {\n\t                    d[m] = a;\n\t                    g[a] = m;\n\t                    break\n\t                }\n\t                m = null\n\t            } while (null === m);\n\t            return m + \":\" + b.localName\n\t        }\n\t    }\n\t    function k(b) {\n\t        return b.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/'/g, \"&apos;\").replace(/\"/g, \"&quot;\")\n\t    }\n\t    function d(f, n) {\n\t        var g = \"\", r = b.filter ? b.filter.acceptNode(n) : NodeFilter.FILTER_ACCEPT, q;\n\t        if (r === NodeFilter.FILTER_ACCEPT && n.nodeType === Node.ELEMENT_NODE) {\n\t            f.push();\n\t            q = f.getQName(n);\n\t            var e, l = n.attributes, a, c, m, h = \"\", y;\n\t            e = \"<\" + q;\n\t            a = l.length;\n\t            for (c = 0; c < a; c += 1)\n\t                m = l.item(c),\n\t                \"http://www.w3.org/2000/xmlns/\" !== m.namespaceURI && (y = b.filter ? b.filter.acceptNode(m) : NodeFilter.FILTER_ACCEPT,\n\t                y === NodeFilter.FILTER_ACCEPT && (y = f.getQName(m),\n\t                m = \"string\" === typeof m.value ? k(m.value) : m.value,\n\t                h += \" \" + (y + '=\"' + m + '\"')));\n\t            a = f.getLocalNamespaceDefinitions();\n\t            for (c in a)\n\t                a.hasOwnProperty(c) && ((l = a[c]) ? \"xmlns\" !== l && (e += \" xmlns:\" + a[c] + '=\"' + c + '\"') : e += ' xmlns=\"' + c + '\"');\n\t            g += e + (h + \">\")\n\t        }\n\t        if (r === NodeFilter.FILTER_ACCEPT || r === NodeFilter.FILTER_SKIP) {\n\t            for (r = n.firstChild; r; )\n\t                g += d(f, r),\n\t                r = r.nextSibling;\n\t            n.nodeValue && (g += k(n.nodeValue))\n\t        }\n\t        q && (g += \"</\" + q + \">\",\n\t        f.pop());\n\t        return g\n\t    }\n\t    var b = this;\n\t    this.filter = null;\n\t    this.writeToString = function(b, n) {\n\t        if (!b)\n\t            return \"\";\n\t        var k = new g(n);\n\t        return d(k, b)\n\t    }\n\t}\n\t;\n\t(function() {\n\t    function g(b) {\n\t        var a, c = r.length;\n\t        for (a = 0; a < c; a += 1)\n\t            if (\"urn:oasis:names:tc:opendocument:xmlns:office:1.0\" === b.namespaceURI && b.localName === r[a])\n\t                return a;\n\t        return -1\n\t    }\n\t    function k(b, a) {\n\t        var c = new f.UsedStyleList(b,a)\n\t          , d = new odf.OdfNodeFilter;\n\t        this.acceptNode = function(b) {\n\t            var e = d.acceptNode(b);\n\t            e === NodeFilter.FILTER_ACCEPT && b.parentNode === a && b.nodeType === Node.ELEMENT_NODE && (e = c.uses(b) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT);\n\t            return e\n\t        }\n\t    }\n\t    function d(b, a) {\n\t        var c = new k(b,a);\n\t        this.acceptNode = function(a) {\n\t            var b = c.acceptNode(a);\n\t            b !== NodeFilter.FILTER_ACCEPT || !a.parentNode || a.parentNode.namespaceURI !== odf.Namespaces.textns || \"s\" !== a.parentNode.localName && \"tab\" !== a.parentNode.localName || (b = NodeFilter.FILTER_REJECT);\n\t            return b\n\t        }\n\t    }\n\t    function b(b, a) {\n\t        if (a) {\n\t            var c = g(a), d, h = b.firstChild;\n\t            if (-1 !== c) {\n\t                for (; h; ) {\n\t                    d = g(h);\n\t                    if (-1 !== d && d > c)\n\t                        break;\n\t                    h = h.nextSibling\n\t                }\n\t                b.insertBefore(a, h)\n\t            }\n\t        }\n\t    }\n\t    var f = new odf.StyleInfo\n\t      , n = core.DomUtils\n\t      , p = odf.Namespaces.stylens\n\t      , r = \"meta settings scripts font-face-decls styles automatic-styles master-styles body\".split(\" \")\n\t      , q = Date.now() + \"_webodf_\"\n\t      , e = new core.Base64;\n\t    odf.ODFElement = function() {}\n\t    ;\n\t    odf.ODFDocumentElement = function() {}\n\t    ;\n\t    odf.ODFDocumentElement.prototype = new odf.ODFElement;\n\t    odf.ODFDocumentElement.prototype.constructor = odf.ODFDocumentElement;\n\t    odf.ODFDocumentElement.prototype.fontFaceDecls = null;\n\t    odf.ODFDocumentElement.prototype.manifest = null;\n\t    odf.ODFDocumentElement.prototype.settings = null;\n\t    odf.ODFDocumentElement.namespaceURI = \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\";\n\t    odf.ODFDocumentElement.localName = \"document\";\n\t    odf.AnnotationElement = function() {}\n\t    ;\n\t    odf.OdfPart = function(b, a, c, d) {\n\t        var h = this;\n\t        this.size = 0;\n\t        this.type = null;\n\t        this.name = b;\n\t        this.container = c;\n\t        this.url = null;\n\t        this.mimetype = a;\n\t        this.onstatereadychange = this.document = null;\n\t        this.EMPTY = 0;\n\t        this.LOADING = 1;\n\t        this.DONE = 2;\n\t        this.state = this.EMPTY;\n\t        this.data = \"\";\n\t        this.load = function() {\n\t            null !== d && (this.mimetype = a,\n\t            d.loadAsDataURL(b, a, function(a, c) {\n\t                a && runtime.log(a);\n\t                h.url = c;\n\t                if (h.onchange)\n\t                    h.onchange(h);\n\t                if (h.onstatereadychange)\n\t                    h.onstatereadychange(h)\n\t            }))\n\t        }\n\t    }\n\t    ;\n\t    odf.OdfPart.prototype.load = function() {}\n\t    ;\n\t    odf.OdfPart.prototype.getUrl = function() {\n\t        return this.data ? \"data:;base64,\" + e.toBase64(this.data) : null\n\t    }\n\t    ;\n\t    odf.OdfContainer = function a(c, m) {\n\t        function h(a) {\n\t            for (var c = a.firstChild, b; c; )\n\t                b = c.nextSibling,\n\t                c.nodeType === Node.ELEMENT_NODE ? h(c) : c.nodeType === Node.PROCESSING_INSTRUCTION_NODE && a.removeChild(c),\n\t                c = b\n\t        }\n\t        function g(a) {\n\t            var c = {}, b, d, h = a.ownerDocument.createNodeIterator(a, NodeFilter.SHOW_ELEMENT, null, !1);\n\t            for (a = h.nextNode(); a; )\n\t                \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\" === a.namespaceURI && (\"annotation\" === a.localName ? (b = a.getAttributeNS(\"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"name\")) && (c.hasOwnProperty(b) ? runtime.log(\"Warning: annotation name used more than once with <office:annotation/>: '\" + b + \"'\") : c[b] = a) : \"annotation-end\" === a.localName && ((b = a.getAttributeNS(\"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"name\")) ? c.hasOwnProperty(b) ? (d = c[b],\n\t                d.annotationEndElement ? runtime.log(\"Warning: annotation name used more than once with <office:annotation-end/>: '\" + b + \"'\") : d.annotationEndElement = a) : runtime.log(\"Warning: annotation end without an annotation start, name: '\" + b + \"'\") : runtime.log(\"Warning: annotation end without a name found\"))),\n\t                a = h.nextNode()\n\t        }\n\t        function r(a, c) {\n\t            for (var b = a && a.firstChild; b; )\n\t                b.nodeType === Node.ELEMENT_NODE && b.setAttributeNS(\"urn:webodf:names:scope\", \"scope\", c),\n\t                b = b.nextSibling\n\t        }\n\t        function z(a, c) {\n\t            for (var b = B.rootElement.meta, b = b && b.firstChild; b && (b.namespaceURI !== a || b.localName !== c); )\n\t                b = b.nextSibling;\n\t            for (b = b && b.firstChild; b && b.nodeType !== Node.TEXT_NODE; )\n\t                b = b.nextSibling;\n\t            return b ? b.data : null\n\t        }\n\t        function w(a) {\n\t            var c = {}, b;\n\t            for (a = a.firstChild; a; )\n\t                a.nodeType === Node.ELEMENT_NODE && a.namespaceURI === p && \"font-face\" === a.localName && (b = a.getAttributeNS(p, \"name\"),\n\t                c[b] = a),\n\t                a = a.nextSibling;\n\t            return c\n\t        }\n\t        function v(a, c) {\n\t            var b = null, d, h, e;\n\t            if (a)\n\t                for (b = a.cloneNode(!0),\n\t                d = b.firstElementChild; d; )\n\t                    h = d.nextElementSibling,\n\t                    (e = d.getAttributeNS(\"urn:webodf:names:scope\", \"scope\")) && e !== c && b.removeChild(d),\n\t                    d = h;\n\t            return b\n\t        }\n\t        function u(a, c) {\n\t            var b, d, h, e = null, m = {};\n\t            if (a)\n\t                for (c.forEach(function(a) {\n\t                    f.collectUsedFontFaces(m, a)\n\t                }),\n\t                e = a.cloneNode(!0),\n\t                b = e.firstElementChild; b; )\n\t                    d = b.nextElementSibling,\n\t                    h = b.getAttributeNS(p, \"name\"),\n\t                    m[h] || e.removeChild(b),\n\t                    b = d;\n\t            return e\n\t        }\n\t        function t(a) {\n\t            var c = B.rootElement.ownerDocument, b;\n\t            if (a) {\n\t                h(a.documentElement);\n\t                try {\n\t                    b = c.importNode(a.documentElement, !0)\n\t                } catch (d) {}\n\t            }\n\t            return b\n\t        }\n\t        function A(a) {\n\t            B.state = a;\n\t            if (B.onchange)\n\t                B.onchange(B);\n\t            if (B.onstatereadychange)\n\t                B.onstatereadychange(B)\n\t        }\n\t        function I(a) {\n\t            Q = null;\n\t            B.rootElement = a;\n\t            a.fontFaceDecls = n.getDirectChild(a, \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"font-face-decls\");\n\t            a.styles = n.getDirectChild(a, \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"styles\");\n\t            a.automaticStyles = n.getDirectChild(a, \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"automatic-styles\");\n\t            a.masterStyles = n.getDirectChild(a, \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"master-styles\");\n\t            a.body = n.getDirectChild(a, \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"body\");\n\t            a.meta = n.getDirectChild(a, \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"meta\");\n\t            a.settings = n.getDirectChild(a, \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"settings\");\n\t            a.scripts = n.getDirectChild(a, \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"scripts\");\n\t            g(a)\n\t        }\n\t        function K(c) {\n\t            var d = t(c), h = B.rootElement, e;\n\t            d && \"document-styles\" === d.localName && \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\" === d.namespaceURI ? (h.fontFaceDecls = n.getDirectChild(d, \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"font-face-decls\"),\n\t            b(h, h.fontFaceDecls),\n\t            e = n.getDirectChild(d, \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"styles\"),\n\t            h.styles = e || c.createElementNS(\"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"styles\"),\n\t            b(h, h.styles),\n\t            e = n.getDirectChild(d, \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"automatic-styles\"),\n\t            h.automaticStyles = e || c.createElementNS(\"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"automatic-styles\"),\n\t            r(h.automaticStyles, \"document-styles\"),\n\t            b(h, h.automaticStyles),\n\t            d = n.getDirectChild(d, \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"master-styles\"),\n\t            h.masterStyles = d || c.createElementNS(\"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"master-styles\"),\n\t            b(h, h.masterStyles),\n\t            f.prefixStyleNames(h.automaticStyles, q, h.masterStyles)) : A(a.INVALID)\n\t        }\n\t        function L(c) {\n\t            c = t(c);\n\t            var d, h, e, m;\n\t            if (c && \"document-content\" === c.localName && \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\" === c.namespaceURI) {\n\t                d = B.rootElement;\n\t                e = n.getDirectChild(c, \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"font-face-decls\");\n\t                if (d.fontFaceDecls && e) {\n\t                    m = d.fontFaceDecls;\n\t                    var g, k, O, q, D = {};\n\t                    h = w(m);\n\t                    q = w(e);\n\t                    for (e = e.firstElementChild; e; ) {\n\t                        g = e.nextElementSibling;\n\t                        if (e.namespaceURI === p && \"font-face\" === e.localName)\n\t                            if (k = e.getAttributeNS(p, \"name\"),\n\t                            h.hasOwnProperty(k)) {\n\t                                if (!e.isEqualNode(h[k])) {\n\t                                    O = k;\n\t                                    for (var y = h, E = q, u = 0, W = void 0, W = O = O.replace(/\\d+$/, \"\"); y.hasOwnProperty(W) || E.hasOwnProperty(W); )\n\t                                        u += 1,\n\t                                        W = O + u;\n\t                                    O = W;\n\t                                    e.setAttributeNS(p, \"style:name\", O);\n\t                                    m.appendChild(e);\n\t                                    h[O] = e;\n\t                                    delete q[k];\n\t                                    D[k] = O\n\t                                }\n\t                            } else\n\t                                m.appendChild(e),\n\t                                h[k] = e,\n\t                                delete q[k];\n\t                        e = g\n\t                    }\n\t                    m = D\n\t                } else\n\t                    e && (d.fontFaceDecls = e,\n\t                    b(d, e));\n\t                h = n.getDirectChild(c, \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"automatic-styles\");\n\t                r(h, \"document-content\");\n\t                m && f.changeFontFaceNames(h, m);\n\t                if (d.automaticStyles && h)\n\t                    for (m = h.firstChild; m; )\n\t                        d.automaticStyles.appendChild(m),\n\t                        m = h.firstChild;\n\t                else\n\t                    h && (d.automaticStyles = h,\n\t                    b(d, h));\n\t                c = n.getDirectChild(c, \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"body\");\n\t                if (null === c)\n\t                    throw \"<office:body/> tag is mising.\";\n\t                d.body = c;\n\t                b(d, d.body)\n\t            } else\n\t                A(a.INVALID)\n\t        }\n\t        function E(a) {\n\t            a = t(a);\n\t            var c;\n\t            a && \"document-meta\" === a.localName && \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\" === a.namespaceURI && (c = B.rootElement,\n\t            c.meta = n.getDirectChild(a, \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"meta\"),\n\t            b(c, c.meta))\n\t        }\n\t        function N(a) {\n\t            a = t(a);\n\t            var c;\n\t            a && \"document-settings\" === a.localName && \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\" === a.namespaceURI && (c = B.rootElement,\n\t            c.settings = n.getDirectChild(a, \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"settings\"),\n\t            b(c, c.settings))\n\t        }\n\t        function O(a) {\n\t            a = t(a);\n\t            var c;\n\t            if (a && \"manifest\" === a.localName && \"urn:oasis:names:tc:opendocument:xmlns:manifest:1.0\" === a.namespaceURI)\n\t                for (c = B.rootElement,\n\t                c.manifest = a,\n\t                a = c.manifest.firstElementChild; a; )\n\t                    \"file-entry\" === a.localName && \"urn:oasis:names:tc:opendocument:xmlns:manifest:1.0\" === a.namespaceURI && (M[a.getAttributeNS(\"urn:oasis:names:tc:opendocument:xmlns:manifest:1.0\", \"full-path\")] = a.getAttributeNS(\"urn:oasis:names:tc:opendocument:xmlns:manifest:1.0\", \"media-type\")),\n\t                    a = a.nextElementSibling\n\t        }\n\t        function D(a, c, b) {\n\t            a = n.getElementsByTagName(a, c);\n\t            var d;\n\t            for (d = 0; d < a.length; d += 1)\n\t                c = a[d],\n\t                b.hasOwnProperty(c.namespaceURI) || c.parentNode.removeChild(c)\n\t        }\n\t        function V(a) {\n\t            D(a, \"script\", {\n\t                \"urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0\": !0,\n\t                \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\": !0,\n\t                \"urn:oasis:names:tc:opendocument:xmlns:table:1.0\": !0,\n\t                \"urn:oasis:names:tc:opendocument:xmlns:text:1.0\": !0,\n\t                \"urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0\": !0\n\t            });\n\t            D(a, \"style\", {\n\t                \"urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0\": !0,\n\t                \"urn:oasis:names:tc:opendocument:xmlns:drawing:1.0\": !0,\n\t                \"urn:oasis:names:tc:opendocument:xmlns:style:1.0\": !0\n\t            })\n\t        }\n\t        function W(a) {\n\t            var c = a.firstElementChild, b = [], d, h, e, m = a.attributes, f = m.length;\n\t            for (d = 0; d < f; d += 1)\n\t                e = m.item(d),\n\t                h = e.localName.substr(0, 2).toLowerCase(),\n\t                null === e.namespaceURI && \"on\" === h && b.push(e);\n\t            f = b.length;\n\t            for (d = 0; d < f; d += 1)\n\t                a.removeAttributeNode(b[d]);\n\t            for (; c; )\n\t                W(c),\n\t                c = c.nextElementSibling\n\t        }\n\t        function J(c) {\n\t            var b = c.shift();\n\t            b ? Y.loadAsDOM(b.path, function(d, h) {\n\t                h && (V(h),\n\t                W(h.documentElement));\n\t                b.handler(h);\n\t                B.state === a.INVALID ? d ? runtime.log(\"ERROR: Unable to load \" + b.path + \" - \" + d) : runtime.log(\"ERROR: Unable to load \" + b.path) : (d && runtime.log(\"DEBUG: Unable to load \" + b.path + \" - \" + d),\n\t                J(c))\n\t            }) : (g(B.rootElement),\n\t            A(a.DONE))\n\t        }\n\t        function R(a) {\n\t            var c = \"\";\n\t            odf.Namespaces.forEachPrefix(function(a, b) {\n\t                c += \" xmlns:\" + a + '=\"' + b + '\"'\n\t            });\n\t            return '<?xml version=\"1.0\" encoding=\"UTF-8\"?><office:' + a + \" \" + c + ' office:version=\"1.2\">'\n\t        }\n\t        function P() {\n\t            var a = new xmldom.LSSerializer\n\t              , c = R(\"document-meta\");\n\t            a.filter = new odf.OdfNodeFilter;\n\t            c += a.writeToString(B.rootElement.meta, odf.Namespaces.namespaceMap);\n\t            return c + \"</office:document-meta>\"\n\t        }\n\t        function aa(a, c) {\n\t            var b = document.createElementNS(\"urn:oasis:names:tc:opendocument:xmlns:manifest:1.0\", \"manifest:file-entry\");\n\t            b.setAttributeNS(\"urn:oasis:names:tc:opendocument:xmlns:manifest:1.0\", \"manifest:full-path\", a);\n\t            b.setAttributeNS(\"urn:oasis:names:tc:opendocument:xmlns:manifest:1.0\", \"manifest:media-type\", c);\n\t            return b\n\t        }\n\t        function S() {\n\t            var a = runtime.parseXML('<manifest:manifest xmlns:manifest=\"urn:oasis:names:tc:opendocument:xmlns:manifest:1.0\" manifest:version=\"1.2\"></manifest:manifest>'), c = a.documentElement, b = new xmldom.LSSerializer, d;\n\t            for (d in M)\n\t                M.hasOwnProperty(d) && c.appendChild(aa(d, M[d]));\n\t            b.filter = new odf.OdfNodeFilter;\n\t            return '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\\n' + b.writeToString(a, odf.Namespaces.namespaceMap)\n\t        }\n\t        function fa() {\n\t            var a, c, b, d = odf.Namespaces.namespaceMap, h = new xmldom.LSSerializer, e = R(\"document-styles\");\n\t            c = v(B.rootElement.automaticStyles, \"document-styles\");\n\t            b = B.rootElement.masterStyles.cloneNode(!0);\n\t            a = u(B.rootElement.fontFaceDecls, [b, B.rootElement.styles, c]);\n\t            f.removePrefixFromStyleNames(c, q, b);\n\t            h.filter = new k(b,c);\n\t            e += h.writeToString(a, d);\n\t            e += h.writeToString(B.rootElement.styles, d);\n\t            e += h.writeToString(c, d);\n\t            e += h.writeToString(b, d);\n\t            return e + \"</office:document-styles>\"\n\t        }\n\t        function ha() {\n\t            var a, c, b = odf.Namespaces.namespaceMap, h = new xmldom.LSSerializer, e = R(\"document-content\");\n\t            c = v(B.rootElement.automaticStyles, \"document-content\");\n\t            a = u(B.rootElement.fontFaceDecls, [c]);\n\t            h.filter = new d(B.rootElement.body,c);\n\t            e += h.writeToString(a, b);\n\t            e += h.writeToString(c, b);\n\t            e += h.writeToString(B.rootElement.body, b);\n\t            return e + \"</office:document-content>\"\n\t        }\n\t        function C(c, b) {\n\t            runtime.loadXML(c, function(c, d) {\n\t                if (c)\n\t                    b(c);\n\t                else if (d) {\n\t                    V(d);\n\t                    W(d.documentElement);\n\t                    var h = t(d);\n\t                    h && \"document\" === h.localName && \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\" === h.namespaceURI ? (I(h),\n\t                    A(a.DONE)) : A(a.INVALID)\n\t                } else\n\t                    b(\"No DOM was loaded.\")\n\t            })\n\t        }\n\t        function Z(a, c) {\n\t            var d;\n\t            d = B.rootElement;\n\t            var h = d.meta;\n\t            h || (d.meta = h = document.createElementNS(\"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"meta\"),\n\t            b(d, h));\n\t            d = h;\n\t            a && n.mapKeyValObjOntoNode(d, a, odf.Namespaces.lookupNamespaceURI);\n\t            c && n.removeKeyElementsFromNode(d, c, odf.Namespaces.lookupNamespaceURI)\n\t        }\n\t        function ba(c, b) {\n\t            function d(a, c) {\n\t                var b;\n\t                c || (c = a);\n\t                b = document.createElementNS(\"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", c);\n\t                f[a] = b;\n\t                f.appendChild(b)\n\t            }\n\t            var h = new core.Zip(\"\",null)\n\t              , e = \"application/vnd.oasis.opendocument.\" + c + (!0 === b ? \"-template\" : \"\")\n\t              , m = runtime.byteArrayFromString(e, \"utf8\")\n\t              , f = B.rootElement\n\t              , g = document.createElementNS(\"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", c);\n\t            h.save(\"mimetype\", m, !1, new Date);\n\t            d(\"meta\");\n\t            d(\"settings\");\n\t            d(\"scripts\");\n\t            d(\"fontFaceDecls\", \"font-face-decls\");\n\t            d(\"styles\");\n\t            d(\"automaticStyles\", \"automatic-styles\");\n\t            d(\"masterStyles\", \"master-styles\");\n\t            d(\"body\");\n\t            f.body.appendChild(g);\n\t            M[\"/\"] = e;\n\t            M[\"settings.xml\"] = \"text/xml\";\n\t            M[\"meta.xml\"] = \"text/xml\";\n\t            M[\"styles.xml\"] = \"text/xml\";\n\t            M[\"content.xml\"] = \"text/xml\";\n\t            A(a.DONE);\n\t            return h\n\t        }\n\t        function U() {\n\t            var a, c = new Date, b = \"\";\n\t            B.rootElement.settings && B.rootElement.settings.firstElementChild && (a = new xmldom.LSSerializer,\n\t            b = R(\"document-settings\"),\n\t            a.filter = new odf.OdfNodeFilter,\n\t            b += a.writeToString(B.rootElement.settings, odf.Namespaces.namespaceMap),\n\t            b += \"</office:document-settings>\");\n\t            (a = b) ? (a = runtime.byteArrayFromString(a, \"utf8\"),\n\t            Y.save(\"settings.xml\", a, !0, c)) : Y.remove(\"settings.xml\");\n\t            b = runtime.getWindow();\n\t            a = \"WebODF/\" + webodf.Version;\n\t            b && (a = a + \" \" + b.navigator.userAgent);\n\t            Z({\n\t                \"meta:generator\": a\n\t            }, null);\n\t            a = runtime.byteArrayFromString(P(), \"utf8\");\n\t            Y.save(\"meta.xml\", a, !0, c);\n\t            a = runtime.byteArrayFromString(fa(), \"utf8\");\n\t            Y.save(\"styles.xml\", a, !0, c);\n\t            a = runtime.byteArrayFromString(ha(), \"utf8\");\n\t            Y.save(\"content.xml\", a, !0, c);\n\t            a = runtime.byteArrayFromString(S(), \"utf8\");\n\t            Y.save(\"META-INF/manifest.xml\", a, !0, c)\n\t        }\n\t        function ga(a, c) {\n\t            U();\n\t            Y.writeAs(a, function(a) {\n\t                c(a)\n\t            })\n\t        }\n\t        var B = this, Y, M = {}, Q, F = \"\";\n\t        this.onstatereadychange = m;\n\t        this.state = this.onchange = null;\n\t        this.getMetadata = z;\n\t        this.setRootElement = I;\n\t        this.getContentElement = function() {\n\t            var a;\n\t            Q || (a = B.rootElement.body,\n\t            Q = n.getDirectChild(a, \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"text\") || n.getDirectChild(a, \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"presentation\") || n.getDirectChild(a, \"urn:oasis:names:tc:opendocument:xmlns:office:1.0\", \"spreadsheet\"));\n\t            if (!Q)\n\t                throw \"Could not find content element in <office:body/>.\";\n\t            return Q\n\t        }\n\t        ;\n\t        this.getDocumentType = function() {\n\t            var a = B.getContentElement();\n\t            return a && a.localName\n\t        }\n\t        ;\n\t        this.isTemplate = function() {\n\t            return \"-template\" === M[\"/\"].substr(-9)\n\t        }\n\t        ;\n\t        this.setIsTemplate = function(a) {\n\t            var c = M[\"/\"]\n\t              , b = \"-template\" === c.substr(-9);\n\t            a !== b && (c = a ? c + \"-template\" : c.substr(0, c.length - 9),\n\t            M[\"/\"] = c,\n\t            a = runtime.byteArrayFromString(c, \"utf8\"),\n\t            Y.save(\"mimetype\", a, !1, new Date))\n\t        }\n\t        ;\n\t        this.getPart = function(a) {\n\t            return new odf.OdfPart(a,M[a],B,Y)\n\t        }\n\t        ;\n\t        this.getPartData = function(a, c) {\n\t            Y.load(a, c)\n\t        }\n\t        ;\n\t        this.setMetadata = Z;\n\t        this.incrementEditingCycles = function() {\n\t            var a = z(odf.Namespaces.metans, \"editing-cycles\")\n\t              , a = a ? parseInt(a, 10) : 0;\n\t            isNaN(a) && (a = 0);\n\t            Z({\n\t                \"meta:editing-cycles\": a + 1\n\t            }, null);\n\t            return a + 1\n\t        }\n\t        ;\n\t        this.createByteArray = function(a, c) {\n\t            U();\n\t            Y.createByteArray(a, c)\n\t        }\n\t        ;\n\t        this.saveAs = ga;\n\t        this.save = function(a) {\n\t            ga(F, a)\n\t        }\n\t        ;\n\t        this.getUrl = function() {\n\t            return F\n\t        }\n\t        ;\n\t        this.setBlob = function(a, c, b) {\n\t            b = e.convertBase64ToByteArray(b);\n\t            Y.save(a, b, !1, new Date);\n\t            M.hasOwnProperty(a) && runtime.log(a + \" has been overwritten.\");\n\t            M[a] = c\n\t        }\n\t        ;\n\t        this.removeBlob = function(a) {\n\t            var c = Y.remove(a);\n\t            runtime.assert(c, \"file is not found: \" + a);\n\t            delete M[a]\n\t        }\n\t        ;\n\t        this.state = a.LOADING;\n\t        this.rootElement = function(a) {\n\t            var c = document.createElementNS(a.namespaceURI, a.localName), b;\n\t            a = new a.Type;\n\t            for (b in a)\n\t                a.hasOwnProperty(b) && (c[b] = a[b]);\n\t            return c\n\t        }({\n\t            Type: odf.ODFDocumentElement,\n\t            namespaceURI: odf.ODFDocumentElement.namespaceURI,\n\t            localName: odf.ODFDocumentElement.localName\n\t        });\n\t        c === odf.OdfContainer.DocumentType.TEXT ? Y = ba(\"text\") : c === odf.OdfContainer.DocumentType.TEXT_TEMPLATE ? Y = ba(\"text\", !0) : c === odf.OdfContainer.DocumentType.PRESENTATION ? Y = ba(\"presentation\") : c === odf.OdfContainer.DocumentType.PRESENTATION_TEMPLATE ? Y = ba(\"presentation\", !0) : c === odf.OdfContainer.DocumentType.SPREADSHEET ? Y = ba(\"spreadsheet\") : c === odf.OdfContainer.DocumentType.SPREADSHEET_TEMPLATE ? Y = ba(\"spreadsheet\", !0) : (F = c,\n\t        Y = new core.Zip(F,function(c, b) {\n\t            Y = b;\n\t            c ? C(F, function(b) {\n\t                c && (Y.error = c + \"\\n\" + b,\n\t                A(a.INVALID))\n\t            }) : J([{\n\t                path: \"styles.xml\",\n\t                handler: K\n\t            }, {\n\t                path: \"content.xml\",\n\t                handler: L\n\t            }, {\n\t                path: \"meta.xml\",\n\t                handler: E\n\t            }, {\n\t                path: \"settings.xml\",\n\t                handler: N\n\t            }, {\n\t                path: \"META-INF/manifest.xml\",\n\t                handler: O\n\t            }])\n\t        }\n\t        ))\n\t    }\n\t    ;\n\t    odf.OdfContainer.EMPTY = 0;\n\t    odf.OdfContainer.LOADING = 1;\n\t    odf.OdfContainer.DONE = 2;\n\t    odf.OdfContainer.INVALID = 3;\n\t    odf.OdfContainer.SAVING = 4;\n\t    odf.OdfContainer.MODIFIED = 5;\n\t    odf.OdfContainer.getContainer = function(a) {\n\t        return new odf.OdfContainer(a,null)\n\t    }\n\t}\n\t)();\n\todf.OdfContainer.DocumentType = {\n\t    TEXT: 1,\n\t    TEXT_TEMPLATE: 2,\n\t    PRESENTATION: 3,\n\t    PRESENTATION_TEMPLATE: 4,\n\t    SPREADSHEET: 5,\n\t    SPREADSHEET_TEMPLATE: 6\n\t};\n\tgui.AnnotatableCanvas = function() {}\n\t;\n\tgui.AnnotatableCanvas.prototype.refreshSize = function() {}\n\t;\n\tgui.AnnotatableCanvas.prototype.getZoomLevel = function() {}\n\t;\n\tgui.AnnotatableCanvas.prototype.getSizer = function() {}\n\t;\n\tgui.AnnotationViewManager = function(g, k, d, b) {\n\t    function f(c) {\n\t        var b = c.annotationEndElement\n\t          , d = l.createRange()\n\t          , e = c.getAttributeNS(odf.Namespaces.officens, \"name\");\n\t        b && (d.setStart(c, c.childNodes.length),\n\t        d.setEnd(b, 0),\n\t        c = a.getTextNodes(d, !1),\n\t        c.forEach(function(a) {\n\t            var c;\n\t            a: {\n\t                for (c = a.parentNode; c.namespaceURI !== odf.Namespaces.officens || \"body\" !== c.localName; ) {\n\t                    if (\"http://www.w3.org/1999/xhtml\" === c.namespaceURI && \"webodf-annotationHighlight\" === c.className && c.getAttribute(\"annotation\") === e) {\n\t                        c = !0;\n\t                        break a\n\t                    }\n\t                    c = c.parentNode\n\t                }\n\t                c = !1\n\t            }\n\t            c || (c = l.createElement(\"span\"),\n\t            c.className = \"webodf-annotationHighlight\",\n\t            c.setAttribute(\"annotation\", e),\n\t            a.parentNode.replaceChild(c, a),\n\t            c.appendChild(a))\n\t        }));\n\t        d.detach()\n\t    }\n\t    function n(a) {\n\t        var b = g.getSizer();\n\t        a ? (d.style.display = \"inline-block\",\n\t        b.style.paddingRight = c.getComputedStyle(d).width) : (d.style.display = \"none\",\n\t        b.style.paddingRight = 0);\n\t        g.refreshSize()\n\t    }\n\t    function p() {\n\t        e.sort(function(a, c) {\n\t            return 0 !== (a.compareDocumentPosition(c) & Node.DOCUMENT_POSITION_FOLLOWING) ? -1 : 1\n\t        })\n\t    }\n\t    function r() {\n\t        var a;\n\t        for (a = 0; a < e.length; a += 1) {\n\t            var c = e[a]\n\t              , b = c.parentNode\n\t              , f = b.nextElementSibling\n\t              , l = f.nextElementSibling\n\t              , n = b.parentNode\n\t              , k = 0\n\t              , k = e[e.indexOf(c) - 1]\n\t              , r = void 0\n\t              , c = g.getZoomLevel();\n\t            b.style.left = (d.getBoundingClientRect().left - n.getBoundingClientRect().left) / c + \"px\";\n\t            b.style.width = d.getBoundingClientRect().width / c + \"px\";\n\t            f.style.width = parseFloat(b.style.left) - 30 + \"px\";\n\t            k ? (r = k.parentNode.getBoundingClientRect(),\n\t            20 >= (n.getBoundingClientRect().top - r.bottom) / c ? b.style.top = Math.abs(n.getBoundingClientRect().top - r.bottom) / c + 20 + \"px\" : b.style.top = \"0px\") : b.style.top = \"0px\";\n\t            l.style.left = f.getBoundingClientRect().width / c + \"px\";\n\t            var f = l.style\n\t              , n = l.getBoundingClientRect().left / c\n\t              , k = l.getBoundingClientRect().top / c\n\t              , r = b.getBoundingClientRect().left / c\n\t              , p = b.getBoundingClientRect().top / c\n\t              , q = 0\n\t              , I = 0\n\t              , q = r - n\n\t              , q = q * q\n\t              , I = p - k\n\t              , I = I * I\n\t              , n = Math.sqrt(q + I);\n\t            f.width = n + \"px\";\n\t            k = Math.asin((b.getBoundingClientRect().top - l.getBoundingClientRect().top) / (c * parseFloat(l.style.width)));\n\t            l.style.transform = \"rotate(\" + k + \"rad)\";\n\t            l.style.MozTransform = \"rotate(\" + k + \"rad)\";\n\t            l.style.WebkitTransform = \"rotate(\" + k + \"rad)\";\n\t            l.style.msTransform = \"rotate(\" + k + \"rad)\"\n\t        }\n\t    }\n\t    function q(a) {\n\t        var c = e.indexOf(a)\n\t          , b = a.parentNode.parentNode;\n\t        \"div\" === b.localName && (b.parentNode.insertBefore(a, b),\n\t        b.parentNode.removeChild(b));\n\t        a = a.getAttributeNS(odf.Namespaces.officens, \"name\");\n\t        a = l.querySelectorAll('span.webodf-annotationHighlight[annotation=\"' + a + '\"]');\n\t        for (var d, b = 0; b < a.length; b += 1) {\n\t            for (d = a.item(b); d.firstChild; )\n\t                d.parentNode.insertBefore(d.firstChild, d);\n\t            d.parentNode.removeChild(d)\n\t        }\n\t        -1 !== c && e.splice(c, 1);\n\t        0 === e.length && n(!1)\n\t    }\n\t    var e = []\n\t      , l = k.ownerDocument\n\t      , a = odf.OdfUtils\n\t      , c = runtime.getWindow();\n\t    runtime.assert(Boolean(c), \"Expected to be run in an environment which has a global window, like a browser.\");\n\t    this.rerenderAnnotations = r;\n\t    this.rehighlightAnnotations = function() {\n\t        e.forEach(function(a) {\n\t            f(a)\n\t        })\n\t    }\n\t    ;\n\t    this.getMinimumHeightForAnnotationPane = function() {\n\t        return \"none\" !== d.style.display && 0 < e.length ? (e[e.length - 1].parentNode.getBoundingClientRect().bottom - d.getBoundingClientRect().top) / g.getZoomLevel() + \"px\" : null\n\t    }\n\t    ;\n\t    this.addAnnotations = function(c) {\n\t        0 !== c.length && (n(!0),\n\t        c.forEach(function(c) {\n\t            e.push(c);\n\t            var d = l.createElement(\"div\"), m = l.createElement(\"div\"), n = l.createElement(\"div\"), g = l.createElement(\"div\"), k;\n\t            d.className = \"annotationWrapper\";\n\t            d.setAttribute(\"creator\", a.getAnnotationCreator(c));\n\t            c.parentNode.insertBefore(d, c);\n\t            m.className = \"annotationNote\";\n\t            m.appendChild(c);\n\t            b && (k = l.createElement(\"div\"),\n\t            k.className = \"annotationRemoveButton\",\n\t            m.appendChild(k));\n\t            n.className = \"annotationConnector horizontal\";\n\t            g.className = \"annotationConnector angular\";\n\t            d.appendChild(m);\n\t            d.appendChild(n);\n\t            d.appendChild(g);\n\t            c.annotationEndElement && f(c)\n\t        }),\n\t        p(),\n\t        r())\n\t    }\n\t    ;\n\t    this.forgetAnnotation = q;\n\t    this.forgetAnnotations = function() {\n\t        for (; e.length; )\n\t            q(e[0])\n\t    }\n\t}\n\t;\n\tgui.Viewport = function() {}\n\t;\n\tgui.Viewport.prototype.scrollIntoView = function(g, k) {}\n\t;\n\tgui.SingleScrollViewport = function(g) {\n\t    this.scrollIntoView = function(k, d) {\n\t        var b, f, n, p;\n\t        p = g.offsetHeight - g.clientHeight;\n\t        n = g.offsetWidth - g.clientWidth;\n\t        var r = g.getBoundingClientRect();\n\t        if (k && r) {\n\t            b = r.left + 5;\n\t            f = r.top + 5;\n\t            n = r.right - (n + 5);\n\t            p = r.bottom - (p + 5);\n\t            if (d || k.top < f)\n\t                g.scrollTop -= f - k.top;\n\t            else if (k.top > p || k.bottom > p)\n\t                g.scrollTop = k.bottom - k.top <= p - f ? g.scrollTop + (k.bottom - p) : g.scrollTop + (k.top - f);\n\t            k.left < b ? g.scrollLeft -= b - k.left : k.right > n && (g.scrollLeft = k.right - k.left <= n - b ? g.scrollLeft + (k.right - n) : g.scrollLeft - (b - k.left))\n\t        }\n\t    }\n\t}\n\t;\n\t(function() {\n\t    function g(d, n, k, r, q) {\n\t        var e, l = 0, a;\n\t        for (a in d)\n\t            if (d.hasOwnProperty(a)) {\n\t                if (l === k) {\n\t                    e = a;\n\t                    break\n\t                }\n\t                l += 1\n\t            }\n\t        e ? n.getPartData(d[e].href, function(a, m) {\n\t            if (a)\n\t                runtime.log(a);\n\t            else if (m) {\n\t                var h = \"@font-face { font-family: \" + (d[e].family || e) + \"; src: url(data:application/x-font-ttf;charset=binary;base64,\" + b.convertUTF8ArrayToBase64(m) + ') format(\"truetype\"); }';\n\t                try {\n\t                    r.insertRule(h, r.cssRules.length)\n\t                } catch (l) {\n\t                    runtime.log(\"Problem inserting rule in CSS: \" + runtime.toJson(l) + \"\\nRule: \" + h)\n\t                }\n\t            } else\n\t                runtime.log(\"missing font data for \" + d[e].href);\n\t            g(d, n, k + 1, r, q)\n\t        }) : q && q()\n\t    }\n\t    var k = xmldom.XPath\n\t      , d = odf.OdfUtils\n\t      , b = new core.Base64;\n\t    odf.FontLoader = function() {\n\t        this.loadFonts = function(b, n) {\n\t            for (var p = b.rootElement.fontFaceDecls; n.cssRules.length; )\n\t                n.deleteRule(n.cssRules.length - 1);\n\t            if (p) {\n\t                var r = {}, q, e, l, a;\n\t                if (p)\n\t                    for (p = k.getODFElementsWithXPath(p, \"style:font-face[svg:font-face-src]\", odf.Namespaces.lookupNamespaceURI),\n\t                    q = 0; q < p.length; q += 1)\n\t                        e = p[q],\n\t                        l = e.getAttributeNS(odf.Namespaces.stylens, \"name\"),\n\t                        a = d.getNormalizedFontFamilyName(e.getAttributeNS(odf.Namespaces.svgns, \"font-family\")),\n\t                        e = k.getODFElementsWithXPath(e, \"svg:font-face-src/svg:font-face-uri\", odf.Namespaces.lookupNamespaceURI),\n\t                        0 < e.length && (e = e[0].getAttributeNS(odf.Namespaces.xlinkns, \"href\"),\n\t                        r[l] = {\n\t                            href: e,\n\t                            family: a\n\t                        });\n\t                g(r, b, 0, n)\n\t            }\n\t        }\n\t    }\n\t}\n\t)();\n\todf.Formatting = function() {\n\t    function g(a) {\n\t        return (a = A[a]) ? u.mergeObjects({}, a) : {}\n\t    }\n\t    function k() {\n\t        for (var c = a.rootElement.fontFaceDecls, b = {}, d, e, c = c && c.firstElementChild; c; ) {\n\t            if (d = c.getAttributeNS(h, \"name\"))\n\t                if ((e = c.getAttributeNS(m, \"font-family\")) || 0 < c.getElementsByTagNameNS(m, \"font-face-uri\").length)\n\t                    b[d] = e;\n\t            c = c.nextElementSibling\n\t        }\n\t        return b\n\t    }\n\t    function d(c) {\n\t        for (var b = a.rootElement.styles.firstElementChild; b; ) {\n\t            if (b.namespaceURI === h && \"default-style\" === b.localName && b.getAttributeNS(h, \"family\") === c)\n\t                return b;\n\t            b = b.nextElementSibling\n\t        }\n\t        return null\n\t    }\n\t    function b(c, b, d) {\n\t        var e, m, l;\n\t        d = d || [a.rootElement.automaticStyles, a.rootElement.styles];\n\t        for (l = 0; l < d.length; l += 1)\n\t            for (e = d[l],\n\t            e = e.firstElementChild; e; ) {\n\t                m = e.getAttributeNS(h, \"name\");\n\t                if (e.namespaceURI === h && \"style\" === e.localName && e.getAttributeNS(h, \"family\") === b && m === c || \"list-style\" === b && e.namespaceURI === y && \"list-style\" === e.localName && m === c || \"data\" === b && e.namespaceURI === x && m === c)\n\t                    return e;\n\t                e = e.nextElementSibling\n\t            }\n\t        return null\n\t    }\n\t    function f(a) {\n\t        for (var c, b, d, e, m = {}, l = a.firstElementChild; l; ) {\n\t            if (l.namespaceURI === h)\n\t                for (d = m[l.nodeName] = {},\n\t                b = l.attributes,\n\t                c = 0; c < b.length; c += 1)\n\t                    e = b.item(c),\n\t                    d[e.name] = e.value;\n\t            l = l.nextElementSibling\n\t        }\n\t        b = a.attributes;\n\t        for (c = 0; c < b.length; c += 1)\n\t            e = b.item(c),\n\t            m[e.name] = e.value;\n\t        return m\n\t    }\n\t    function n(c, e) {\n\t        for (var m = a.rootElement.styles, l, n = {}, k = c.getAttributeNS(h, \"family\"), r = c; r; )\n\t            l = f(r),\n\t            n = u.mergeObjects(l, n),\n\t            r = (l = r.getAttributeNS(h, \"parent-style-name\")) ? b(l, k, [m]) : null;\n\t        if (r = d(k))\n\t            l = f(r),\n\t            n = u.mergeObjects(l, n);\n\t        !1 !== e && (l = g(k),\n\t        n = u.mergeObjects(l, n));\n\t        return n\n\t    }\n\t    function p(b, d) {\n\t        function h(a) {\n\t            Object.keys(a).forEach(function(c) {\n\t                Object.keys(a[c]).forEach(function(a) {\n\t                    f += \"|\" + c + \":\" + a + \"|\"\n\t                })\n\t            })\n\t        }\n\t        for (var e = b.nodeType === Node.TEXT_NODE ? b.parentNode : b, m, l = [], f = \"\", n = !1; e && !w.isInlineRoot(e) && e.parentNode !== a.rootElement; )\n\t            !n && w.isGroupingElement(e) && (n = !0),\n\t            (m = c.determineStylesForNode(e)) && l.push(m),\n\t            e = e.parentNode;\n\t        n && (l.forEach(h),\n\t        d && (d[f] = l));\n\t        return n ? l : void 0\n\t    }\n\t    function r(c) {\n\t        var d = {\n\t            orderedStyles: [],\n\t            styleProperties: {}\n\t        };\n\t        c.forEach(function(c) {\n\t            Object.keys(c).forEach(function(e) {\n\t                var m = Object.keys(c[e])[0], l = {\n\t                    name: m,\n\t                    family: e,\n\t                    displayName: void 0,\n\t                    isCommonStyle: !1\n\t                }, f;\n\t                (f = b(m, e)) ? (e = n(f),\n\t                d.styleProperties = u.mergeObjects(e, d.styleProperties),\n\t                l.displayName = f.getAttributeNS(h, \"display-name\") || void 0,\n\t                l.isCommonStyle = f.parentNode === a.rootElement.styles) : runtime.log(\"No style element found for '\" + m + \"' of family '\" + e + \"'\");\n\t                d.orderedStyles.push(l)\n\t            })\n\t        });\n\t        return d\n\t    }\n\t    function q(a, c) {\n\t        var b = {}\n\t          , d = [];\n\t        c || (c = {});\n\t        a.forEach(function(a) {\n\t            p(a, b)\n\t        });\n\t        Object.keys(b).forEach(function(a) {\n\t            c[a] || (c[a] = r(b[a]));\n\t            d.push(c[a])\n\t        });\n\t        return d\n\t    }\n\t    function e(c) {\n\t        for (var b = a.rootElement.masterStyles.firstElementChild; b && (b.namespaceURI !== h || \"master-page\" !== b.localName || b.getAttributeNS(h, \"name\") !== c); )\n\t            b = b.nextElementSibling;\n\t        return b\n\t    }\n\t    function l(a, c) {\n\t        var b;\n\t        a && (b = t.convertMeasure(a, \"px\"));\n\t        void 0 === b && c && (b = t.convertMeasure(c, \"px\"));\n\t        return b\n\t    }\n\t    var a, c = new odf.StyleInfo, m = odf.Namespaces.svgns, h = odf.Namespaces.stylens, y = odf.Namespaces.textns, x = odf.Namespaces.numberns, z = odf.Namespaces.fons, w = odf.OdfUtils, v = core.DomUtils, u = new core.Utils, t = new core.CSSUnits, A = {\n\t        paragraph: {\n\t            \"style:paragraph-properties\": {\n\t                \"fo:text-align\": \"left\"\n\t            }\n\t        }\n\t    };\n\t    this.getSystemDefaultStyleAttributes = g;\n\t    this.setOdfContainer = function(c) {\n\t        a = c\n\t    }\n\t    ;\n\t    this.getFontMap = k;\n\t    this.getAvailableParagraphStyles = function() {\n\t        for (var c = a.rootElement.styles, b, d, e = [], c = c && c.firstElementChild; c; )\n\t            \"style\" === c.localName && c.namespaceURI === h && (b = c.getAttributeNS(h, \"family\"),\n\t            \"paragraph\" === b && (b = c.getAttributeNS(h, \"name\"),\n\t            d = c.getAttributeNS(h, \"display-name\") || b,\n\t            b && d && e.push({\n\t                name: b,\n\t                displayName: d\n\t            }))),\n\t            c = c.nextElementSibling;\n\t        return e\n\t    }\n\t    ;\n\t    this.isStyleUsed = function(b) {\n\t        var d, e = a.rootElement;\n\t        d = c.hasDerivedStyles(e, odf.Namespaces.lookupNamespaceURI, b);\n\t        b = (new c.UsedStyleList(e.styles)).uses(b) || (new c.UsedStyleList(e.automaticStyles)).uses(b) || (new c.UsedStyleList(e.body)).uses(b);\n\t        return d || b\n\t    }\n\t    ;\n\t    this.getDefaultStyleElement = d;\n\t    this.getStyleElement = b;\n\t    this.getStyleAttributes = f;\n\t    this.getInheritedStyleAttributes = n;\n\t    this.getFirstCommonParentStyleNameOrSelf = function(c) {\n\t        var d = a.rootElement.styles, e;\n\t        if (e = b(c, \"paragraph\", [a.rootElement.automaticStyles]))\n\t            if (c = e.getAttributeNS(h, \"parent-style-name\"),\n\t            !c)\n\t                return null;\n\t        return (e = b(c, \"paragraph\", [d])) ? c : null\n\t    }\n\t    ;\n\t    this.hasParagraphStyle = function(a) {\n\t        return Boolean(b(a, \"paragraph\"))\n\t    }\n\t    ;\n\t    this.getAppliedStyles = q;\n\t    this.getAppliedStylesForElement = function(a, c) {\n\t        return q([a], c)[0]\n\t    }\n\t    ;\n\t    this.updateStyle = function(c, b) {\n\t        var d, e;\n\t        v.mapObjOntoNode(c, b, odf.Namespaces.lookupNamespaceURI);\n\t        (d = (d = b[\"style:text-properties\"]) && d[\"style:font-name\"]) && !k().hasOwnProperty(d) && (e = c.ownerDocument.createElementNS(h, \"style:font-face\"),\n\t        e.setAttributeNS(h, \"style:name\", d),\n\t        e.setAttributeNS(m, \"svg:font-family\", d),\n\t        a.rootElement.fontFaceDecls.appendChild(e))\n\t    }\n\t    ;\n\t    this.createDerivedStyleObject = function(c, d, e) {\n\t        var h = b(c, d);\n\t        runtime.assert(Boolean(h), \"No style element found for '\" + c + \"' of family '\" + d + \"'\");\n\t        c = h.parentNode === a.rootElement.styles ? {\n\t            \"style:parent-style-name\": c\n\t        } : f(h);\n\t        c[\"style:family\"] = d;\n\t        u.mergeObjects(c, e);\n\t        return c\n\t    }\n\t    ;\n\t    this.getDefaultTabStopDistance = function() {\n\t        for (var a = d(\"paragraph\"), a = a && a.firstElementChild, c; a; )\n\t            a.namespaceURI === h && \"paragraph-properties\" === a.localName && (c = a.getAttributeNS(h, \"tab-stop-distance\")),\n\t            a = a.nextElementSibling;\n\t        c || (c = \"1.25cm\");\n\t        return w.parseNonNegativeLength(c)\n\t    }\n\t    ;\n\t    this.getMasterPageElement = e;\n\t    this.getContentSize = function(c, d) {\n\t        var m, f, n, g, k, r, p, q, y, u;\n\t        a: {\n\t            f = b(c, d);\n\t            runtime.assert(\"paragraph\" === d || \"table\" === d, \"styleFamily must be either paragraph or table\");\n\t            if (f) {\n\t                if (f = f.getAttributeNS(h, \"master-page-name\"))\n\t                    (m = e(f)) || runtime.log(\"WARN: No master page definition found for \" + f);\n\t                m || (m = e(\"Standard\"));\n\t                m || (m = a.rootElement.masterStyles.getElementsByTagNameNS(h, \"master-page\")[0]) || runtime.log(\"WARN: Document has no master pages defined\");\n\t                if (m)\n\t                    for (f = m.getAttributeNS(h, \"page-layout-name\"),\n\t                    n = a.rootElement.automaticStyles.getElementsByTagNameNS(h, \"page-layout\"),\n\t                    g = 0; g < n.length; g += 1)\n\t                        if (m = n.item(g),\n\t                        m.getAttributeNS(h, \"name\") === f)\n\t                            break a\n\t            }\n\t            m = null\n\t        }\n\t        m || (m = v.getDirectChild(a.rootElement.styles, h, \"default-page-layout\"));\n\t        (m = v.getDirectChild(m, h, \"page-layout-properties\")) ? (\"landscape\" === m.getAttributeNS(h, \"print-orientation\") ? (f = \"29.7cm\",\n\t        n = \"21.001cm\") : (f = \"21.001cm\",\n\t        n = \"29.7cm\"),\n\t        f = l(m.getAttributeNS(z, \"page-width\"), f),\n\t        n = l(m.getAttributeNS(z, \"page-height\"), n),\n\t        g = l(m.getAttributeNS(z, \"margin\")),\n\t        void 0 === g ? (g = l(m.getAttributeNS(z, \"margin-left\"), \"2cm\"),\n\t        k = l(m.getAttributeNS(z, \"margin-right\"), \"2cm\"),\n\t        r = l(m.getAttributeNS(z, \"margin-top\"), \"2cm\"),\n\t        p = l(m.getAttributeNS(z, \"margin-bottom\"), \"2cm\")) : g = k = r = p = g,\n\t        q = l(m.getAttributeNS(z, \"padding\")),\n\t        void 0 === q ? (q = l(m.getAttributeNS(z, \"padding-left\"), \"0cm\"),\n\t        y = l(m.getAttributeNS(z, \"padding-right\"), \"0cm\"),\n\t        u = l(m.getAttributeNS(z, \"padding-top\"), \"0cm\"),\n\t        m = l(m.getAttributeNS(z, \"padding-bottom\"), \"0cm\")) : q = y = u = m = q) : (f = l(\"21.001cm\"),\n\t        n = l(\"29.7cm\"),\n\t        g = k = r = p = g = l(\"2cm\"),\n\t        q = y = u = m = q = l(\"0cm\"));\n\t        return {\n\t            width: f - g - k - q - y,\n\t            height: n - r - p - u - m\n\t        }\n\t    }\n\t}\n\t;\n\t(function() {\n\t    var g = odf.Namespaces.stylens\n\t      , k = odf.Namespaces.textns\n\t      , d = {\n\t        graphic: \"draw\",\n\t        \"drawing-page\": \"draw\",\n\t        paragraph: \"text\",\n\t        presentation: \"presentation\",\n\t        ruby: \"text\",\n\t        section: \"text\",\n\t        table: \"table\",\n\t        \"table-cell\": \"table\",\n\t        \"table-column\": \"table\",\n\t        \"table-row\": \"table\",\n\t        text: \"text\",\n\t        list: \"text\",\n\t        page: \"office\"\n\t    };\n\t    odf.StyleTreeNode = function(b) {\n\t        this.derivedStyles = {};\n\t        this.element = b\n\t    }\n\t    ;\n\t    odf.StyleTree = function(b, f) {\n\t        function n(b) {\n\t            var a, c, d, e = {};\n\t            if (!b)\n\t                return e;\n\t            for (b = b.firstElementChild; b; ) {\n\t                if (c = b.namespaceURI !== g || \"style\" !== b.localName && \"default-style\" !== b.localName ? b.namespaceURI === k && \"list-style\" === b.localName ? \"list\" : b.namespaceURI !== g || \"page-layout\" !== b.localName && \"default-page-layout\" !== b.localName ? void 0 : \"page\" : b.getAttributeNS(g, \"family\"))\n\t                    (a = b.getAttributeNS(g, \"name\")) || (a = \"\"),\n\t                    e.hasOwnProperty(c) ? d = e[c] : e[c] = d = {},\n\t                    d[a] = b;\n\t                b = b.nextElementSibling\n\t            }\n\t            return e\n\t        }\n\t        function p(b, a) {\n\t            if (b.hasOwnProperty(a))\n\t                return b[a];\n\t            var c = null, d = Object.keys(b), e;\n\t            for (e = 0; e < d.length && !(c = p(b[d[e]].derivedStyles, a)); e += 1)\n\t                ;\n\t            return c\n\t        }\n\t        function r(b, a, c) {\n\t            var d, e, f;\n\t            if (!a.hasOwnProperty(b))\n\t                return null;\n\t            d = new odf.StyleTreeNode(a[b]);\n\t            e = d.element.getAttributeNS(g, \"parent-style-name\");\n\t            f = null;\n\t            e && (f = p(c, e) || r(e, a, c));\n\t            f ? f.derivedStyles[b] = d : c[b] = d;\n\t            delete a[b];\n\t            return d\n\t        }\n\t        function q(b, a) {\n\t            b && Object.keys(b).forEach(function(c) {\n\t                r(c, b, a)\n\t            })\n\t        }\n\t        var e = {};\n\t        this.getStyleTree = function() {\n\t            return e\n\t        }\n\t        ;\n\t        (function() {\n\t            var l, a, c;\n\t            a = n(b);\n\t            c = n(f);\n\t            Object.keys(d).forEach(function(b) {\n\t                l = e[b] = {};\n\t                q(a[b], l);\n\t                q(c[b], l)\n\t            })\n\t        }\n\t        )()\n\t    }\n\t}\n\t)();\n\t(function() {\n\t    function g(b, d) {\n\t        try {\n\t            b.insertRule(d, b.cssRules.length)\n\t        } catch (f) {\n\t            runtime.log(\"cannot load rule: \" + d + \" - \" + f)\n\t        }\n\t    }\n\t    function k(b, d) {\n\t        this.listCounterCount = 0;\n\t        this.contentRules = b;\n\t        this.counterIdStack = [];\n\t        this.continuedCounterIdStack = d\n\t    }\n\t    function d(b) {\n\t        function d(c, h, f, l) {\n\t            var k = h.namespaceURI === n && \"list\" === h.localName\n\t              , r = h.namespaceURI === n && \"list-item\" === h.localName;\n\t            if (k || r) {\n\t                if (k) {\n\t                    var k = f += 1, p, u, t;\n\t                    l.listCounterCount += 1;\n\t                    r = c + \"-level\" + k + \"-\" + l.listCounterCount;\n\t                    h.setAttributeNS(\"urn:webodf:names:helper\", \"counter-id\", r);\n\t                    p = l.continuedCounterIdStack.shift();\n\t                    p || (p = r,\n\t                    a += r + \" 1 \",\n\t                    u = 'text|list[webodfhelper|counter-id=\"' + r + '\"] > text|list-item:first-child > :not(text|list):first-child:before',\n\t                    u += \"{\",\n\t                    u += \"counter-increment: \" + p + \" 0;\",\n\t                    u += \"}\",\n\t                    g(b, u));\n\t                    for (; l.counterIdStack.length >= k; )\n\t                        l.counterIdStack.pop();\n\t                    l.counterIdStack.push(p);\n\t                    t = l.contentRules[k.toString()] || \"\";\n\t                    for (u = 1; u <= k; u += 1)\n\t                        t = t.replace(u + \"webodf-listLevel\", l.counterIdStack[u - 1]);\n\t                    u = 'text|list[webodfhelper|counter-id=\"' + r + '\"] > text|list-item > :not(text|list):first-child:before';\n\t                    u += \"{\";\n\t                    u += t;\n\t                    u += \"counter-increment: \" + p + \";\";\n\t                    u += \"}\";\n\t                    g(b, u)\n\t                }\n\t                for (h = h.firstElementChild; h; )\n\t                    d(c, h, f, l),\n\t                    h = h.nextElementSibling\n\t            } else\n\t                l.continuedCounterIdStack = []\n\t        }\n\t        var f = 0\n\t          , a = \"\"\n\t          , c = {};\n\t        this.createCounterRules = function(a, b, n) {\n\t            var g = b.getAttributeNS(p, \"id\")\n\t              , r = [];\n\t            n && (n = n.getAttributeNS(\"urn:webodf:names:helper\", \"counter-id\"),\n\t            r = c[n].slice(0));\n\t            a = new k(a,r);\n\t            g ? g = \"Y\" + g : (f += 1,\n\t            g = \"X\" + f);\n\t            d(g, b, 0, a);\n\t            c[g + \"-level1-1\"] = a.counterIdStack\n\t        }\n\t        ;\n\t        this.initialiseCreatedCounters = function() {\n\t            var c;\n\t            c = \"office|document{\" + (\"counter-reset: \" + a + \";\");\n\t            c += \"}\";\n\t            g(b, c)\n\t        }\n\t    }\n\t    var b = odf.Namespaces.fons\n\t      , f = odf.Namespaces.stylens\n\t      , n = odf.Namespaces.textns\n\t      , p = odf.Namespaces.xmlns\n\t      , r = {\n\t        1: \"decimal\",\n\t        a: \"lower-latin\",\n\t        A: \"upper-latin\",\n\t        i: \"lower-roman\",\n\t        I: \"upper-roman\"\n\t    };\n\t    odf.ListStyleToCss = function() {\n\t        function k(a) {\n\t            var b = m.parseLength(a);\n\t            return b ? c.convert(b.value, b.unit, \"px\") : (runtime.log(\"Could not parse value '\" + a + \"'.\"),\n\t            0)\n\t        }\n\t        function e(a) {\n\t            return a.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, '\\\\\"')\n\t        }\n\t        function l(a, c) {\n\t            var b;\n\t            a && (b = a.getAttributeNS(n, \"style-name\"));\n\t            return b === c\n\t        }\n\t        function a(a, c, b) {\n\t            c = c.getElementsByTagNameNS(n, \"list\");\n\t            a = new d(a);\n\t            var m, g, k, q, t, A, I = {}, K;\n\t            for (K = 0; K < c.length; K += 1)\n\t                if (m = c.item(K),\n\t                A = m.getAttributeNS(n, \"style-name\")) {\n\t                    k = m.getAttributeNS(n, \"continue-numbering\");\n\t                    q = m.getAttributeNS(n, \"continue-list\");\n\t                    (t = m.getAttributeNS(p, \"id\")) && (I[t] = m);\n\t                    t = b[A].element.firstElementChild;\n\t                    for (var L = void 0, E = {}; t; ) {\n\t                        var L = (L = t.getAttributeNS(n, \"level\")) && parseInt(L, 10)\n\t                          , N = t\n\t                          , O = \"\"\n\t                          , D = void 0\n\t                          , V = void 0\n\t                          , W = D = void 0;\n\t                        if (\"list-level-style-number\" === N.localName) {\n\t                            var J = N\n\t                              , O = J.getAttributeNS(f, \"num-format\")\n\t                              , D = J.getAttributeNS(f, \"num-suffix\") || \"\"\n\t                              , V = J.getAttributeNS(f, \"num-prefix\") || \"\"\n\t                              , R = \"\"\n\t                              , P = J.getAttributeNS(n, \"level\")\n\t                              , J = J.getAttributeNS(n, \"display-levels\");\n\t                            V && (R += '\"' + e(V) + '\"\\n');\n\t                            if (r.hasOwnProperty(O))\n\t                                for (P = P ? parseInt(P, 10) : 1,\n\t                                J = J ? parseInt(J, 10) : 1; 0 < J; )\n\t                                    R += \" counter(\" + (P - J + 1) + \"webodf-listLevel,\" + r[O] + \")\",\n\t                                    1 < J && (R += '\".\"'),\n\t                                    --J;\n\t                            else\n\t                                R = O ? R + (' \"' + O + '\"') : R + ' \"\"';\n\t                            O = \"content:\" + R + ' \"' + e(D) + '\"'\n\t                        } else\n\t                            \"list-level-style-image\" === N.localName ? O = \"content: none\" : \"list-level-style-bullet\" === N.localName && (O = N.getAttributeNS(n, \"bullet-char\"),\n\t                            O = 'content: \"' + e(O) + '\"');\n\t                        if (D = N.getElementsByTagNameNS(f, \"list-level-properties\")[0])\n\t                            V = D.getAttributeNS(n, \"list-level-position-and-space-mode\"),\n\t                            \"label-alignment\" === V && ((D = D.getElementsByTagNameNS(f, \"list-level-label-alignment\")[0]) && (W = D.getAttributeNS(n, \"label-followed-by\")),\n\t                            \"space\" === W && (O += ' \"\\\\a0\"'));\n\t                        E[L] = \"\\n\" + O + \";\\n\";\n\t                        t = t.nextElementSibling\n\t                    }\n\t                    t = E;\n\t                    k && !q && l(g, A) ? a.createCounterRules(t, m, g) : q && l(I[q], A) ? a.createCounterRules(t, m, I[q]) : a.createCounterRules(t, m);\n\t                    g = m\n\t                }\n\t            a.initialiseCreatedCounters()\n\t        }\n\t        var c = new core.CSSUnits\n\t          , m = odf.OdfUtils;\n\t        this.applyListStyles = function(c, d, e) {\n\t            var m, l;\n\t            (m = d.list) && Object.keys(m).forEach(function(a) {\n\t                l = m[a];\n\t                for (var d = l.element.firstElementChild; d; ) {\n\t                    if (d.namespaceURI === n) {\n\t                        for (var e = c, r = d, p = 'text|list[text|style-name=\"' + a + '\"]', y = r.getAttributeNS(n, \"level\"), x = void 0, E = void 0, N = E = void 0, O = void 0, D = void 0, V = x = void 0, W = void 0, J = void 0, R = void 0, O = void 0, N = (E = r.getElementsByTagNameNS(f, \"list-level-properties\")[0]) && E.getAttributeNS(n, \"list-level-position-and-space-mode\"), O = E && E.getElementsByTagNameNS(f, \"list-level-label-alignment\")[0], x = y = y && parseInt(y, 10); 1 < x; )\n\t                            p += \" > text|list-item > text|list\",\n\t                            --x;\n\t                        x = E && E.getAttributeNS(b, \"text-align\") || \"left\";\n\t                        switch (x) {\n\t                        case \"end\":\n\t                            x = \"right\";\n\t                            break;\n\t                        case \"start\":\n\t                            x = \"left\"\n\t                        }\n\t                        \"label-alignment\" === N ? (D = O && O.getAttributeNS(b, \"margin-left\") || \"0px\",\n\t                        J = O && O.getAttributeNS(b, \"text-indent\") || \"0px\",\n\t                        R = O && O.getAttributeNS(n, \"label-followed-by\"),\n\t                        O = k(D)) : (D = E && E.getAttributeNS(n, \"space-before\") || \"0px\",\n\t                        V = E && E.getAttributeNS(n, \"min-label-width\") || \"0px\",\n\t                        W = E && E.getAttributeNS(n, \"min-label-distance\") || \"0px\",\n\t                        O = k(D) + k(V));\n\t                        E = p + \" > text|list-item\";\n\t                        E += \"{\";\n\t                        E += \"margin-left: \" + O + \"px;\";\n\t                        E += \"}\";\n\t                        g(e, E);\n\t                        E = p + \" > text|list-item > text|list\";\n\t                        E += \"{\";\n\t                        E += \"margin-left: \" + -O + \"px;\";\n\t                        E += \"}\";\n\t                        g(e, E);\n\t                        E = p + \" > text|list-item > :not(text|list):first-child:before\";\n\t                        E += \"{\";\n\t                        E += \"text-align: \" + x + \";\";\n\t                        E += \"display: inline-block;\";\n\t                        \"label-alignment\" === N ? (E += \"margin-left: \" + J + \";\",\n\t                        \"listtab\" === R && (E += \"padding-right: 0.2cm;\")) : (E += \"min-width: \" + V + \";\",\n\t                        E += \"margin-left: \" + (0 === parseFloat(V) ? \"\" : \"-\") + V + \";\",\n\t                        E += \"padding-right: \" + W + \";\");\n\t                        E += \"}\";\n\t                        g(e, E)\n\t                    }\n\t                    d = d.nextElementSibling\n\t                }\n\t            });\n\t            a(c, e, m)\n\t        }\n\t    }\n\t}\n\t)();\n\todf.LazyStyleProperties = function(g, k) {\n\t    var d = {};\n\t    this.value = function(b) {\n\t        var f;\n\t        d.hasOwnProperty(b) ? f = d[b] : (f = k[b](),\n\t        void 0 === f && g && (f = g.value(b)),\n\t        d[b] = f);\n\t        return f\n\t    }\n\t    ;\n\t    this.reset = function(b) {\n\t        g = b;\n\t        d = {}\n\t    }\n\t}\n\t;\n\todf.StyleParseUtils = function() {\n\t    function g(d) {\n\t        var b, f;\n\t        d = (d = /(-?[0-9]*[0-9][0-9]*(\\.[0-9]*)?|0+\\.[0-9]*[1-9][0-9]*|\\.[0-9]*[1-9][0-9]*)((cm)|(mm)|(in)|(pt)|(pc)|(px))/.exec(d)) ? {\n\t            value: parseFloat(d[1]),\n\t            unit: d[3]\n\t        } : null;\n\t        f = d && d.unit;\n\t        \"px\" === f ? b = d.value : \"cm\" === f ? b = d.value / 2.54 * 96 : \"mm\" === f ? b = d.value / 25.4 * 96 : \"in\" === f ? b = 96 * d.value : \"pt\" === f ? b = d.value / .75 : \"pc\" === f && (b = 16 * d.value);\n\t        return b\n\t    }\n\t    var k = odf.Namespaces.stylens;\n\t    this.parseLength = g;\n\t    this.parsePositiveLengthOrPercent = function(d, b, f) {\n\t        var n;\n\t        d && (n = parseFloat(d.substr(0, d.indexOf(\"%\"))),\n\t        isNaN(n) && (n = void 0));\n\t        var k;\n\t        void 0 !== n ? (f && (k = f.value(b)),\n\t        n = void 0 === k ? void 0 : k / 100 * n) : n = g(d);\n\t        return n\n\t    }\n\t    ;\n\t    this.getPropertiesElement = function(d, b, f) {\n\t        for (b = f ? f.nextElementSibling : b.firstElementChild; null !== b && (b.localName !== d || b.namespaceURI !== k); )\n\t            b = b.nextElementSibling;\n\t        return b\n\t    }\n\t    ;\n\t    this.parseAttributeList = function(d) {\n\t        d && (d = d.replace(/^\\s*(.*?)\\s*$/g, \"$1\"));\n\t        return d && 0 < d.length ? d.split(/\\s+/) : []\n\t    }\n\t}\n\t;\n\todf.Style2CSS = function() {\n\t    function g(a, c, b) {\n\t        var d = [];\n\t        b = b.derivedStyles;\n\t        var e;\n\t        var h = z[a], m;\n\t        void 0 === h ? c = null : (m = c ? \"[\" + h + '|style-name=\"' + c + '\"]' : \"\",\n\t        \"presentation\" === h && (h = \"draw\",\n\t        m = c ? '[presentation|style-name=\"' + c + '\"]' : \"\"),\n\t        c = h + \"|\" + w[a].join(m + \",\" + h + \"|\") + m);\n\t        null !== c && d.push(c);\n\t        for (e in b)\n\t            b.hasOwnProperty(e) && (c = g(a, e, b[e]),\n\t            d = d.concat(c));\n\t        return d\n\t    }\n\t    function k(a) {\n\t        var c = \"\"\n\t          , b = \"\"\n\t          , c = null;\n\t        if (\"default-style\" === a.localName)\n\t            return null;\n\t        c = a.getAttributeNS(l, \"parent-style-name\");\n\t        b = a.getAttributeNS(l, \"family\");\n\t        return c = S.getODFElementsWithXPath(P, c ? \"//style:*[@style:name='\" + c + \"'][@style:family='\" + b + \"']\" : \"//style:default-style[@style:family='\" + b + \"']\", odf.Namespaces.lookupNamespaceURI)[0]\n\t    }\n\t    function d(a, c) {\n\t        var b = \"\", d, e, h;\n\t        for (d = 0; d < c.length; d += 1)\n\t            if (e = c[d],\n\t            h = a.getAttributeNS(e[0], e[1])) {\n\t                h = h.trim();\n\t                if (D.hasOwnProperty(e[1])) {\n\t                    var m = h\n\t                      , f = m.indexOf(\" \")\n\t                      , n = void 0;\n\t                    h = void 0;\n\t                    -1 !== f ? (n = m.substring(0, f),\n\t                    h = m.substring(f)) : (n = m,\n\t                    h = \"\");\n\t                    (n = J.parseLength(n)) && \"pt\" === n.unit && .75 > n.value && (m = \"0.75pt\" + h);\n\t                    h = m\n\t                } else if (V.hasOwnProperty(e[1])) {\n\t                    var m = a\n\t                      , f = e[0]\n\t                      , n = e[1]\n\t                      , g = J.parseLength(h)\n\t                      , r = void 0\n\t                      , p = void 0\n\t                      , q = void 0\n\t                      , O = void 0\n\t                      , q = void 0;\n\t                    if (g && \"%\" === g.unit) {\n\t                        r = g.value / 100;\n\t                        p = k(m.parentNode);\n\t                        for (O = \"0\"; p; ) {\n\t                            if (q = y.getDirectChild(p, l, \"paragraph-properties\"))\n\t                                if (q = J.parseLength(q.getAttributeNS(f, n))) {\n\t                                    if (\"%\" !== q.unit) {\n\t                                        O = q.value * r + q.unit;\n\t                                        break\n\t                                    }\n\t                                    r *= q.value / 100\n\t                                }\n\t                            p = k(p)\n\t                        }\n\t                        h = O\n\t                    }\n\t                }\n\t                e[2] && (b += e[2] + \":\" + h + \";\")\n\t            }\n\t        return b\n\t    }\n\t    function b(a, c, b, d) {\n\t        return c + c + b + b + d + d\n\t    }\n\t    function f(a, c) {\n\t        var b = [a]\n\t          , d = c.derivedStyles;\n\t        Object.keys(d).forEach(function(a) {\n\t            a = f(a, d[a]);\n\t            b = b.concat(a)\n\t        });\n\t        return b\n\t    }\n\t    function n(a, c, b, d) {\n\t        function e(c, b) {\n\t            var d = [], h;\n\t            c.forEach(function(a) {\n\t                m.forEach(function(c) {\n\t                    d.push('draw|page[webodfhelper|page-style-name=\"' + c + '\"] draw|frame[presentation|class=\"' + a + '\"]')\n\t                })\n\t            });\n\t            0 < d.length && (h = d.join(\",\") + \"{visibility:\" + b + \";}\",\n\t            a.insertRule(h, a.cssRules.length))\n\t        }\n\t        var m = f(c, d)\n\t          , l = []\n\t          , n = [];\n\t        [\"page-number\", \"date-time\", \"header\", \"footer\"].forEach(function(a) {\n\t            var c;\n\t            c = b.getAttributeNS(h, \"display-\" + a);\n\t            \"true\" === c ? l.push(a) : \"false\" === c && n.push(a)\n\t        });\n\t        e(l, \"visible\");\n\t        e(n, \"hidden\")\n\t    }\n\t    function p(a, f, D, V) {\n\t        var z, w;\n\t        if (\"page\" === f) {\n\t            var B = V.element, P = \"\", M, Q;\n\t            Q = M = \"\";\n\t            D = y.getDirectChild(B, l, \"page-layout-properties\");\n\t            var F;\n\t            if (D)\n\t                if (F = B.getAttributeNS(l, \"name\"),\n\t                P += d(D, N),\n\t                (M = y.getDirectChild(D, l, \"background-image\")) && (Q = M.getAttributeNS(m, \"href\")) && (P = P + (\"background-image: url('odfkit:\" + Q + \"');\") + d(M, u)),\n\t                \"presentation\" === R)\n\t                    for (B = (B = y.getDirectChild(B.parentNode.parentNode, e, \"master-styles\")) && B.firstElementChild; B; )\n\t                        B.namespaceURI === l && \"master-page\" === B.localName && B.getAttributeNS(l, \"page-layout-name\") === F && (Q = B.getAttributeNS(l, \"name\"),\n\t                        M = 'draw|page[draw|master-page-name=\"' + Q + '\"] {' + P + \"}\",\n\t                        Q = 'office|body, draw|page[draw|master-page-name=\"' + Q + '\"] {' + d(D, O) + \" }\",\n\t                        a.insertRule(M, a.cssRules.length),\n\t                        a.insertRule(Q, a.cssRules.length)),\n\t                        B = B.nextElementSibling;\n\t                else\n\t                    \"text\" === R && (M = \"office|text {\" + P + \"}\",\n\t                    Q = \"office|body {width: \" + D.getAttributeNS(q, \"page-width\") + \";}\",\n\t                    a.insertRule(M, a.cssRules.length),\n\t                    a.insertRule(Q, a.cssRules.length))\n\t        } else {\n\t            P = g(f, D, V).join(\",\");\n\t            F = \"\";\n\t            if (B = y.getDirectChild(V.element, l, \"text-properties\")) {\n\t                var S = B\n\t                  , ca = w = \"\";\n\t                M = \"\";\n\t                Q = 1;\n\t                B = \"\" + d(S, v);\n\t                z = S.getAttributeNS(l, \"text-underline-style\");\n\t                \"solid\" === z && (w += \" underline\");\n\t                z = S.getAttributeNS(l, \"text-line-through-style\");\n\t                \"solid\" === z && (w += \" line-through\");\n\t                w.length && (B = B + (\"text-decoration:\" + w + \";\\n\") + (\"text-decoration-line:\" + w + \";\\n\"),\n\t                B += \"-moz-text-decoration-line:\" + w + \";\\n\");\n\t                z = S.getAttributeNS(l, \"text-line-through-type\");\n\t                switch (z) {\n\t                case \"double\":\n\t                    ca += \" double\";\n\t                    break;\n\t                case \"single\":\n\t                    ca += \" single\"\n\t                }\n\t                ca && (B += \"text-decoration-style:\" + ca + \";\\n\",\n\t                B += \"-moz-text-decoration-style:\" + ca + \";\\n\");\n\t                if (w = S.getAttributeNS(l, \"font-name\") || S.getAttributeNS(q, \"font-family\"))\n\t                    z = W[w],\n\t                    B += \"font-family: \" + (z || w) + \";\";\n\t                if (z = S.getAttributeNS(l, \"text-position\"))\n\t                    w = x.parseAttributeList(z),\n\t                    z = w[0],\n\t                    w = w[1],\n\t                    B += \"vertical-align: \" + z + \"\\n; \",\n\t                    w && (Q = parseFloat(w) / 100);\n\t                if (S.hasAttributeNS(q, \"font-size\") || 1 !== Q) {\n\t                    for (S = S.parentNode; S; ) {\n\t                        if (z = (z = y.getDirectChild(S, l, \"text-properties\")) ? J.parseFoFontSize(z.getAttributeNS(q, \"font-size\")) : null) {\n\t                            if (\"%\" !== z.unit) {\n\t                                M = \"font-size: \" + z.value * Q + z.unit + \";\";\n\t                                break\n\t                            }\n\t                            Q *= z.value / 100\n\t                        }\n\t                        S = k(S)\n\t                    }\n\t                    M || (M = \"font-size: \" + parseFloat(aa) * Q + fa.getUnits(aa) + \";\")\n\t                }\n\t                B += M;\n\t                F += B\n\t            }\n\t            if (B = y.getDirectChild(V.element, l, \"paragraph-properties\"))\n\t                M = B,\n\t                B = \"\" + d(M, t),\n\t                (Q = y.getDirectChild(M, l, \"background-image\")) && (S = Q.getAttributeNS(m, \"href\")) && (B = B + (\"background-image: url('odfkit:\" + S + \"');\") + d(Q, u)),\n\t                (M = M.getAttributeNS(q, \"line-height\")) && \"normal\" !== M && (M = J.parseFoLineHeight(M),\n\t                B = \"%\" !== M.unit ? B + (\"line-height: \" + M.value + M.unit + \";\") : B + (\"line-height: \" + M.value / 100 + \";\")),\n\t                F += B;\n\t            if (B = y.getDirectChild(V.element, l, \"graphic-properties\"))\n\t                S = B,\n\t                B = \"\" + d(S, A),\n\t                M = S.getAttributeNS(r, \"opacity\"),\n\t                Q = S.getAttributeNS(r, \"fill\"),\n\t                S = S.getAttributeNS(r, \"fill-color\"),\n\t                \"solid\" === Q || \"hatch\" === Q ? S && \"none\" !== S ? (M = isNaN(parseFloat(M)) ? 1 : parseFloat(M) / 100,\n\t                Q = S.replace(/^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i, b),\n\t                (S = (Q = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(Q)) ? {\n\t                    r: parseInt(Q[1], 16),\n\t                    g: parseInt(Q[2], 16),\n\t                    b: parseInt(Q[3], 16)\n\t                } : null) && (B += \"background-color: rgba(\" + S.r + \",\" + S.g + \",\" + S.b + \",\" + M + \");\")) : B += \"background: none;\" : \"none\" === Q && (B += \"background: none;\"),\n\t                F += B;\n\t            if (B = y.getDirectChild(V.element, l, \"drawing-page-properties\"))\n\t                M = B,\n\t                Q = \"\" + d(M, A),\n\t                \"true\" === M.getAttributeNS(h, \"background-visible\") && (Q += \"background: none;\"),\n\t                F += Q,\n\t                n(a, D, B, V);\n\t            if (B = y.getDirectChild(V.element, l, \"table-cell-properties\"))\n\t                D = F,\n\t                F = \"\" + d(B, I),\n\t                F = D + F;\n\t            if (B = y.getDirectChild(V.element, l, \"table-row-properties\"))\n\t                D = F,\n\t                F = \"\" + d(B, L),\n\t                F = D + F;\n\t            if (B = y.getDirectChild(V.element, l, \"table-column-properties\"))\n\t                D = F,\n\t                F = \"\" + d(B, K),\n\t                F = D + F;\n\t            if (B = y.getDirectChild(V.element, l, \"table-properties\"))\n\t                D = F,\n\t                F = \"\" + d(B, E),\n\t                B = B.getAttributeNS(c, \"border-model\"),\n\t                \"collapsing\" === B ? F += \"border-collapse:collapse;\" : \"separating\" === B && (F += \"border-collapse:separate;\"),\n\t                F = D + F;\n\t            0 !== F.length && a.insertRule(P + \"{\" + F + \"}\", a.cssRules.length)\n\t        }\n\t        for (var X in V.derivedStyles)\n\t            V.derivedStyles.hasOwnProperty(X) && p(a, f, X, V.derivedStyles[X])\n\t    }\n\t    var r = odf.Namespaces.drawns, q = odf.Namespaces.fons, e = odf.Namespaces.officens, l = odf.Namespaces.stylens, a = odf.Namespaces.svgns, c = odf.Namespaces.tablens, m = odf.Namespaces.xlinkns, h = odf.Namespaces.presentationns, y = core.DomUtils, x = new odf.StyleParseUtils, z = {\n\t        graphic: \"draw\",\n\t        \"drawing-page\": \"draw\",\n\t        paragraph: \"text\",\n\t        presentation: \"presentation\",\n\t        ruby: \"text\",\n\t        section: \"text\",\n\t        table: \"table\",\n\t        \"table-cell\": \"table\",\n\t        \"table-column\": \"table\",\n\t        \"table-row\": \"table\",\n\t        text: \"text\",\n\t        list: \"text\",\n\t        page: \"office\"\n\t    }, w = {\n\t        graphic: \"circle connected control custom-shape ellipse frame g line measure page page-thumbnail path polygon polyline rect regular-polygon\".split(\" \"),\n\t        paragraph: \"alphabetical-index-entry-template h illustration-index-entry-template index-source-style object-index-entry-template p table-index-entry-template table-of-content-entry-template user-index-entry-template\".split(\" \"),\n\t        presentation: \"caption circle connector control custom-shape ellipse frame g line measure page-thumbnail path polygon polyline rect regular-polygon\".split(\" \"),\n\t        \"drawing-page\": \"caption circle connector control page custom-shape ellipse frame g line measure page-thumbnail path polygon polyline rect regular-polygon\".split(\" \"),\n\t        ruby: [\"ruby\", \"ruby-text\"],\n\t        section: \"alphabetical-index bibliography illustration-index index-title object-index section table-of-content table-index user-index\".split(\" \"),\n\t        table: [\"background\", \"table\"],\n\t        \"table-cell\": \"body covered-table-cell even-columns even-rows first-column first-row last-column last-row odd-columns odd-rows table-cell\".split(\" \"),\n\t        \"table-column\": [\"table-column\"],\n\t        \"table-row\": [\"table-row\"],\n\t        text: \"a index-entry-chapter index-entry-link-end index-entry-link-start index-entry-page-number index-entry-span index-entry-tab-stop index-entry-text index-title-template linenumbering-configuration list-level-style-number list-level-style-bullet outline-level-style span\".split(\" \"),\n\t        list: [\"list-item\"]\n\t    }, v = [[q, \"color\", \"color\"], [q, \"background-color\", \"background-color\"], [q, \"font-weight\", \"font-weight\"], [q, \"font-style\", \"font-style\"]], u = [[l, \"repeat\", \"background-repeat\"]], t = [[q, \"background-color\", \"background-color\"], [q, \"text-align\", \"text-align\"], [q, \"text-indent\", \"text-indent\"], [q, \"padding\", \"padding\"], [q, \"padding-left\", \"padding-left\"], [q, \"padding-right\", \"padding-right\"], [q, \"padding-top\", \"padding-top\"], [q, \"padding-bottom\", \"padding-bottom\"], [q, \"border-left\", \"border-left\"], [q, \"border-right\", \"border-right\"], [q, \"border-top\", \"border-top\"], [q, \"border-bottom\", \"border-bottom\"], [q, \"margin\", \"margin\"], [q, \"margin-left\", \"margin-left\"], [q, \"margin-right\", \"margin-right\"], [q, \"margin-top\", \"margin-top\"], [q, \"margin-bottom\", \"margin-bottom\"], [q, \"border\", \"border\"]], A = [[q, \"background-color\", \"background-color\"], [q, \"min-height\", \"min-height\"], [r, \"stroke\", \"border\"], [a, \"stroke-color\", \"border-color\"], [a, \"stroke-width\", \"border-width\"], [q, \"border\", \"border\"], [q, \"border-left\", \"border-left\"], [q, \"border-right\", \"border-right\"], [q, \"border-top\", \"border-top\"], [q, \"border-bottom\", \"border-bottom\"]], I = [[q, \"background-color\", \"background-color\"], [q, \"border-left\", \"border-left\"], [q, \"border-right\", \"border-right\"], [q, \"border-top\", \"border-top\"], [q, \"border-bottom\", \"border-bottom\"], [q, \"border\", \"border\"]], K = [[l, \"column-width\", \"width\"]], L = [[l, \"row-height\", \"height\"], [q, \"keep-together\", null]], E = [[l, \"width\", \"width\"], [q, \"margin-left\", \"margin-left\"], [q, \"margin-right\", \"margin-right\"], [q, \"margin-top\", \"margin-top\"], [q, \"margin-bottom\", \"margin-bottom\"]], N = [[q, \"background-color\", \"background-color\"], [q, \"padding\", \"padding\"], [q, \"padding-left\", \"padding-left\"], [q, \"padding-right\", \"padding-right\"], [q, \"padding-top\", \"padding-top\"], [q, \"padding-bottom\", \"padding-bottom\"], [q, \"border\", \"border\"], [q, \"border-left\", \"border-left\"], [q, \"border-right\", \"border-right\"], [q, \"border-top\", \"border-top\"], [q, \"border-bottom\", \"border-bottom\"], [q, \"margin\", \"margin\"], [q, \"margin-left\", \"margin-left\"], [q, \"margin-right\", \"margin-right\"], [q, \"margin-top\", \"margin-top\"], [q, \"margin-bottom\", \"margin-bottom\"]], O = [[q, \"page-width\", \"width\"], [q, \"page-height\", \"height\"]], D = {\n\t        border: !0,\n\t        \"border-left\": !0,\n\t        \"border-right\": !0,\n\t        \"border-top\": !0,\n\t        \"border-bottom\": !0,\n\t        \"stroke-width\": !0\n\t    }, V = {\n\t        margin: !0,\n\t        \"margin-left\": !0,\n\t        \"margin-right\": !0,\n\t        \"margin-top\": !0,\n\t        \"margin-bottom\": !0\n\t    }, W = {}, J = odf.OdfUtils, R, P, aa, S = xmldom.XPath, fa = new core.CSSUnits;\n\t    this.style2css = function(a, c, b, d, e) {\n\t        function h(a, c) {\n\t            m = \"@namespace \" + a + \" url(\" + c + \");\";\n\t            try {\n\t                b.insertRule(m, b.cssRules.length)\n\t            } catch (d) {}\n\t        }\n\t        var m, f, l;\n\t        for (P = c; b.cssRules.length; )\n\t            b.deleteRule(b.cssRules.length - 1);\n\t        odf.Namespaces.forEachPrefix(h);\n\t        h(\"webodfhelper\", \"urn:webodf:names:helper\");\n\t        W = d;\n\t        R = a;\n\t        aa = runtime.getWindow().getComputedStyle(document.body, null).getPropertyValue(\"font-size\") || \"12pt\";\n\t        for (l in z)\n\t            if (z.hasOwnProperty(l))\n\t                for (f in a = e[l],\n\t                a)\n\t                    a.hasOwnProperty(f) && p(b, l, f, a[f])\n\t    }\n\t}\n\t;\n\t(function() {\n\t    function g(k, d) {\n\t        var b = this;\n\t        this.getDistance = function(d) {\n\t            var n = b.x - d.x;\n\t            d = b.y - d.y;\n\t            return Math.sqrt(n * n + d * d)\n\t        }\n\t        ;\n\t        this.getCenter = function(d) {\n\t            return new g((b.x + d.x) / 2,(b.y + d.y) / 2)\n\t        }\n\t        ;\n\t        b.x = k;\n\t        b.y = d\n\t    }\n\t    gui.ZoomHelper = function() {\n\t        function k(a, b, d, e) {\n\t            a = e ? \"translate3d(\" + a + \"px, \" + b + \"px, 0) scale3d(\" + d + \", \" + d + \", 1)\" : \"translate(\" + a + \"px, \" + b + \"px) scale(\" + d + \")\";\n\t            c.style.WebkitTransform = a;\n\t            c.style.MozTransform = a;\n\t            c.style.msTransform = a;\n\t            c.style.OTransform = a;\n\t            c.style.transform = a\n\t        }\n\t        function d(a) {\n\t            a ? k(-m.x, -m.y, x, !0) : (k(0, 0, x, !0),\n\t            k(0, 0, x, !1))\n\t        }\n\t        function b(a) {\n\t            if (w && I) {\n\t                var c = w.style.overflow\n\t                  , b = w.classList.contains(\"webodf-customScrollbars\");\n\t                a && b || !a && !b || (a ? (w.classList.add(\"webodf-customScrollbars\"),\n\t                w.style.overflow = \"hidden\",\n\t                runtime.requestAnimationFrame(function() {\n\t                    w.style.overflow = c\n\t                })) : w.classList.remove(\"webodf-customScrollbars\"))\n\t            }\n\t        }\n\t        function f() {\n\t            k(-m.x, -m.y, x, !0);\n\t            w.scrollLeft = 0;\n\t            w.scrollTop = 0;\n\t            K = v.style.overflow;\n\t            v.style.overflow = \"visible\";\n\t            b(!1)\n\t        }\n\t        function n() {\n\t            k(0, 0, x, !0);\n\t            w.scrollLeft = m.x;\n\t            w.scrollTop = m.y;\n\t            v.style.overflow = K || \"\";\n\t            b(!0)\n\t        }\n\t        function p(a) {\n\t            return new g(a.pageX - c.offsetLeft,a.pageY - c.offsetTop)\n\t        }\n\t        function r(a) {\n\t            if (h) {\n\t                m.x -= a.x - h.x;\n\t                m.y -= a.y - h.y;\n\t                var b = m;\n\t                m = new g(Math.min(Math.max(b.x, c.offsetLeft), (c.offsetLeft + c.offsetWidth) * x - w.clientWidth),Math.min(Math.max(b.y, c.offsetTop), (c.offsetTop + c.offsetHeight) * x - w.clientHeight))\n\t            }\n\t            h = a\n\t        }\n\t        function q(a) {\n\t            var c = a.touches.length\n\t              , b = 0 < c ? p(a.touches[0]) : null;\n\t            a = 1 < c ? p(a.touches[1]) : null;\n\t            b && a ? (y = b.getDistance(a),\n\t            z = x,\n\t            h = b.getCenter(a),\n\t            f(),\n\t            A = t.PINCH) : b && (h = b,\n\t            A = t.SCROLL)\n\t        }\n\t        function e(a) {\n\t            var b = a.touches.length\n\t              , e = 0 < b ? p(a.touches[0]) : null\n\t              , b = 1 < b ? p(a.touches[1]) : null;\n\t            if (e && b)\n\t                if (a.preventDefault(),\n\t                A === t.SCROLL)\n\t                    A = t.PINCH,\n\t                    f(),\n\t                    y = e.getDistance(b);\n\t                else {\n\t                    a = e.getCenter(b);\n\t                    e = e.getDistance(b) / y;\n\t                    r(a);\n\t                    var b = x\n\t                      , h = Math.min(4, c.offsetParent.clientWidth / c.offsetWidth);\n\t                    x = z * e;\n\t                    x = Math.min(Math.max(x, h), 4);\n\t                    e = x / b;\n\t                    m.x += (e - 1) * (a.x + m.x);\n\t                    m.y += (e - 1) * (a.y + m.y);\n\t                    d(!0)\n\t                }\n\t            else\n\t                e && (A === t.PINCH ? (A = t.SCROLL,\n\t                n()) : r(e))\n\t        }\n\t        function l() {\n\t            A === t.PINCH && (u.emit(gui.ZoomHelper.signalZoomChanged, x),\n\t            n(),\n\t            d(!1));\n\t            A = t.NONE\n\t        }\n\t        function a() {\n\t            w && (w.removeEventListener(\"touchstart\", q, !1),\n\t            w.removeEventListener(\"touchmove\", e, !1),\n\t            w.removeEventListener(\"touchend\", l, !1))\n\t        }\n\t        var c, m, h, y, x, z, w, v, u = new core.EventNotifier([gui.ZoomHelper.signalZoomChanged]), t = {\n\t            NONE: 0,\n\t            SCROLL: 1,\n\t            PINCH: 2\n\t        }, A = t.NONE, I = runtime.getWindow().hasOwnProperty(\"ontouchstart\"), K = \"\";\n\t        this.subscribe = function(a, c) {\n\t            u.subscribe(a, c)\n\t        }\n\t        ;\n\t        this.unsubscribe = function(a, c) {\n\t            u.unsubscribe(a, c)\n\t        }\n\t        ;\n\t        this.getZoomLevel = function() {\n\t            return x\n\t        }\n\t        ;\n\t        this.setZoomLevel = function(a) {\n\t            c && (x = a,\n\t            d(!1),\n\t            u.emit(gui.ZoomHelper.signalZoomChanged, x))\n\t        }\n\t        ;\n\t        this.destroy = function(c) {\n\t            a();\n\t            b(!1);\n\t            c()\n\t        }\n\t        ;\n\t        this.setZoomableElement = function(h) {\n\t            a();\n\t            c = h;\n\t            w = c.offsetParent;\n\t            v = c.parentNode;\n\t            d(!1);\n\t            w && (w.addEventListener(\"touchstart\", q, !1),\n\t            w.addEventListener(\"touchmove\", e, !1),\n\t            w.addEventListener(\"touchend\", l, !1));\n\t            b(!0)\n\t        }\n\t        ;\n\t        z = x = 1;\n\t        m = new g(0,0)\n\t    }\n\t    ;\n\t    gui.ZoomHelper.signalZoomChanged = \"zoomChanged\"\n\t}\n\t)();\n\tops.Canvas = function() {}\n\t;\n\tops.Canvas.prototype.getZoomLevel = function() {}\n\t;\n\tops.Canvas.prototype.getElement = function() {}\n\t;\n\tops.Canvas.prototype.getSizer = function() {}\n\t;\n\tops.Canvas.prototype.getZoomHelper = function() {}\n\t;\n\t(function() {\n\t    function g() {\n\t        function a(d) {\n\t            b = !0;\n\t            runtime.setTimeout(function() {\n\t                try {\n\t                    d()\n\t                } catch (e) {\n\t                    runtime.log(String(e) + \"\\n\" + e.stack)\n\t                }\n\t                b = !1;\n\t                0 < c.length && a(c.pop())\n\t            }, 10)\n\t        }\n\t        var c = []\n\t          , b = !1;\n\t        this.clearQueue = function() {\n\t            c.length = 0\n\t        }\n\t        ;\n\t        this.addToQueue = function(d) {\n\t            if (0 === c.length && !b)\n\t                return a(d);\n\t            c.push(d)\n\t        }\n\t    }\n\t    function k(a) {\n\t        function c() {\n\t            for (; 0 < b.cssRules.length; )\n\t                b.deleteRule(0);\n\t            b.insertRule(\"#shadowContent draw|page {display:none;}\", 0);\n\t            b.insertRule(\"office|presentation draw|page {display:none;}\", 1);\n\t            b.insertRule(\"#shadowContent draw|page:nth-of-type(\" + d + \") {display:block;}\", 2);\n\t            b.insertRule(\"office|presentation draw|page:nth-of-type(\" + d + \") {display:block;}\", 3)\n\t        }\n\t        var b = a.sheet\n\t          , d = 1;\n\t        this.showFirstPage = function() {\n\t            d = 1;\n\t            c()\n\t        }\n\t        ;\n\t        this.showNextPage = function() {\n\t            d += 1;\n\t            c()\n\t        }\n\t        ;\n\t        this.showPreviousPage = function() {\n\t            1 < d && (--d,\n\t            c())\n\t        }\n\t        ;\n\t        this.showPage = function(a) {\n\t            0 < a && (d = a,\n\t            c())\n\t        }\n\t        ;\n\t        this.css = a;\n\t        this.destroy = function(c) {\n\t            a.parentNode.removeChild(a);\n\t            c()\n\t        }\n\t    }\n\t    function d(a) {\n\t        a = a.sheet;\n\t        for (var c = a.cssRules; c.length; )\n\t            a.deleteRule(c.length - 1)\n\t    }\n\t    function b(a, c, b) {\n\t        var d = new odf.Style2CSS\n\t          , e = new odf.ListStyleToCss;\n\t        b = b.sheet;\n\t        var h = (new odf.StyleTree(a.rootElement.styles,a.rootElement.automaticStyles)).getStyleTree();\n\t        d.style2css(a.getDocumentType(), a.rootElement, b, c.getFontMap(), h);\n\t        e.applyListStyles(b, h, a.rootElement.body)\n\t    }\n\t    function f(a, c) {\n\t        (new odf.FontLoader).loadFonts(a, c.sheet)\n\t    }\n\t    function n(a, c, b) {\n\t        var d = null;\n\t        a = a.rootElement.body.getElementsByTagNameNS(L, b + \"-decl\");\n\t        b = c.getAttributeNS(L, \"use-\" + b + \"-name\");\n\t        var e;\n\t        if (b && 0 < a.length)\n\t            for (c = 0; c < a.length; c += 1)\n\t                if (e = a[c],\n\t                e.getAttributeNS(L, \"name\") === b) {\n\t                    d = e.textContent;\n\t                    break\n\t                }\n\t        return d\n\t    }\n\t    function p(a, c, b, d) {\n\t        var e = a.ownerDocument;\n\t        c = N.getElementsByTagNameNS(a, c, b);\n\t        for (a = 0; a < c.length; a += 1)\n\t            N.removeAllChildNodes(c[a]),\n\t            d && (b = c[a],\n\t            b.appendChild(e.createTextNode(d)))\n\t    }\n\t    function r(a, c, b) {\n\t        c.setAttributeNS(\"urn:webodf:names:helper\", \"styleid\", a);\n\t        var d, e = c.getAttributeNS(I, \"anchor-type\"), h = c.getAttributeNS(t, \"x\"), m = c.getAttributeNS(t, \"y\"), f = c.getAttributeNS(t, \"width\"), l = c.getAttributeNS(t, \"height\"), n = c.getAttributeNS(w, \"min-height\"), g = c.getAttributeNS(w, \"min-width\");\n\t        if (\"as-char\" === e)\n\t            d = \"display: inline-block;\";\n\t        else if (e || h || m)\n\t            d = \"position: absolute;\";\n\t        else if (f || l || n || g)\n\t            d = \"display: block;\";\n\t        h && (d += \"left: \" + h + \";\");\n\t        m && (d += \"top: \" + m + \";\");\n\t        f && (d += \"width: \" + f + \";\");\n\t        l && (d += \"height: \" + l + \";\");\n\t        n && (d += \"min-height: \" + n + \";\");\n\t        g && (d += \"min-width: \" + g + \";\");\n\t        d && (d = \"draw|\" + c.localName + '[webodfhelper|styleid=\"' + a + '\"] {' + d + \"}\",\n\t        b.insertRule(d, b.cssRules.length))\n\t    }\n\t    function q(a) {\n\t        for (a = a.firstChild; a; ) {\n\t            if (a.namespaceURI === v && \"binary-data\" === a.localName)\n\t                return \"data:image/png;base64,\" + a.textContent.replace(/[\\r\\n\\s]/g, \"\");\n\t            a = a.nextSibling\n\t        }\n\t        return \"\"\n\t    }\n\t    function e(a, c, b, d) {\n\t        function e(c) {\n\t            c && (c = 'draw|image[webodfhelper|styleid=\"' + a + '\"] {' + (\"background-image: url(\" + c + \");\") + \"}\",\n\t            d.insertRule(c, d.cssRules.length))\n\t        }\n\t        function h(a) {\n\t            e(a.url)\n\t        }\n\t        b.setAttributeNS(\"urn:webodf:names:helper\", \"styleid\", a);\n\t        var m = b.getAttributeNS(K, \"href\"), f;\n\t        if (m)\n\t            try {\n\t                f = c.getPart(m),\n\t                f.onchange = h,\n\t                f.load()\n\t            } catch (l) {\n\t                runtime.log(\"slight problem: \" + String(l))\n\t            }\n\t        else\n\t            m = q(b),\n\t            e(m)\n\t    }\n\t    function l(a) {\n\t        var c = a.ownerDocument;\n\t        N.getElementsByTagNameNS(a, I, \"line-break\").forEach(function(a) {\n\t            a.hasChildNodes() || a.appendChild(c.createElement(\"br\"))\n\t        })\n\t    }\n\t    function a(a) {\n\t        var c = a.ownerDocument;\n\t        N.getElementsByTagNameNS(a, I, \"s\").forEach(function(a) {\n\t            var b, d;\n\t            N.removeAllChildNodes(a);\n\t            a.appendChild(c.createTextNode(\" \"));\n\t            d = parseInt(a.getAttributeNS(I, \"c\"), 10);\n\t            if (1 < d)\n\t                for (a.removeAttributeNS(I, \"c\"),\n\t                b = 1; b < d; b += 1)\n\t                    a.parentNode.insertBefore(a.cloneNode(!0), a)\n\t        })\n\t    }\n\t    function c(a) {\n\t        N.getElementsByTagNameNS(a, I, \"tab\").forEach(function(a) {\n\t            a.textContent = \"\\t\"\n\t        })\n\t    }\n\t    function m(a, c) {\n\t        function b(a, d) {\n\t            var m = f.documentElement.namespaceURI;\n\t            \"video/\" === d.substr(0, 6) ? (e = f.createElementNS(m, \"video\"),\n\t            e.setAttribute(\"controls\", \"controls\"),\n\t            h = f.createElementNS(m, \"source\"),\n\t            a && h.setAttribute(\"src\", a),\n\t            h.setAttribute(\"type\", d),\n\t            e.appendChild(h),\n\t            c.parentNode.appendChild(e)) : c.innerHtml = \"Unrecognised Plugin\"\n\t        }\n\t        function d(a) {\n\t            b(a.url, a.mimetype)\n\t        }\n\t        var e, h, m, f = c.ownerDocument, l;\n\t        if (m = c.getAttributeNS(K, \"href\"))\n\t            try {\n\t                l = a.getPart(m),\n\t                l.onchange = d,\n\t                l.load()\n\t            } catch (n) {\n\t                runtime.log(\"slight problem: \" + String(n))\n\t            }\n\t        else\n\t            runtime.log(\"using MP4 data fallback\"),\n\t            m = q(c),\n\t            b(m, \"video/mp4\")\n\t    }\n\t    function h(a) {\n\t        var c = a.getElementsByTagName(\"head\")[0], b, d;\n\t        b = a.styleSheets.length;\n\t        for (d = c.firstElementChild; d && (\"style\" !== d.localName || !d.hasAttribute(\"webodfcss\")); )\n\t            d = d.nextElementSibling;\n\t        if (d)\n\t            return b = parseInt(d.getAttribute(\"webodfcss\"), 10),\n\t            d.setAttribute(\"webodfcss\", b + 1),\n\t            d;\n\t        \"string\" === String(typeof webodf_css) ? b = webodf_css : (d = \"webodf.css\",\n\t        runtime.currentDirectory && (d = runtime.currentDirectory(),\n\t        0 < d.length && \"/\" !== d.substr(-1) && (d += \"/\"),\n\t        d += \"../webodf.css\"),\n\t        b = runtime.readFileSync(d, \"utf-8\"));\n\t        d = a.createElementNS(c.namespaceURI, \"style\");\n\t        d.setAttribute(\"media\", \"screen, print, handheld, projection\");\n\t        d.setAttribute(\"type\", \"text/css\");\n\t        d.setAttribute(\"webodfcss\", \"1\");\n\t        d.appendChild(a.createTextNode(b));\n\t        c.appendChild(d);\n\t        return d\n\t    }\n\t    function y(a) {\n\t        var c = parseInt(a.getAttribute(\"webodfcss\"), 10);\n\t        1 === c ? a.parentNode.removeChild(a) : a.setAttribute(\"count\", c - 1)\n\t    }\n\t    function x(a) {\n\t        var c = a.getElementsByTagName(\"head\")[0]\n\t          , b = a.createElementNS(c.namespaceURI, \"style\")\n\t          , d = \"\";\n\t        b.setAttribute(\"type\", \"text/css\");\n\t        b.setAttribute(\"media\", \"screen, print, handheld, projection\");\n\t        odf.Namespaces.forEachPrefix(function(a, c) {\n\t            d += \"@namespace \" + a + \" url(\" + c + \");\\n\"\n\t        });\n\t        d += \"@namespace webodfhelper url(urn:webodf:names:helper);\\n\";\n\t        b.appendChild(a.createTextNode(d));\n\t        c.appendChild(b);\n\t        return b\n\t    }\n\t    var z = odf.Namespaces.drawns\n\t      , w = odf.Namespaces.fons\n\t      , v = odf.Namespaces.officens\n\t      , u = odf.Namespaces.stylens\n\t      , t = odf.Namespaces.svgns\n\t      , A = odf.Namespaces.tablens\n\t      , I = odf.Namespaces.textns\n\t      , K = odf.Namespaces.xlinkns\n\t      , L = odf.Namespaces.presentationns\n\t      , E = xmldom.XPath\n\t      , N = core.DomUtils;\n\t    odf.OdfCanvas = function(q, D) {\n\t        function t(a, c, b) {\n\t            function d(a, c, b, h) {\n\t                na.addToQueue(function() {\n\t                    e(a, c, b, h)\n\t                })\n\t            }\n\t            var h, m;\n\t            h = c.getElementsByTagNameNS(z, \"image\");\n\t            for (c = 0; c < h.length; c += 1)\n\t                m = h.item(c),\n\t                d(\"image\" + String(c), a, m, b)\n\t        }\n\t        function W(a, c) {\n\t            function b(a, c) {\n\t                na.addToQueue(function() {\n\t                    m(a, c)\n\t                })\n\t            }\n\t            var d, e, h;\n\t            e = c.getElementsByTagNameNS(z, \"plugin\");\n\t            for (d = 0; d < e.length; d += 1)\n\t                h = e.item(d),\n\t                b(a, h)\n\t        }\n\t        function w() {\n\t            var a;\n\t            a = U.firstChild;\n\t            var c = ea.getZoomLevel();\n\t            a && (U.style.WebkitTransformOrigin = \"0% 0%\",\n\t            U.style.MozTransformOrigin = \"0% 0%\",\n\t            U.style.msTransformOrigin = \"0% 0%\",\n\t            U.style.OTransformOrigin = \"0% 0%\",\n\t            U.style.transformOrigin = \"0% 0%\",\n\t            M && ((a = M.getMinimumHeightForAnnotationPane()) ? U.style.minHeight = a : U.style.removeProperty(\"min-height\")),\n\t            q.style.width = Math.round(c * U.offsetWidth) + \"px\",\n\t            q.style.height = Math.round(c * U.offsetHeight) + \"px\",\n\t            q.style.display = \"inline-block\")\n\t        }\n\t        function K(b, d) {\n\t            var e = ca.sheet;\n\t            N.removeAllChildNodes(q);\n\t            U = ha.createElementNS(q.namespaceURI, \"div\");\n\t            U.style.display = \"inline-block\";\n\t            U.style.background = \"white\";\n\t            U.style.setProperty(\"float\", \"left\", \"important\");\n\t            U.appendChild(d);\n\t            q.appendChild(U);\n\t            ga = ha.createElementNS(q.namespaceURI, \"div\");\n\t            ga.id = \"annotationsPane\";\n\t            X = ha.createElementNS(q.namespaceURI, \"div\");\n\t            X.id = \"shadowContent\";\n\t            X.style.position = \"absolute\";\n\t            X.style.top = 0;\n\t            X.style.left = 0;\n\t            b.getContentElement().appendChild(X);\n\t            var h = d.body, m, f = [], g;\n\t            for (m = h.firstElementChild; m && m !== h; )\n\t                if (m.namespaceURI === z && (f[f.length] = m),\n\t                m.firstElementChild)\n\t                    m = m.firstElementChild;\n\t                else {\n\t                    for (; m && m !== h && !m.nextElementSibling; )\n\t                        m = m.parentNode;\n\t                    m && m.nextElementSibling && (m = m.nextElementSibling)\n\t                }\n\t            for (g = 0; g < f.length; g += 1)\n\t                m = f[g],\n\t                r(\"frame\" + String(g), m, e);\n\t            f = E.getODFElementsWithXPath(h, \".//*[*[@text:anchor-type='paragraph']]\", odf.Namespaces.lookupNamespaceURI);\n\t            for (m = 0; m < f.length; m += 1)\n\t                h = f[m],\n\t                h.setAttributeNS && h.setAttributeNS(\"urn:webodf:names:helper\", \"containsparagraphanchor\", !0);\n\t            h = Z;\n\t            m = X;\n\t            var k, D, y, x, w = 0, J;\n\t            g = b.rootElement.ownerDocument;\n\t            if ((f = d.body.firstElementChild) && f.namespaceURI === v && (\"presentation\" === f.localName || \"drawing\" === f.localName))\n\t                for (f = f.firstElementChild; f; ) {\n\t                    if (k = (k = f.getAttributeNS(z, \"master-page-name\")) ? h.getMasterPageElement(k) : null) {\n\t                        D = f.getAttributeNS(\"urn:webodf:names:helper\", \"styleid\");\n\t                        y = g.createElementNS(z, \"draw:page\");\n\t                        J = k.firstElementChild;\n\t                        for (w = 0; J; )\n\t                            \"true\" !== J.getAttributeNS(L, \"placeholder\") && (x = J.cloneNode(!0),\n\t                            y.appendChild(x)),\n\t                            J = J.nextElementSibling,\n\t                            w += 1;\n\t                        J = x = w = void 0;\n\t                        for (var B = N.getElementsByTagNameNS(y, z, \"frame\"), w = 0; w < B.length; w += 1)\n\t                            x = B[w],\n\t                            (J = x.getAttributeNS(L, \"class\")) && !/^(date-time|footer|header|page-number)$/.test(J) && x.parentNode.removeChild(x);\n\t                        x = N.getElementsByTagNameNS(y, z, \"*\");\n\t                        for (w = 0; w < x.length; w += 1)\n\t                            r(D + \"_\" + w, x[w], e);\n\t                        m.appendChild(y);\n\t                        w = String(m.getElementsByTagNameNS(z, \"page\").length);\n\t                        p(y, I, \"page-number\", w);\n\t                        p(y, L, \"header\", n(b, f, \"header\"));\n\t                        p(y, L, \"footer\", n(b, f, \"footer\"));\n\t                        r(D, y, e);\n\t                        y.setAttributeNS(\"urn:webodf:names:helper\", \"page-style-name\", f.getAttributeNS(z, \"style-name\"));\n\t                        y.setAttributeNS(z, \"draw:master-page-name\", k.getAttributeNS(u, \"name\"))\n\t                    }\n\t                    f = f.nextElementSibling\n\t                }\n\t            h = q.namespaceURI;\n\t            f = N.getElementsByTagNameNS(d.body, A, \"table-cell\");\n\t            for (m = 0; m < f.length; m += 1)\n\t                g = f[m],\n\t                g.hasAttributeNS(A, \"number-columns-spanned\") && g.setAttributeNS(h, \"colspan\", g.getAttributeNS(A, \"number-columns-spanned\")),\n\t                g.hasAttributeNS(A, \"number-rows-spanned\") && g.setAttributeNS(h, \"rowspan\", g.getAttributeNS(A, \"number-rows-spanned\"));\n\t            l(d.body);\n\t            a(d.body);\n\t            c(d.body);\n\t            t(b, d.body, e);\n\t            W(b, d.body);\n\t            U.insertBefore(X, U.firstChild);\n\t            ea.setZoomableElement(U)\n\t        }\n\t        function P(a) {\n\t            B ? (ga.parentNode || U.appendChild(ga),\n\t            M && M.forgetAnnotations(),\n\t            M = new gui.AnnotationViewManager(fa,a.body,ga,Y),\n\t            a = N.getElementsByTagNameNS(a.body, v, \"annotation\"),\n\t            M.addAnnotations(a),\n\t            w()) : ga.parentNode && (U.removeChild(ga),\n\t            M.forgetAnnotations(),\n\t            w())\n\t        }\n\t        function aa(a) {\n\t            function c() {\n\t                d(F);\n\t                d(ja);\n\t                d(ca);\n\t                N.removeAllChildNodes(q);\n\t                q.style.display = \"inline-block\";\n\t                var e = C.rootElement;\n\t                q.ownerDocument.importNode(e, !0);\n\t                Z.setOdfContainer(C);\n\t                f(C, F);\n\t                b(C, Z, ja);\n\t                K(C, e);\n\t                P(e);\n\t                a || na.addToQueue(function() {\n\t                    var a = [C];\n\t                    if (da.hasOwnProperty(\"statereadychange\")) {\n\t                        var c = da.statereadychange, b;\n\t                        for (b = 0; b < c.length; b += 1)\n\t                            c[b].apply(null, a)\n\t                    }\n\t                })\n\t            }\n\t            C.state === odf.OdfContainer.DONE ? c() : (runtime.log(\"WARNING: refreshOdf called but ODF was not DONE.\"),\n\t            qa = runtime.setTimeout(function T() {\n\t                C.state === odf.OdfContainer.DONE ? c() : (runtime.log(\"will be back later...\"),\n\t                qa = runtime.setTimeout(T, 500))\n\t            }, 100))\n\t        }\n\t        function S(a) {\n\t            na.clearQueue();\n\t            N.removeAllChildNodes(q);\n\t            q.appendChild(q.ownerDocument.createTextNode(runtime.tr(\"Loading\") + a + \"...\"));\n\t            q.removeAttribute(\"style\");\n\t            C = new odf.OdfContainer(a,function(a) {\n\t                C = a;\n\t                aa(!1)\n\t            }\n\t            )\n\t        }\n\t        runtime.assert(null !== q && void 0 !== q, \"odf.OdfCanvas constructor needs DOM element\");\n\t        runtime.assert(null !== q.ownerDocument && void 0 !== q.ownerDocument, \"odf.OdfCanvas constructor needs DOM\");\n\t        var fa = this, ha = q.ownerDocument, C, Z = new odf.Formatting, ba, U = null, ga = null, B = !1, Y = !1, M = null, Q, F, ja, ca, X, da = {}, qa, la, ia = !1, ma = !1, na = new g, ea = new gui.ZoomHelper, ka = D || new gui.SingleScrollViewport(q.parentNode);\n\t        this.refreshCSS = function() {\n\t            ia = !0;\n\t            la.trigger()\n\t        }\n\t        ;\n\t        this.refreshSize = function() {\n\t            la.trigger()\n\t        }\n\t        ;\n\t        this.odfContainer = function() {\n\t            return C\n\t        }\n\t        ;\n\t        this.setOdfContainer = function(a, c) {\n\t            C = a;\n\t            aa(!0 === c)\n\t        }\n\t        ;\n\t        this.load = this.load = S;\n\t        this.save = function(a) {\n\t            C.save(a)\n\t        }\n\t        ;\n\t        this.addListener = function(a, c) {\n\t            switch (a) {\n\t            case \"click\":\n\t                var b = a;\n\t                q.addEventListener ? q.addEventListener(b, c, !1) : q.attachEvent ? q.attachEvent(\"on\" + b, c) : q[\"on\" + b] = c;\n\t                break;\n\t            default:\n\t                b = da.hasOwnProperty(a) ? da[a] : da[a] = [],\n\t                c && -1 === b.indexOf(c) && b.push(c)\n\t            }\n\t        }\n\t        ;\n\t        this.getFormatting = function() {\n\t            return Z\n\t        }\n\t        ;\n\t        this.getAnnotationViewManager = function() {\n\t            return M\n\t        }\n\t        ;\n\t        this.refreshAnnotations = function() {\n\t            P(C.rootElement)\n\t        }\n\t        ;\n\t        this.rerenderAnnotations = function() {\n\t            M && (ma = !0,\n\t            la.trigger())\n\t        }\n\t        ;\n\t        this.getSizer = function() {\n\t            return U\n\t        }\n\t        ;\n\t        this.enableAnnotations = function(a, c) {\n\t            a !== B && (B = a,\n\t            Y = c,\n\t            C && P(C.rootElement))\n\t        }\n\t        ;\n\t        this.addAnnotation = function(a) {\n\t            M && (M.addAnnotations([a]),\n\t            w())\n\t        }\n\t        ;\n\t        this.forgetAnnotation = function(a) {\n\t            M && (M.forgetAnnotation(a),\n\t            w())\n\t        }\n\t        ;\n\t        this.getZoomHelper = function() {\n\t            return ea\n\t        }\n\t        ;\n\t        this.setZoomLevel = function(a) {\n\t            ea.setZoomLevel(a)\n\t        }\n\t        ;\n\t        this.getZoomLevel = function() {\n\t            return ea.getZoomLevel()\n\t        }\n\t        ;\n\t        this.fitToContainingElement = function(a, c) {\n\t            var b = ea.getZoomLevel()\n\t              , d = q.offsetHeight / b\n\t              , b = a / (q.offsetWidth / b);\n\t            c / d < b && (b = c / d);\n\t            ea.setZoomLevel(b)\n\t        }\n\t        ;\n\t        this.fitToWidth = function(a) {\n\t            var c = q.offsetWidth / ea.getZoomLevel();\n\t            ea.setZoomLevel(a / c)\n\t        }\n\t        ;\n\t        this.fitSmart = function(a, c) {\n\t            var b, d;\n\t            d = ea.getZoomLevel();\n\t            b = q.offsetWidth / d;\n\t            d = q.offsetHeight / d;\n\t            b = a / b;\n\t            void 0 !== c && c / d < b && (b = c / d);\n\t            ea.setZoomLevel(Math.min(1, b))\n\t        }\n\t        ;\n\t        this.fitToHeight = function(a) {\n\t            var c = q.offsetHeight / ea.getZoomLevel();\n\t            ea.setZoomLevel(a / c)\n\t        }\n\t        ;\n\t        this.showFirstPage = function() {\n\t            ba.showFirstPage()\n\t        }\n\t        ;\n\t        this.showNextPage = function() {\n\t            ba.showNextPage()\n\t        }\n\t        ;\n\t        this.showPreviousPage = function() {\n\t            ba.showPreviousPage()\n\t        }\n\t        ;\n\t        this.showPage = function(a) {\n\t            ba.showPage(a);\n\t            w()\n\t        }\n\t        ;\n\t        this.getElement = function() {\n\t            return q\n\t        }\n\t        ;\n\t        this.getViewport = function() {\n\t            return ka\n\t        }\n\t        ;\n\t        this.addCssForFrameWithImage = function(a) {\n\t            var c = a.getAttributeNS(z, \"name\")\n\t              , b = a.firstElementChild;\n\t            r(c, a, ca.sheet);\n\t            b && e(c + \"img\", C, b, ca.sheet)\n\t        }\n\t        ;\n\t        this.destroy = function(a) {\n\t            var c = ha.getElementsByTagName(\"head\")[0]\n\t              , b = [ba.destroy, la.destroy];\n\t            runtime.clearTimeout(qa);\n\t            ga && ga.parentNode && ga.parentNode.removeChild(ga);\n\t            ea.destroy(function() {\n\t                U && (q.removeChild(U),\n\t                U = null)\n\t            });\n\t            y(Q);\n\t            c.removeChild(F);\n\t            c.removeChild(ja);\n\t            c.removeChild(ca);\n\t            core.Async.destroyAll(b, a)\n\t        }\n\t        ;\n\t        Q = h(ha);\n\t        ba = new k(x(ha));\n\t        F = x(ha);\n\t        ja = x(ha);\n\t        ca = x(ha);\n\t        la = core.Task.createRedrawTask(function() {\n\t            ia && (b(C, Z, ja),\n\t            ia = !1);\n\t            ma && (M && M.rerenderAnnotations(),\n\t            ma = !1);\n\t            w()\n\t        });\n\t        ea.subscribe(gui.ZoomHelper.signalZoomChanged, w)\n\t    }\n\t}\n\t)();\n\todf.StepUtils = function() {\n\t    this.getContentBounds = function(g) {\n\t        var k = g.container(), d, b;\n\t        runtime.assert(g.isStep(), \"Step iterator must be on a step\");\n\t        k.nodeType === Node.TEXT_NODE && 0 < g.offset() ? d = g.offset() : (k = g.leftNode()) && k.nodeType === Node.TEXT_NODE && (d = k.length);\n\t        k && (k.nodeType === Node.TEXT_NODE ? (runtime.assert(0 < d, \"Empty text node found\"),\n\t        b = {\n\t            container: k,\n\t            startOffset: d - 1,\n\t            endOffset: d\n\t        }) : b = {\n\t            container: k,\n\t            startOffset: 0,\n\t            endOffset: k.childNodes.length\n\t        });\n\t        return b\n\t    }\n\t}\n\t;\n\tops.MemberProperties = function() {}\n\t;\n\tops.Member = function(g, k) {\n\t    var d = new ops.MemberProperties;\n\t    this.getMemberId = function() {\n\t        return g\n\t    }\n\t    ;\n\t    this.getProperties = function() {\n\t        return d\n\t    }\n\t    ;\n\t    this.setProperties = function(b) {\n\t        Object.keys(b).forEach(function(f) {\n\t            d[f] = b[f]\n\t        })\n\t    }\n\t    ;\n\t    this.removeProperties = function(b) {\n\t        Object.keys(b).forEach(function(b) {\n\t            \"fullName\" !== b && \"color\" !== b && \"imageUrl\" !== b && d.hasOwnProperty(b) && delete d[b]\n\t        })\n\t    }\n\t    ;\n\t    runtime.assert(Boolean(g), \"No memberId was supplied!\");\n\t    k.fullName || (k.fullName = runtime.tr(\"Unknown Author\"));\n\t    k.color || (k.color = \"black\");\n\t    k.imageUrl || (k.imageUrl = \"avatar-joe.png\");\n\t    d = k\n\t}\n\t;\n\tops.Document = function() {}\n\t;\n\tops.Document.prototype.getMemberIds = function() {}\n\t;\n\tops.Document.prototype.removeCursor = function(g) {}\n\t;\n\tops.Document.prototype.getDocumentElement = function() {}\n\t;\n\tops.Document.prototype.getRootNode = function() {}\n\t;\n\tops.Document.prototype.getDOMDocument = function() {}\n\t;\n\tops.Document.prototype.cloneDocumentElement = function() {}\n\t;\n\tops.Document.prototype.setDocumentElement = function(g) {}\n\t;\n\tops.Document.prototype.subscribe = function(g, k) {}\n\t;\n\tops.Document.prototype.unsubscribe = function(g, k) {}\n\t;\n\tops.Document.prototype.getCanvas = function() {}\n\t;\n\tops.Document.prototype.createRootFilter = function(g) {}\n\t;\n\tops.Document.prototype.createPositionIterator = function(g) {}\n\t;\n\tops.Document.prototype.hasCursor = function(g) {}\n\t;\n\tops.Document.signalCursorAdded = \"cursor/added\";\n\tops.Document.signalCursorRemoved = \"cursor/removed\";\n\tops.Document.signalCursorMoved = \"cursor/moved\";\n\tops.Document.signalMemberAdded = \"member/added\";\n\tops.Document.signalMemberUpdated = \"member/updated\";\n\tops.Document.signalMemberRemoved = \"member/removed\";\n\tops.OdtCursor = function(g, k) {\n\t    var d = this, b = {}, f, n, p = new core.EventNotifier([ops.OdtCursor.signalCursorUpdated]);\n\t    this.removeFromDocument = function() {\n\t        n.remove()\n\t    }\n\t    ;\n\t    this.subscribe = function(b, d) {\n\t        p.subscribe(b, d)\n\t    }\n\t    ;\n\t    this.unsubscribe = function(b, d) {\n\t        p.unsubscribe(b, d)\n\t    }\n\t    ;\n\t    this.getMemberId = function() {\n\t        return g\n\t    }\n\t    ;\n\t    this.getNode = function() {\n\t        return n.getNode()\n\t    }\n\t    ;\n\t    this.getAnchorNode = function() {\n\t        return n.getAnchorNode()\n\t    }\n\t    ;\n\t    this.getSelectedRange = function() {\n\t        return n.getSelectedRange()\n\t    }\n\t    ;\n\t    this.setSelectedRange = function(b, f) {\n\t        n.setSelectedRange(b, f);\n\t        p.emit(ops.OdtCursor.signalCursorUpdated, d)\n\t    }\n\t    ;\n\t    this.hasForwardSelection = function() {\n\t        return n.hasForwardSelection()\n\t    }\n\t    ;\n\t    this.getDocument = function() {\n\t        return k\n\t    }\n\t    ;\n\t    this.getSelectionType = function() {\n\t        return f\n\t    }\n\t    ;\n\t    this.setSelectionType = function(d) {\n\t        b.hasOwnProperty(d) ? f = d : runtime.log(\"Invalid selection type: \" + d)\n\t    }\n\t    ;\n\t    this.resetSelectionType = function() {\n\t        d.setSelectionType(ops.OdtCursor.RangeSelection)\n\t    }\n\t    ;\n\t    n = new core.Cursor(k.getDOMDocument(),g);\n\t    b[ops.OdtCursor.RangeSelection] = !0;\n\t    b[ops.OdtCursor.RegionSelection] = !0;\n\t    d.resetSelectionType()\n\t}\n\t;\n\tops.OdtCursor.RangeSelection = \"Range\";\n\tops.OdtCursor.RegionSelection = \"Region\";\n\tops.OdtCursor.signalCursorUpdated = \"cursorUpdated\";\n\t(function() {\n\t    var g = 0;\n\t    ops.StepsCache = function(k, d, b) {\n\t        function f(a, c) {\n\t            var d = this;\n\t            this.nodeId = a;\n\t            this.steps = -1;\n\t            this.node = c;\n\t            this.previousBookmark = this.nextBookmark = null;\n\t            this.setIteratorPosition = function(a) {\n\t                a.setPositionBeforeElement(c);\n\t                b(d.steps, a)\n\t            }\n\t        }\n\t        function n(a, c, d) {\n\t            var e = this;\n\t            this.nodeId = a;\n\t            this.steps = c;\n\t            this.node = d;\n\t            this.previousBookmark = this.nextBookmark = null;\n\t            this.setIteratorPosition = function(a) {\n\t                a.setUnfilteredPosition(d, 0);\n\t                b(e.steps, a)\n\t            }\n\t        }\n\t        function p(a, c) {\n\t            var b = \"[\" + a.nodeId;\n\t            c && (b += \" => \" + c.nodeId);\n\t            return b + \"]\"\n\t        }\n\t        function r() {\n\t            if (!0 === ops.StepsCache.ENABLE_CACHE_VERIFICATION) {\n\t                for (var a = x, c, b, d, e = new core.LoopWatchDog(0,1E5), h = {}; a; ) {\n\t                    e.check();\n\t                    (c = a.previousBookmark) ? runtime.assert(c.nextBookmark === a, \"Broken bookmark link to previous @\" + p(c, a)) : (runtime.assert(a === x, \"Broken bookmark link @\" + p(a)),\n\t                    runtime.assert(void 0 === z || x === x || x.steps <= z, \"Base point is damaged @\" + p(a)));\n\t                    (b = a.nextBookmark) && runtime.assert(b.previousBookmark === a, \"Broken bookmark link to next @\" + p(a, b));\n\t                    if (void 0 === z || a === x || a.steps <= z)\n\t                        runtime.assert(y.containsNode(k, a.node), \"Disconnected node is being reported as undamaged @\" + p(a)),\n\t                        c && (d = a.node.compareDocumentPosition(c.node),\n\t                        runtime.assert(0 === d || 0 !== (d & v), \"Bookmark order with previous does not reflect DOM order @\" + p(c, a))),\n\t                        b && y.containsNode(k, b.node) && (d = a.node.compareDocumentPosition(b.node),\n\t                        runtime.assert(0 === d || 0 !== (d & w), \"Bookmark order with next does not reflect DOM order @\" + p(a, b)));\n\t                    a = a.nextBookmark\n\t                }\n\t                Object.keys(m).forEach(function(a) {\n\t                    var c = m[a];\n\t                    (void 0 === z || a <= z) && runtime.assert(c.steps <= a, \"Bookmark step of \" + c.steps + \" exceeds cached step lookup for \" + a + \" @\" + p(c));\n\t                    runtime.assert(!1 === h.hasOwnProperty(c.nodeId), \"Bookmark \" + p(c) + \" appears twice in cached step lookup at steps \" + h[c.nodeId] + \" and \" + a);\n\t                    h[c.nodeId] = a\n\t                })\n\t            }\n\t        }\n\t        function q(a) {\n\t            var c = \"\";\n\t            a.nodeType === Node.ELEMENT_NODE && (c = a.getAttributeNS(\"urn:webodf:names:steps\", \"nodeId\") || \"\");\n\t            return c\n\t        }\n\t        function e(a) {\n\t            var c = g.toString();\n\t            a.setAttributeNS(\"urn:webodf:names:steps\", \"nodeId\", c);\n\t            g += 1;\n\t            return c\n\t        }\n\t        function l(a) {\n\t            var c, b, e = new core.LoopWatchDog(0,1E4);\n\t            void 0 !== z && a > z && (a = z);\n\t            for (c = Math.floor(a / d) * d; !b && 0 <= c; )\n\t                b = m[c],\n\t                c -= d;\n\t            for (b = b || x; b.nextBookmark && b.nextBookmark.steps <= a; )\n\t                e.check(),\n\t                b = b.nextBookmark;\n\t            runtime.assert(-1 === a || b.steps <= a, \"Bookmark @\" + p(b) + \" at step \" + b.steps + \" exceeds requested step of \" + a);\n\t            return b\n\t        }\n\t        function a(a) {\n\t            a.previousBookmark && (a.previousBookmark.nextBookmark = a.nextBookmark);\n\t            a.nextBookmark && (a.nextBookmark.previousBookmark = a.previousBookmark)\n\t        }\n\t        function c(a) {\n\t            for (var c, b = null; !b && a && a !== k; )\n\t                (c = q(a)) && (b = h[c]) && b.node !== a && (runtime.log(\"Cloned node detected. Creating new bookmark\"),\n\t                b = null,\n\t                a.removeAttributeNS(\"urn:webodf:names:steps\", \"nodeId\")),\n\t                a = a.parentNode;\n\t            return b\n\t        }\n\t        var m = {}, h = {}, y = core.DomUtils, x, z, w = Node.DOCUMENT_POSITION_FOLLOWING, v = Node.DOCUMENT_POSITION_PRECEDING;\n\t        this.updateBookmark = function(c, b) {\n\t            var g, n = Math.ceil(c / d) * d, p, v, E;\n\t            if (void 0 !== z && z < c) {\n\t                p = l(z);\n\t                for (v = p.nextBookmark; v && v.steps <= c; )\n\t                    g = v.nextBookmark,\n\t                    E = Math.ceil(v.steps / d) * d,\n\t                    m[E] === v && delete m[E],\n\t                    y.containsNode(k, v.node) ? v.steps = c + 1 : (a(v),\n\t                    delete h[v.nodeId]),\n\t                    v = g;\n\t                z = c\n\t            } else\n\t                p = l(c);\n\t            v = q(b) || e(b);\n\t            g = h[v];\n\t            g ? g.node !== b && (runtime.log(\"Cloned node detected. Creating new bookmark\"),\n\t            v = e(b),\n\t            g = h[v] = new f(v,b)) : g = h[v] = new f(v,b);\n\t            v = g;\n\t            v.steps !== c && (g = Math.ceil(v.steps / d) * d,\n\t            g !== n && m[g] === v && delete m[g],\n\t            v.steps = c);\n\t            if (p !== v && p.nextBookmark !== v) {\n\t                if (p.steps === v.steps)\n\t                    for (; 0 !== (v.node.compareDocumentPosition(p.node) & w) && p !== x; )\n\t                        p = p.previousBookmark;\n\t                p !== v && p.nextBookmark !== v && (a(v),\n\t                g = p.nextBookmark,\n\t                v.nextBookmark = p.nextBookmark,\n\t                v.previousBookmark = p,\n\t                p.nextBookmark = v,\n\t                g && (g.previousBookmark = v))\n\t            }\n\t            p = m[n];\n\t            if (!p || v.steps > p.steps)\n\t                m[n] = v;\n\t            r()\n\t        }\n\t        ;\n\t        this.setToClosestStep = function(a, c) {\n\t            var b;\n\t            r();\n\t            b = l(a);\n\t            b.setIteratorPosition(c);\n\t            return b.steps\n\t        }\n\t        ;\n\t        this.setToClosestDomPoint = function(a, b, d) {\n\t            var e, h;\n\t            r();\n\t            if (a === k && 0 === b)\n\t                e = x;\n\t            else if (a === k && b === k.childNodes.length)\n\t                for (h in e = x,\n\t                m)\n\t                    m.hasOwnProperty(h) && (a = m[h],\n\t                    a.steps > e.steps && (e = a));\n\t            else if (e = c(a.childNodes.item(b) || a),\n\t            !e)\n\t                for (d.setUnfilteredPosition(a, b); !e && d.previousNode(); )\n\t                    e = c(d.getCurrentNode());\n\t            e = e || x;\n\t            void 0 !== z && e.steps > z && (e = l(z));\n\t            e.setIteratorPosition(d);\n\t            return e.steps\n\t        }\n\t        ;\n\t        this.damageCacheAfterStep = function(a) {\n\t            0 > a && (a = -1);\n\t            void 0 === z ? z = a : a < z && (z = a);\n\t            r()\n\t        }\n\t        ;\n\t        (function() {\n\t            var a = q(k) || e(k);\n\t            x = new n(a,0,k)\n\t        }\n\t        )()\n\t    }\n\t    ;\n\t    ops.StepsCache.ENABLE_CACHE_VERIFICATION = !1;\n\t    ops.StepsCache.Bookmark = function() {}\n\t    ;\n\t    ops.StepsCache.Bookmark.prototype.setIteratorPosition = function(g) {}\n\t}\n\t)();\n\t(function() {\n\t    ops.OdtStepsTranslator = function(g, k, d, b) {\n\t        function f(a, b, d) {\n\t            var e = b.getCurrentNode();\n\t            b.isBeforeNode() && r.isParagraph(e) && (d || (a += 1),\n\t            p.updateBookmark(a, e))\n\t        }\n\t        function n(c, b) {\n\t            if (!b || d.acceptPosition(c) === e)\n\t                return !0;\n\t            for (; c.previousPosition(); )\n\t                if (d.acceptPosition(c) === e) {\n\t                    if (b(l, c.container(), c.unfilteredDomOffset()))\n\t                        return !0;\n\t                    break\n\t                }\n\t            for (; c.nextPosition(); )\n\t                if (d.acceptPosition(c) === e) {\n\t                    if (b(a, c.container(), c.unfilteredDomOffset()))\n\t                        return !0;\n\t                    break\n\t                }\n\t            return !1\n\t        }\n\t        var p, r = odf.OdfUtils, q = core.DomUtils, e = core.PositionFilter.FilterResult.FILTER_ACCEPT, l = core.StepDirection.PREVIOUS, a = core.StepDirection.NEXT;\n\t        this.convertStepsToDomPoint = function(a) {\n\t            var b, h;\n\t            if (isNaN(a))\n\t                throw new TypeError(\"Requested steps is not numeric (\" + a + \")\");\n\t            if (0 > a)\n\t                throw new RangeError(\"Requested steps is negative (\" + a + \")\");\n\t            for (b = p.setToClosestStep(a, k); b < a && k.nextPosition(); )\n\t                (h = d.acceptPosition(k) === e) && (b += 1),\n\t                f(b, k, h);\n\t            if (b !== a)\n\t                throw new RangeError(\"Requested steps (\" + a + \") exceeds available steps (\" + b + \")\");\n\t            return {\n\t                node: k.container(),\n\t                offset: k.unfilteredDomOffset()\n\t            }\n\t        }\n\t        ;\n\t        this.convertDomPointToSteps = function(a, b, h) {\n\t            var l;\n\t            q.containsNode(g, a) || (b = 0 > q.comparePoints(g, 0, a, b),\n\t            a = g,\n\t            b = b ? 0 : g.childNodes.length);\n\t            k.setUnfilteredPosition(a, b);\n\t            n(k, h) || k.setUnfilteredPosition(a, b);\n\t            h = k.container();\n\t            b = k.unfilteredDomOffset();\n\t            a = p.setToClosestDomPoint(h, b, k);\n\t            if (0 > q.comparePoints(k.container(), k.unfilteredDomOffset(), h, b))\n\t                return 0 < a ? a - 1 : a;\n\t            for (; (k.container() !== h || k.unfilteredDomOffset() !== b) && k.nextPosition(); )\n\t                (l = d.acceptPosition(k) === e) && (a += 1),\n\t                f(a, k, l);\n\t            return a + 0\n\t        }\n\t        ;\n\t        this.prime = function() {\n\t            var a, b;\n\t            for (a = p.setToClosestStep(0, k); k.nextPosition(); )\n\t                (b = d.acceptPosition(k) === e) && (a += 1),\n\t                f(a, k, b)\n\t        }\n\t        ;\n\t        this.handleStepsInserted = function(a) {\n\t            p.damageCacheAfterStep(a.position)\n\t        }\n\t        ;\n\t        this.handleStepsRemoved = function(a) {\n\t            p.damageCacheAfterStep(a.position - 1)\n\t        }\n\t        ;\n\t        p = new ops.StepsCache(g,b,function(a, b) {\n\t            do {\n\t                if (d.acceptPosition(b) === e) {\n\t                    f(a, b, !0);\n\t                    break\n\t                }\n\t                f(a - 1, b, !1)\n\t            } while (b.nextPosition())\n\t        }\n\t        )\n\t    }\n\t}\n\t)();\n\tops.Operation = function() {}\n\t;\n\tops.Operation.prototype.init = function(g) {}\n\t;\n\tops.Operation.prototype.execute = function(g) {}\n\t;\n\tops.Operation.prototype.spec = function() {}\n\t;\n\tops.TextPositionFilter = function() {\n\t    function g(b, d) {\n\t        for (; b && d(b) !== n; )\n\t            b = b.previousSibling;\n\t        return b\n\t    }\n\t    function k(b, f, e, l) {\n\t        var a;\n\t        if (f) {\n\t            if (d.isInlineRoot(f) && d.isGroupingElement(e))\n\t                return p;\n\t            l = d.lookLeftForCharacter(f);\n\t            if (1 === l || 2 === l && (d.scanRightForAnyCharacter(e) || d.scanRightForAnyCharacter(d.nextNode(b))))\n\t                return n\n\t        } else if (d.isGroupingElement(b) && d.isInlineRoot(g(b.previousSibling, l)))\n\t            return n;\n\t        l = null === f && d.isParagraph(b);\n\t        a = d.lookRightForCharacter(e);\n\t        if (l)\n\t            return a ? n : d.scanRightForAnyCharacter(e) ? p : n;\n\t        if (!a)\n\t            return p;\n\t        f = f || d.previousNode(b);\n\t        return d.scanLeftForAnyCharacter(f) ? p : n\n\t    }\n\t    var d = odf.OdfUtils\n\t      , b = Node.ELEMENT_NODE\n\t      , f = Node.TEXT_NODE\n\t      , n = core.PositionFilter.FilterResult.FILTER_ACCEPT\n\t      , p = core.PositionFilter.FilterResult.FILTER_REJECT;\n\t    this.acceptPosition = function(g) {\n\t        var q = g.container(), e = q.nodeType, l, a, c;\n\t        if (e !== b && e !== f)\n\t            return p;\n\t        if (e === f) {\n\t            e = g.unfilteredDomOffset();\n\t            l = q.data;\n\t            runtime.assert(e !== l.length, \"Unexpected offset.\");\n\t            if (0 < e) {\n\t                g = l[e - 1];\n\t                if (!d.isODFWhitespace(g))\n\t                    return n;\n\t                if (1 < e)\n\t                    if (g = l[e - 2],\n\t                    !d.isODFWhitespace(g))\n\t                        c = n;\n\t                    else {\n\t                        if (!d.isODFWhitespace(l.substr(0, e)))\n\t                            return p\n\t                    }\n\t                else\n\t                    a = d.previousNode(q),\n\t                    d.scanLeftForNonSpace(a) && (c = n);\n\t                if (c === n)\n\t                    return d.isTrailingWhitespace(q, e) ? p : n;\n\t                g = l[e];\n\t                return d.isODFWhitespace(g) ? p : d.scanLeftForAnyCharacter(d.previousNode(q)) ? p : n\n\t            }\n\t            a = g.leftNode();\n\t            c = q;\n\t            q = q.parentNode;\n\t            c = k(q, a, c, g.getNodeFilter())\n\t        } else\n\t            d.isGroupingElement(q) ? (a = g.leftNode(),\n\t            c = g.rightNode(),\n\t            c = k(q, a, c, g.getNodeFilter())) : c = p;\n\t        return c\n\t    }\n\t}\n\t;\n\tfunction RootFilter(g, k, d) {\n\t    var b = core.PositionFilter.FilterResult.FILTER_ACCEPT\n\t      , f = core.PositionFilter.FilterResult.FILTER_REJECT;\n\t    this.acceptPosition = function(n) {\n\t        n = n.container();\n\t        var p;\n\t        p = \"string\" === typeof g ? k[g].getNode() : g;\n\t        return d(n) === d(p) ? b : f\n\t    }\n\t}\n\tops.OdtDocument = function(g) {\n\t    function k(a) {\n\t        return new core.PositionIterator(a,A,L,!1)\n\t    }\n\t    function d() {\n\t        var a = g.odfContainer().getContentElement()\n\t          , c = a && a.localName;\n\t        runtime.assert(\"text\" === c, \"Unsupported content element type '\" + c + \"' for OdtDocument\");\n\t        return a\n\t    }\n\t    function b() {\n\t        return a.getDocumentElement().ownerDocument\n\t    }\n\t    function f(a) {\n\t        for (; a && !(a.namespaceURI === odf.Namespaces.officens && \"text\" === a.localName || a.namespaceURI === odf.Namespaces.officens && \"annotation\" === a.localName); )\n\t            a = a.parentNode;\n\t        return a\n\t    }\n\t    function n(a, c, b, d) {\n\t        d = k(d);\n\t        var e;\n\t        1 === b.length ? e = b[0] : (e = new core.PositionFilterChain,\n\t        b.forEach(e.addFilter));\n\t        b = new core.StepIterator(e,d);\n\t        b.setPosition(a, c);\n\t        return b\n\t    }\n\t    function p(a) {\n\t        var c = k(d());\n\t        a = u.convertStepsToDomPoint(a);\n\t        c.setUnfilteredPosition(a.node, a.offset);\n\t        return c\n\t    }\n\t    function r(a) {\n\t        return a === w\n\t    }\n\t    function q(c) {\n\t        var b = c.spec()\n\t          , d = b.memberid\n\t          , e = (new Date(b.timestamp)).toISOString()\n\t          , b = g.odfContainer();\n\t        c.isEdit && (d = a.getMember(d).getProperties().fullName,\n\t        b.setMetadata({\n\t            \"dc:creator\": d,\n\t            \"dc:date\": e\n\t        }, null),\n\t        d = {\n\t            setProperties: {\n\t                \"dc:creator\": d,\n\t                \"dc:date\": e\n\t            },\n\t            removedProperties: []\n\t        },\n\t        t || (d.setProperties[\"meta:editing-cycles\"] = b.incrementEditingCycles(),\n\t        b.setMetadata(null, [\"meta:editing-duration\", \"meta:document-statistic\"])),\n\t        t = c,\n\t        a.emit(ops.OdtDocument.signalMetadataUpdated, d))\n\t    }\n\t    function e(a) {\n\t        var b, d = [], e, f = 2;\n\t        runtime.assert(a.isStep(), \"positionIterator is not at a step\");\n\t        do {\n\t            if (b = c.getContentBounds(a))\n\t                if (b = b.container,\n\t                m.isDowngradableSpaceElement(b)) {\n\t                    for (e = b.lastChild; b.firstChild; )\n\t                        d.push(b.firstChild),\n\t                        b.parentNode.insertBefore(b.firstChild, b);\n\t                    b.parentNode.removeChild(b);\n\t                    a.setPosition(e, e.nodeType === Node.TEXT_NODE ? e.length : e.childNodes.length);\n\t                    a.roundToPreviousStep()\n\t                }\n\t            --f\n\t        } while (0 < f && a.nextStep());\n\t        d.forEach(h.normalizeTextNodes)\n\t    }\n\t    function l(a, c, b) {\n\t        a = a.childNodes.item(c) || a;\n\t        return (a = m.getParagraphElement(a)) && h.containsNode(b, a) ? a : b\n\t    }\n\t    var a = this, c, m = odf.OdfUtils, h = core.DomUtils, y = {}, x = {}, z = new core.EventNotifier([ops.Document.signalMemberAdded, ops.Document.signalMemberUpdated, ops.Document.signalMemberRemoved, ops.Document.signalCursorAdded, ops.Document.signalCursorRemoved, ops.Document.signalCursorMoved, ops.OdtDocument.signalParagraphChanged, ops.OdtDocument.signalParagraphStyleModified, ops.OdtDocument.signalCommonStyleCreated, ops.OdtDocument.signalCommonStyleDeleted, ops.OdtDocument.signalTableAdded, ops.OdtDocument.signalOperationStart, ops.OdtDocument.signalOperationEnd, ops.OdtDocument.signalProcessingBatchStart, ops.OdtDocument.signalProcessingBatchEnd, ops.OdtDocument.signalUndoStackChanged, ops.OdtDocument.signalStepsInserted, ops.OdtDocument.signalStepsRemoved, ops.OdtDocument.signalMetadataUpdated, ops.OdtDocument.signalAnnotationAdded]), w = core.StepDirection.NEXT, v, u, t, A = NodeFilter.SHOW_ALL, I = new gui.BlacklistNamespaceNodeFilter([\"urn:webodf:names:cursor\", \"urn:webodf:names:editinfo\"]), K = new gui.OdfTextBodyNodeFilter, L = new core.NodeFilterChain([I, K]);\n\t    this.createPositionIterator = k;\n\t    this.getDocumentElement = function() {\n\t        return g.odfContainer().rootElement\n\t    }\n\t    ;\n\t    this.cloneDocumentElement = function() {\n\t        var c = a.getDocumentElement()\n\t          , b = g.getAnnotationViewManager();\n\t        b && b.forgetAnnotations();\n\t        c = c.cloneNode(!0);\n\t        g.refreshAnnotations();\n\t        a.fixCursorPositions();\n\t        return c\n\t    }\n\t    ;\n\t    this.setDocumentElement = function(a) {\n\t        var c = g.odfContainer();\n\t        z.unsubscribe(ops.OdtDocument.signalStepsInserted, u.handleStepsInserted);\n\t        z.unsubscribe(ops.OdtDocument.signalStepsRemoved, u.handleStepsRemoved);\n\t        c.setRootElement(a);\n\t        g.setOdfContainer(c, !0);\n\t        g.refreshCSS();\n\t        a = d();\n\t        u = new ops.OdtStepsTranslator(a,k(a),v,500);\n\t        z.subscribe(ops.OdtDocument.signalStepsInserted, u.handleStepsInserted);\n\t        z.subscribe(ops.OdtDocument.signalStepsRemoved, u.handleStepsRemoved)\n\t    }\n\t    ;\n\t    this.getDOMDocument = b;\n\t    this.getRootElement = f;\n\t    this.createStepIterator = n;\n\t    this.getIteratorAtPosition = p;\n\t    this.convertCursorStepToDomPoint = function(a) {\n\t        return u.convertStepsToDomPoint(a)\n\t    }\n\t    ;\n\t    this.convertDomPointToCursorStep = function(a, c, b) {\n\t        var d;\n\t        b === w && (d = r);\n\t        return u.convertDomPointToSteps(a, c, d)\n\t    }\n\t    ;\n\t    this.convertDomToCursorRange = function(a) {\n\t        var c;\n\t        c = u.convertDomPointToSteps(a.anchorNode, a.anchorOffset);\n\t        a = a.anchorNode === a.focusNode && a.anchorOffset === a.focusOffset ? c : u.convertDomPointToSteps(a.focusNode, a.focusOffset);\n\t        return {\n\t            position: c,\n\t            length: a - c\n\t        }\n\t    }\n\t    ;\n\t    this.convertCursorToDomRange = function(a, c) {\n\t        var d = b().createRange(), e, h;\n\t        e = u.convertStepsToDomPoint(a);\n\t        c ? (h = u.convertStepsToDomPoint(a + c),\n\t        0 < c ? (d.setStart(e.node, e.offset),\n\t        d.setEnd(h.node, h.offset)) : (d.setStart(h.node, h.offset),\n\t        d.setEnd(e.node, e.offset))) : d.setStart(e.node, e.offset);\n\t        return d\n\t    }\n\t    ;\n\t    this.upgradeWhitespacesAtPosition = function(a) {\n\t        var b = p(a), b = new core.StepIterator(v,b), d, e = 2;\n\t        runtime.assert(b.isStep(), \"positionIterator is not at a step (requested step: \" + a + \")\");\n\t        do {\n\t            if (d = c.getContentBounds(b))\n\t                if (a = d.container,\n\t                d = d.startOffset,\n\t                a.nodeType === Node.TEXT_NODE && m.isSignificantWhitespace(a, d)) {\n\t                    runtime.assert(\" \" === a.data[d], \"upgradeWhitespaceToElement: textNode.data[offset] should be a literal space\");\n\t                    var h = a.ownerDocument.createElementNS(odf.Namespaces.textns, \"text:s\")\n\t                      , f = a.parentNode\n\t                      , l = a;\n\t                    h.appendChild(a.ownerDocument.createTextNode(\" \"));\n\t                    1 === a.length ? f.replaceChild(h, a) : (a.deleteData(d, 1),\n\t                    0 < d && (d < a.length && a.splitText(d),\n\t                    l = a.nextSibling),\n\t                    f.insertBefore(h, l));\n\t                    a = h;\n\t                    b.setPosition(a, a.childNodes.length);\n\t                    b.roundToPreviousStep()\n\t                }\n\t            --e\n\t        } while (0 < e && b.nextStep())\n\t    }\n\t    ;\n\t    this.downgradeWhitespaces = e;\n\t    this.downgradeWhitespacesAtPosition = function(a) {\n\t        a = p(a);\n\t        a = new core.StepIterator(v,a);\n\t        e(a)\n\t    }\n\t    ;\n\t    this.getTextNodeAtStep = function(c, d) {\n\t        var e = p(c), h = e.container(), m, f = 0, l = null;\n\t        h.nodeType === Node.TEXT_NODE ? (m = h,\n\t        f = e.unfilteredDomOffset(),\n\t        0 < m.length && (0 < f && (m = m.splitText(f)),\n\t        m.parentNode.insertBefore(b().createTextNode(\"\"), m),\n\t        m = m.previousSibling,\n\t        f = 0)) : (m = b().createTextNode(\"\"),\n\t        f = 0,\n\t        h.insertBefore(m, e.rightNode()));\n\t        if (d) {\n\t            if (y[d] && a.getCursorPosition(d) === c) {\n\t                for (l = y[d].getNode(); l.nextSibling && \"cursor\" === l.nextSibling.localName; )\n\t                    l.parentNode.insertBefore(l.nextSibling, l);\n\t                0 < m.length && m.nextSibling !== l && (m = b().createTextNode(\"\"),\n\t                f = 0);\n\t                l.parentNode.insertBefore(m, l)\n\t            }\n\t        } else\n\t            for (; m.nextSibling && \"cursor\" === m.nextSibling.localName; )\n\t                m.parentNode.insertBefore(m.nextSibling, m);\n\t        for (; m.previousSibling && m.previousSibling.nodeType === Node.TEXT_NODE; )\n\t            e = m.previousSibling,\n\t            e.appendData(m.data),\n\t            f = e.length,\n\t            m = e,\n\t            m.parentNode.removeChild(m.nextSibling);\n\t        for (; m.nextSibling && m.nextSibling.nodeType === Node.TEXT_NODE; )\n\t            e = m.nextSibling,\n\t            m.appendData(e.data),\n\t            m.parentNode.removeChild(e);\n\t        return {\n\t            textNode: m,\n\t            offset: f\n\t        }\n\t    }\n\t    ;\n\t    this.fixCursorPositions = function() {\n\t        Object.keys(y).forEach(function(c) {\n\t            var b = y[c], d = f(b.getNode()), e = a.createRootFilter(d), h, m, g, k = !1;\n\t            g = b.getSelectedRange();\n\t            h = l(g.startContainer, g.startOffset, d);\n\t            m = n(g.startContainer, g.startOffset, [v, e], h);\n\t            g.collapsed ? d = m : (h = l(g.endContainer, g.endOffset, d),\n\t            d = n(g.endContainer, g.endOffset, [v, e], h));\n\t            m.isStep() && d.isStep() ? m.container() !== d.container() || m.offset() !== d.offset() || g.collapsed && b.getAnchorNode() === b.getNode() || (k = !0,\n\t            g.setStart(m.container(), m.offset()),\n\t            g.collapse(!0)) : (k = !0,\n\t            runtime.assert(m.roundToClosestStep(), \"No walkable step found for cursor owned by \" + c),\n\t            g.setStart(m.container(), m.offset()),\n\t            runtime.assert(d.roundToClosestStep(), \"No walkable step found for cursor owned by \" + c),\n\t            g.setEnd(d.container(), d.offset()));\n\t            k && (b.setSelectedRange(g, b.hasForwardSelection()),\n\t            a.emit(ops.Document.signalCursorMoved, b))\n\t        })\n\t    }\n\t    ;\n\t    this.getCursorPosition = function(a) {\n\t        return (a = y[a]) ? u.convertDomPointToSteps(a.getNode(), 0) : 0\n\t    }\n\t    ;\n\t    this.getCursorSelection = function(a) {\n\t        a = y[a];\n\t        var c = 0\n\t          , b = 0;\n\t        a && (c = u.convertDomPointToSteps(a.getNode(), 0),\n\t        b = u.convertDomPointToSteps(a.getAnchorNode(), 0));\n\t        return {\n\t            position: b,\n\t            length: c - b\n\t        }\n\t    }\n\t    ;\n\t    this.getPositionFilter = function() {\n\t        return v\n\t    }\n\t    ;\n\t    this.getOdfCanvas = function() {\n\t        return g\n\t    }\n\t    ;\n\t    this.getCanvas = function() {\n\t        return g\n\t    }\n\t    ;\n\t    this.getRootNode = d;\n\t    this.addMember = function(a) {\n\t        runtime.assert(void 0 === x[a.getMemberId()], \"This member already exists\");\n\t        x[a.getMemberId()] = a\n\t    }\n\t    ;\n\t    this.getMember = function(a) {\n\t        return x.hasOwnProperty(a) ? x[a] : null\n\t    }\n\t    ;\n\t    this.removeMember = function(a) {\n\t        delete x[a]\n\t    }\n\t    ;\n\t    this.getCursor = function(a) {\n\t        return y[a]\n\t    }\n\t    ;\n\t    this.hasCursor = function(a) {\n\t        return y.hasOwnProperty(a)\n\t    }\n\t    ;\n\t    this.getMemberIds = function() {\n\t        return Object.keys(x)\n\t    }\n\t    ;\n\t    this.addCursor = function(c) {\n\t        runtime.assert(Boolean(c), \"OdtDocument::addCursor without cursor\");\n\t        var b = c.getMemberId()\n\t          , d = a.convertCursorToDomRange(0, 0);\n\t        runtime.assert(\"string\" === typeof b, \"OdtDocument::addCursor has cursor without memberid\");\n\t        runtime.assert(!y[b], \"OdtDocument::addCursor is adding a duplicate cursor with memberid \" + b);\n\t        c.setSelectedRange(d, !0);\n\t        y[b] = c\n\t    }\n\t    ;\n\t    this.removeCursor = function(c) {\n\t        var b = y[c];\n\t        return b ? (b.removeFromDocument(),\n\t        delete y[c],\n\t        a.emit(ops.Document.signalCursorRemoved, c),\n\t        !0) : !1\n\t    }\n\t    ;\n\t    this.moveCursor = function(c, b, d, e) {\n\t        c = y[c];\n\t        b = a.convertCursorToDomRange(b, d);\n\t        c && (c.setSelectedRange(b, 0 <= d),\n\t        c.setSelectionType(e || ops.OdtCursor.RangeSelection))\n\t    }\n\t    ;\n\t    this.getFormatting = function() {\n\t        return g.getFormatting()\n\t    }\n\t    ;\n\t    this.emit = function(a, c) {\n\t        z.emit(a, c)\n\t    }\n\t    ;\n\t    this.subscribe = function(a, c) {\n\t        z.subscribe(a, c)\n\t    }\n\t    ;\n\t    this.unsubscribe = function(a, c) {\n\t        z.unsubscribe(a, c)\n\t    }\n\t    ;\n\t    this.createRootFilter = function(a) {\n\t        return new RootFilter(a,y,f)\n\t    }\n\t    ;\n\t    this.close = function(a) {\n\t        a()\n\t    }\n\t    ;\n\t    this.destroy = function(a) {\n\t        a()\n\t    }\n\t    ;\n\t    (function() {\n\t        var a = d();\n\t        v = new ops.TextPositionFilter;\n\t        c = new odf.StepUtils;\n\t        u = new ops.OdtStepsTranslator(a,k(a),v,500);\n\t        z.subscribe(ops.OdtDocument.signalStepsInserted, u.handleStepsInserted);\n\t        z.subscribe(ops.OdtDocument.signalStepsRemoved, u.handleStepsRemoved);\n\t        z.subscribe(ops.OdtDocument.signalOperationEnd, q);\n\t        z.subscribe(ops.OdtDocument.signalProcessingBatchEnd, core.Task.processTasks)\n\t    }\n\t    )()\n\t}\n\t;\n\tops.OdtDocument.signalParagraphChanged = \"paragraph/changed\";\n\tops.OdtDocument.signalTableAdded = \"table/added\";\n\tops.OdtDocument.signalCommonStyleCreated = \"style/created\";\n\tops.OdtDocument.signalCommonStyleDeleted = \"style/deleted\";\n\tops.OdtDocument.signalParagraphStyleModified = \"paragraphstyle/modified\";\n\tops.OdtDocument.signalOperationStart = \"operation/start\";\n\tops.OdtDocument.signalOperationEnd = \"operation/end\";\n\tops.OdtDocument.signalProcessingBatchStart = \"router/batchstart\";\n\tops.OdtDocument.signalProcessingBatchEnd = \"router/batchend\";\n\tops.OdtDocument.signalUndoStackChanged = \"undo/changed\";\n\tops.OdtDocument.signalStepsInserted = \"steps/inserted\";\n\tops.OdtDocument.signalStepsRemoved = \"steps/removed\";\n\tops.OdtDocument.signalMetadataUpdated = \"metadata/updated\";\n\tops.OdtDocument.signalAnnotationAdded = \"annotation/added\";\n\tops.OpAddAnnotation = function() {\n\t    function g(b, d, e) {\n\t        var f = b.getTextNodeAtStep(e, k);\n\t        f && (b = f.textNode,\n\t        e = b.parentNode,\n\t        f.offset !== b.length && b.splitText(f.offset),\n\t        e.insertBefore(d, b.nextSibling),\n\t        0 === b.length && e.removeChild(b))\n\t    }\n\t    var k, d, b, f, n, p;\n\t    this.init = function(g) {\n\t        k = g.memberid;\n\t        d = parseInt(g.timestamp, 10);\n\t        b = parseInt(g.position, 10);\n\t        f = void 0 !== g.length ? parseInt(g.length, 10) || 0 : void 0;\n\t        n = g.name\n\t    }\n\t    ;\n\t    this.isEdit = !0;\n\t    this.group = void 0;\n\t    this.execute = function(r) {\n\t        var q = r.getCursor(k), e, l;\n\t        p = r.getDOMDocument();\n\t        var a = new Date(d), c, m, h;\n\t        c = p.createElementNS(odf.Namespaces.officens, \"office:annotation\");\n\t        c.setAttributeNS(odf.Namespaces.officens, \"office:name\", n);\n\t        e = p.createElementNS(odf.Namespaces.dcns, \"dc:creator\");\n\t        e.setAttributeNS(\"urn:webodf:names:editinfo\", \"editinfo:memberid\", k);\n\t        e.textContent = r.getMember(k).getProperties().fullName;\n\t        l = p.createElementNS(odf.Namespaces.dcns, \"dc:date\");\n\t        l.appendChild(p.createTextNode(a.toISOString()));\n\t        a = p.createElementNS(odf.Namespaces.textns, \"text:list\");\n\t        m = p.createElementNS(odf.Namespaces.textns, \"text:list-item\");\n\t        h = p.createElementNS(odf.Namespaces.textns, \"text:p\");\n\t        m.appendChild(h);\n\t        a.appendChild(m);\n\t        c.appendChild(e);\n\t        c.appendChild(l);\n\t        c.appendChild(a);\n\t        void 0 !== f && (e = p.createElementNS(odf.Namespaces.officens, \"office:annotation-end\"),\n\t        e.setAttributeNS(odf.Namespaces.officens, \"office:name\", n),\n\t        c.annotationEndElement = e,\n\t        g(r, e, b + f));\n\t        g(r, c, b);\n\t        r.emit(ops.OdtDocument.signalStepsInserted, {\n\t            position: b\n\t        });\n\t        q && (e = p.createRange(),\n\t        l = c.getElementsByTagNameNS(odf.Namespaces.textns, \"p\")[0],\n\t        e.selectNodeContents(l),\n\t        q.setSelectedRange(e, !1),\n\t        q.setSelectionType(ops.OdtCursor.RangeSelection),\n\t        r.emit(ops.Document.signalCursorMoved, q));\n\t        r.getOdfCanvas().addAnnotation(c);\n\t        r.fixCursorPositions();\n\t        r.emit(ops.OdtDocument.signalAnnotationAdded, {\n\t            memberId: k,\n\t            annotation: c\n\t        });\n\t        return !0\n\t    }\n\t    ;\n\t    this.spec = function() {\n\t        return {\n\t            optype: \"AddAnnotation\",\n\t            memberid: k,\n\t            timestamp: d,\n\t            position: b,\n\t            length: f,\n\t            name: n\n\t        }\n\t    }\n\t}\n\t;\n\tops.OpAddCursor = function() {\n\t    var g, k;\n\t    this.init = function(d) {\n\t        g = d.memberid;\n\t        k = d.timestamp\n\t    }\n\t    ;\n\t    this.isEdit = !1;\n\t    this.group = void 0;\n\t    this.execute = function(d) {\n\t        var b = d.getCursor(g);\n\t        if (b)\n\t            return !1;\n\t        b = new ops.OdtCursor(g,d);\n\t        d.addCursor(b);\n\t        d.emit(ops.Document.signalCursorAdded, b);\n\t        return !0\n\t    }\n\t    ;\n\t    this.spec = function() {\n\t        return {\n\t            optype: \"AddCursor\",\n\t            memberid: g,\n\t            timestamp: k\n\t        }\n\t    }\n\t}\n\t;\n\tops.OpAddMember = function() {\n\t    var g, k, d;\n\t    this.init = function(b) {\n\t        g = b.memberid;\n\t        k = parseInt(b.timestamp, 10);\n\t        d = b.setProperties\n\t    }\n\t    ;\n\t    this.isEdit = !1;\n\t    this.group = void 0;\n\t    this.execute = function(b) {\n\t        var f;\n\t        if (b.getMember(g))\n\t            return !1;\n\t        f = new ops.Member(g,d);\n\t        b.addMember(f);\n\t        b.emit(ops.Document.signalMemberAdded, f);\n\t        return !0\n\t    }\n\t    ;\n\t    this.spec = function() {\n\t        return {\n\t            optype: \"AddMember\",\n\t            memberid: g,\n\t            timestamp: k,\n\t            setProperties: d\n\t        }\n\t    }\n\t}\n\t;\n\tops.OpAddStyle = function() {\n\t    var g, k, d, b, f, n, p = odf.Namespaces.stylens;\n\t    this.init = function(p) {\n\t        g = p.memberid;\n\t        k = p.timestamp;\n\t        d = p.styleName;\n\t        b = p.styleFamily;\n\t        f = \"true\" === p.isAutomaticStyle || !0 === p.isAutomaticStyle;\n\t        n = p.setProperties\n\t    }\n\t    ;\n\t    this.isEdit = !0;\n\t    this.group = void 0;\n\t    this.execute = function(g) {\n\t        var k = g.getOdfCanvas().odfContainer()\n\t          , e = g.getFormatting()\n\t          , l = g.getDOMDocument().createElementNS(p, \"style:style\");\n\t        if (!l)\n\t            return !1;\n\t        n && e.updateStyle(l, n);\n\t        l.setAttributeNS(p, \"style:family\", b);\n\t        l.setAttributeNS(p, \"style:name\", d);\n\t        f ? k.rootElement.automaticStyles.appendChild(l) : k.rootElement.styles.appendChild(l);\n\t        g.getOdfCanvas().refreshCSS();\n\t        f || g.emit(ops.OdtDocument.signalCommonStyleCreated, {\n\t            name: d,\n\t            family: b\n\t        });\n\t        return !0\n\t    }\n\t    ;\n\t    this.spec = function() {\n\t        return {\n\t            optype: \"AddStyle\",\n\t            memberid: g,\n\t            timestamp: k,\n\t            styleName: d,\n\t            styleFamily: b,\n\t            isAutomaticStyle: f,\n\t            setProperties: n\n\t        }\n\t    }\n\t}\n\t;\n\todf.ObjectNameGenerator = function(g, k) {\n\t    function d(a, c) {\n\t        var b = {};\n\t        this.generateName = function() {\n\t            var d = c(), e = 0, f;\n\t            do\n\t                f = a + e,\n\t                e += 1;\n\t            while (b[f] || d[f]);\n\t            b[f] = !0;\n\t            return f\n\t        }\n\t    }\n\t    function b() {\n\t        var a = {};\n\t        [g.rootElement.automaticStyles, g.rootElement.styles].forEach(function(c) {\n\t            for (c = c.firstElementChild; c; )\n\t                c.namespaceURI === f && \"style\" === c.localName && (a[c.getAttributeNS(f, \"name\")] = !0),\n\t                c = c.nextElementSibling\n\t        });\n\t        return a\n\t    }\n\t    var f = odf.Namespaces.stylens\n\t      , n = odf.Namespaces.drawns\n\t      , p = odf.Namespaces.xlinkns\n\t      , r = (new core.Utils).hashString(k)\n\t      , q = null\n\t      , e = null\n\t      , l = null\n\t      , a = {}\n\t      , c = {};\n\t    this.generateStyleName = function() {\n\t        null === q && (q = new d(\"auto\" + r + \"_\",function() {\n\t            return b()\n\t        }\n\t        ));\n\t        return q.generateName()\n\t    }\n\t    ;\n\t    this.generateFrameName = function() {\n\t        var c, b, f;\n\t        if (null === e) {\n\t            b = g.rootElement.body.getElementsByTagNameNS(n, \"frame\");\n\t            for (c = 0; c < b.length; c += 1)\n\t                f = b.item(c),\n\t                a[f.getAttributeNS(n, \"name\")] = !0;\n\t            e = new d(\"fr\" + r + \"_\",function() {\n\t                return a\n\t            }\n\t            )\n\t        }\n\t        return e.generateName()\n\t    }\n\t    ;\n\t    this.generateImageName = function() {\n\t        var a, b, e;\n\t        if (null === l) {\n\t            e = g.rootElement.body.getElementsByTagNameNS(n, \"image\");\n\t            for (a = 0; a < e.length; a += 1)\n\t                b = e.item(a),\n\t                b = b.getAttributeNS(p, \"href\"),\n\t                b = b.substring(9, b.lastIndexOf(\".\")),\n\t                c[b] = !0;\n\t            l = new d(\"img\" + r + \"_\",function() {\n\t                return c\n\t            }\n\t            )\n\t        }\n\t        return l.generateName()\n\t    }\n\t}\n\t;\n\todf.TextStyleApplicator = function(g, k, d) {\n\t    function b(b) {\n\t        function d(a, b) {\n\t            return \"object\" === typeof a && \"object\" === typeof b ? Object.keys(a).every(function(e) {\n\t                return d(a[e], b[e])\n\t            }) : a === b\n\t        }\n\t        var a = {};\n\t        this.isStyleApplied = function(c) {\n\t            c = k.getAppliedStylesForElement(c, a).styleProperties;\n\t            return d(b, c)\n\t        }\n\t    }\n\t    function f(b) {\n\t        var f = {};\n\t        this.applyStyleToContainer = function(a) {\n\t            var c;\n\t            c = a.getAttributeNS(r, \"style-name\");\n\t            var m = a.ownerDocument;\n\t            c = c || \"\";\n\t            if (!f.hasOwnProperty(c)) {\n\t                var h = c, n;\n\t                n = c ? k.createDerivedStyleObject(c, \"text\", b) : b;\n\t                m = m.createElementNS(q, \"style:style\");\n\t                k.updateStyle(m, n);\n\t                m.setAttributeNS(q, \"style:name\", g.generateStyleName());\n\t                m.setAttributeNS(q, \"style:family\", \"text\");\n\t                m.setAttributeNS(\"urn:webodf:names:scope\", \"scope\", \"document-content\");\n\t                d.appendChild(m);\n\t                f[h] = m\n\t            }\n\t            c = f[c].getAttributeNS(q, \"name\");\n\t            a.setAttributeNS(r, \"text:style-name\", c)\n\t        }\n\t    }\n\t    function n(b, d) {\n\t        var a = b.ownerDocument, c = b.parentNode, m, h, f, g = new core.LoopWatchDog(1E4);\n\t        h = [];\n\t        h.push(b);\n\t        for (f = b.nextSibling; f && p.rangeContainsNode(d, f); )\n\t            g.check(),\n\t            h.push(f),\n\t            f = f.nextSibling;\n\t        \"span\" !== c.localName || c.namespaceURI !== r ? (m = a.createElementNS(r, \"text:span\"),\n\t        c.insertBefore(m, b),\n\t        a = !1) : (b.previousSibling && !p.rangeContainsNode(d, c.firstChild) ? (m = c.cloneNode(!1),\n\t        c.parentNode.insertBefore(m, c.nextSibling)) : m = c,\n\t        a = !0);\n\t        h.forEach(function(a) {\n\t            a.parentNode !== m && m.appendChild(a)\n\t        });\n\t        if (f && a)\n\t            for (h = m.cloneNode(!1),\n\t            m.parentNode.insertBefore(h, m.nextSibling); f; )\n\t                g.check(),\n\t                a = f.nextSibling,\n\t                h.appendChild(f),\n\t                f = a;\n\t        return m\n\t    }\n\t    var p = core.DomUtils\n\t      , r = odf.Namespaces.textns\n\t      , q = odf.Namespaces.stylens;\n\t    this.applyStyle = function(d, g, a) {\n\t        var c = {}, m, h, k, p;\n\t        runtime.assert(a && a.hasOwnProperty(\"style:text-properties\"), \"applyStyle without any text properties\");\n\t        c[\"style:text-properties\"] = a[\"style:text-properties\"];\n\t        k = new f(c);\n\t        p = new b(c);\n\t        d.forEach(function(a) {\n\t            m = p.isStyleApplied(a);\n\t            !1 === m && (h = n(a, g),\n\t            k.applyStyleToContainer(h))\n\t        })\n\t    }\n\t}\n\t;\n\tops.OpApplyDirectStyling = function() {\n\t    function g(b, d, f) {\n\t        var a = b.getOdfCanvas().odfContainer()\n\t          , c = r.splitBoundaries(d)\n\t          , m = p.getTextNodes(d, !1);\n\t        (new odf.TextStyleApplicator(new odf.ObjectNameGenerator(a,k),b.getFormatting(),a.rootElement.automaticStyles)).applyStyle(m, d, f);\n\t        c.forEach(r.normalizeTextNodes)\n\t    }\n\t    var k, d, b, f, n, p = odf.OdfUtils, r = core.DomUtils;\n\t    this.init = function(g) {\n\t        k = g.memberid;\n\t        d = g.timestamp;\n\t        b = parseInt(g.position, 10);\n\t        f = parseInt(g.length, 10);\n\t        n = g.setProperties\n\t    }\n\t    ;\n\t    this.isEdit = !0;\n\t    this.group = void 0;\n\t    this.execute = function(r) {\n\t        var e = r.convertCursorToDomRange(b, f)\n\t          , l = p.getParagraphElements(e);\n\t        g(r, e, n);\n\t        e.detach();\n\t        r.getOdfCanvas().refreshCSS();\n\t        r.fixCursorPositions();\n\t        l.forEach(function(a) {\n\t            r.emit(ops.OdtDocument.signalParagraphChanged, {\n\t                paragraphElement: a,\n\t                memberId: k,\n\t                timeStamp: d\n\t            })\n\t        });\n\t        r.getOdfCanvas().rerenderAnnotations();\n\t        return !0\n\t    }\n\t    ;\n\t    this.spec = function() {\n\t        return {\n\t            optype: \"ApplyDirectStyling\",\n\t            memberid: k,\n\t            timestamp: d,\n\t            position: b,\n\t            length: f,\n\t            setProperties: n\n\t        }\n\t    }\n\t}\n\t;\n\tops.OpApplyHyperlink = function() {\n\t    function g(b) {\n\t        for (; b; ) {\n\t            if (r.isHyperlink(b))\n\t                return !0;\n\t            b = b.parentNode\n\t        }\n\t        return !1\n\t    }\n\t    var k, d, b, f, n, p = core.DomUtils, r = odf.OdfUtils;\n\t    this.init = function(g) {\n\t        k = g.memberid;\n\t        d = g.timestamp;\n\t        b = g.position;\n\t        f = g.length;\n\t        n = g.hyperlink\n\t    }\n\t    ;\n\t    this.isEdit = !0;\n\t    this.group = void 0;\n\t    this.execute = function(q) {\n\t        var e = q.getDOMDocument()\n\t          , l = q.convertCursorToDomRange(b, f)\n\t          , a = p.splitBoundaries(l)\n\t          , c = []\n\t          , m = r.getTextNodes(l, !1);\n\t        if (0 === m.length)\n\t            return !1;\n\t        m.forEach(function(a) {\n\t            var b = r.getParagraphElement(a);\n\t            runtime.assert(!1 === g(a), \"The given range should not contain any link.\");\n\t            var d = n\n\t              , m = e.createElementNS(odf.Namespaces.textns, \"text:a\");\n\t            m.setAttributeNS(odf.Namespaces.xlinkns, \"xlink:type\", \"simple\");\n\t            m.setAttributeNS(odf.Namespaces.xlinkns, \"xlink:href\", d);\n\t            a.parentNode.insertBefore(m, a);\n\t            m.appendChild(a);\n\t            -1 === c.indexOf(b) && c.push(b)\n\t        });\n\t        a.forEach(p.normalizeTextNodes);\n\t        l.detach();\n\t        q.fixCursorPositions();\n\t        q.getOdfCanvas().refreshSize();\n\t        q.getOdfCanvas().rerenderAnnotations();\n\t        c.forEach(function(a) {\n\t            q.emit(ops.OdtDocument.signalParagraphChanged, {\n\t                paragraphElement: a,\n\t                memberId: k,\n\t                timeStamp: d\n\t            })\n\t        });\n\t        return !0\n\t    }\n\t    ;\n\t    this.spec = function() {\n\t        return {\n\t            optype: \"ApplyHyperlink\",\n\t            memberid: k,\n\t            timestamp: d,\n\t            position: b,\n\t            length: f,\n\t            hyperlink: n\n\t        }\n\t    }\n\t}\n\t;\n\tops.OpInsertImage = function() {\n\t    var g, k, d, b, f, n, p, r, q = odf.Namespaces.drawns, e = odf.Namespaces.svgns, l = odf.Namespaces.textns, a = odf.Namespaces.xlinkns, c = odf.OdfUtils;\n\t    this.init = function(a) {\n\t        g = a.memberid;\n\t        k = a.timestamp;\n\t        d = a.position;\n\t        b = a.filename;\n\t        f = a.frameWidth;\n\t        n = a.frameHeight;\n\t        p = a.frameStyleName;\n\t        r = a.frameName\n\t    }\n\t    ;\n\t    this.isEdit = !0;\n\t    this.group = void 0;\n\t    this.execute = function(m) {\n\t        var h = m.getOdfCanvas(), y = m.getTextNodeAtStep(d, g), x, z;\n\t        if (!y)\n\t            return !1;\n\t        x = y.textNode;\n\t        z = c.getParagraphElement(x);\n\t        var y = y.offset !== x.length ? x.splitText(y.offset) : x.nextSibling\n\t          , w = m.getDOMDocument()\n\t          , v = w.createElementNS(q, \"draw:image\")\n\t          , w = w.createElementNS(q, \"draw:frame\");\n\t        v.setAttributeNS(a, \"xlink:href\", b);\n\t        v.setAttributeNS(a, \"xlink:type\", \"simple\");\n\t        v.setAttributeNS(a, \"xlink:show\", \"embed\");\n\t        v.setAttributeNS(a, \"xlink:actuate\", \"onLoad\");\n\t        w.setAttributeNS(q, \"draw:style-name\", p);\n\t        w.setAttributeNS(q, \"draw:name\", r);\n\t        w.setAttributeNS(l, \"text:anchor-type\", \"as-char\");\n\t        w.setAttributeNS(e, \"svg:width\", f);\n\t        w.setAttributeNS(e, \"svg:height\", n);\n\t        w.appendChild(v);\n\t        x.parentNode.insertBefore(w, y);\n\t        m.emit(ops.OdtDocument.signalStepsInserted, {\n\t            position: d\n\t        });\n\t        0 === x.length && x.parentNode.removeChild(x);\n\t        h.addCssForFrameWithImage(w);\n\t        h.refreshCSS();\n\t        m.emit(ops.OdtDocument.signalParagraphChanged, {\n\t            paragraphElement: z,\n\t            memberId: g,\n\t            timeStamp: k\n\t        });\n\t        h.rerenderAnnotations();\n\t        return !0\n\t    }\n\t    ;\n\t    this.spec = function() {\n\t        return {\n\t            optype: \"InsertImage\",\n\t            memberid: g,\n\t            timestamp: k,\n\t            filename: b,\n\t            position: d,\n\t            frameWidth: f,\n\t            frameHeight: n,\n\t            frameStyleName: p,\n\t            frameName: r\n\t        }\n\t    }\n\t}\n\t;\n\tops.OpInsertTable = function() {\n\t    function g(a, c) {\n\t        var d;\n\t        if (1 === e.length)\n\t            d = e[0];\n\t        else if (3 === e.length)\n\t            switch (a) {\n\t            case 0:\n\t                d = e[0];\n\t                break;\n\t            case b - 1:\n\t                d = e[2];\n\t                break;\n\t            default:\n\t                d = e[1]\n\t            }\n\t        else\n\t            d = e[a];\n\t        if (1 === d.length)\n\t            return d[0];\n\t        if (3 === d.length)\n\t            switch (c) {\n\t            case 0:\n\t                return d[0];\n\t            case f - 1:\n\t                return d[2];\n\t            default:\n\t                return d[1]\n\t            }\n\t        return d[c]\n\t    }\n\t    var k, d, b, f, n, p, r, q, e, l = odf.OdfUtils;\n\t    this.init = function(a) {\n\t        k = a.memberid;\n\t        d = a.timestamp;\n\t        n = a.position;\n\t        b = a.initialRows;\n\t        f = a.initialColumns;\n\t        p = a.tableName;\n\t        r = a.tableStyleName;\n\t        q = a.tableColumnStyleName;\n\t        e = a.tableCellStyleMatrix\n\t    }\n\t    ;\n\t    this.isEdit = !0;\n\t    this.group = void 0;\n\t    this.execute = function(a) {\n\t        var c = a.getTextNodeAtStep(n)\n\t          , e = a.getRootNode();\n\t        if (c) {\n\t            var h = a.getDOMDocument(), y = h.createElementNS(\"urn:oasis:names:tc:opendocument:xmlns:table:1.0\", \"table:table\"), x = h.createElementNS(\"urn:oasis:names:tc:opendocument:xmlns:table:1.0\", \"table:table-column\"), z, w, v, u;\n\t            r && y.setAttributeNS(\"urn:oasis:names:tc:opendocument:xmlns:table:1.0\", \"table:style-name\", r);\n\t            p && y.setAttributeNS(\"urn:oasis:names:tc:opendocument:xmlns:table:1.0\", \"table:name\", p);\n\t            x.setAttributeNS(\"urn:oasis:names:tc:opendocument:xmlns:table:1.0\", \"table:number-columns-repeated\", f);\n\t            q && x.setAttributeNS(\"urn:oasis:names:tc:opendocument:xmlns:table:1.0\", \"table:style-name\", q);\n\t            y.appendChild(x);\n\t            for (v = 0; v < b; v += 1) {\n\t                x = h.createElementNS(\"urn:oasis:names:tc:opendocument:xmlns:table:1.0\", \"table:table-row\");\n\t                for (u = 0; u < f; u += 1)\n\t                    z = h.createElementNS(\"urn:oasis:names:tc:opendocument:xmlns:table:1.0\", \"table:table-cell\"),\n\t                    (w = g(v, u)) && z.setAttributeNS(\"urn:oasis:names:tc:opendocument:xmlns:table:1.0\", \"table:style-name\", w),\n\t                    w = h.createElementNS(\"urn:oasis:names:tc:opendocument:xmlns:text:1.0\", \"text:p\"),\n\t                    z.appendChild(w),\n\t                    x.appendChild(z);\n\t                y.appendChild(x)\n\t            }\n\t            c = l.getParagraphElement(c.textNode);\n\t            e.insertBefore(y, c.nextSibling);\n\t            a.emit(ops.OdtDocument.signalStepsInserted, {\n\t                position: n\n\t            });\n\t            a.getOdfCanvas().refreshSize();\n\t            a.emit(ops.OdtDocument.signalTableAdded, {\n\t                tableElement: y,\n\t                memberId: k,\n\t                timeStamp: d\n\t            });\n\t            a.getOdfCanvas().rerenderAnnotations();\n\t            return !0\n\t        }\n\t        return !1\n\t    }\n\t    ;\n\t    this.spec = function() {\n\t        return {\n\t            optype: \"InsertTable\",\n\t            memberid: k,\n\t            timestamp: d,\n\t            position: n,\n\t            initialRows: b,\n\t            initialColumns: f,\n\t            tableName: p,\n\t            tableStyleName: r,\n\t            tableColumnStyleName: q,\n\t            tableCellStyleMatrix: e\n\t        }\n\t    }\n\t}\n\t;\n\tops.OpInsertText = function() {\n\t    function g(b) {\n\t        return \"\\t\" !== b && p.isODFWhitespace(b)\n\t    }\n\t    var k, d, b, f, n, p = odf.OdfUtils;\n\t    this.init = function(g) {\n\t        k = g.memberid;\n\t        d = g.timestamp;\n\t        b = g.position;\n\t        n = g.text;\n\t        f = \"true\" === g.moveCursor || !0 === g.moveCursor\n\t    }\n\t    ;\n\t    this.isEdit = !0;\n\t    this.group = void 0;\n\t    this.execute = function(r) {\n\t        var q, e, l, a = null, c = r.getDOMDocument(), m, h = 0, y, x = r.getCursor(k), z;\n\t        r.upgradeWhitespacesAtPosition(b);\n\t        if (q = r.getTextNodeAtStep(b)) {\n\t            e = q.textNode;\n\t            a = e.nextSibling;\n\t            l = e.parentNode;\n\t            m = p.getParagraphElement(e);\n\t            for (z = 0; z < n.length; z += 1) {\n\t                if (!(y = \"\\t\" === n[z])) {\n\t                    y = n;\n\t                    var w = z;\n\t                    y = g(y[w]) && (0 === w || w === y.length - 1 || g(y[w - 1]))\n\t                }\n\t                y && (0 === h ? (q.offset !== e.length && (a = e.splitText(q.offset)),\n\t                0 < z && e.appendData(n.substring(0, z))) : h < z && (h = n.substring(h, z),\n\t                l.insertBefore(c.createTextNode(h), a)),\n\t                h = z + 1,\n\t                \"\\t\" === n[z] ? (y = c.createElementNS(\"urn:oasis:names:tc:opendocument:xmlns:text:1.0\", \"text:tab\"),\n\t                y.appendChild(c.createTextNode(\"\\t\"))) : (\" \" !== n[z] && runtime.log(\"WARN: InsertText operation contains non-tab, non-space whitespace character (character code \" + n.charCodeAt(z) + \")\"),\n\t                y = c.createElementNS(\"urn:oasis:names:tc:opendocument:xmlns:text:1.0\", \"text:s\"),\n\t                y.appendChild(c.createTextNode(\" \"))),\n\t                l.insertBefore(y, a))\n\t            }\n\t            0 === h ? e.insertData(q.offset, n) : h < n.length && (q = n.substring(h),\n\t            l.insertBefore(c.createTextNode(q), a));\n\t            l = e.parentNode;\n\t            a = e.nextSibling;\n\t            l.removeChild(e);\n\t            l.insertBefore(e, a);\n\t            0 === e.length && e.parentNode.removeChild(e);\n\t            r.emit(ops.OdtDocument.signalStepsInserted, {\n\t                position: b\n\t            });\n\t            x && f && (r.moveCursor(k, b + n.length, 0),\n\t            r.emit(ops.Document.signalCursorMoved, x));\n\t            r.downgradeWhitespacesAtPosition(b);\n\t            r.downgradeWhitespacesAtPosition(b + n.length);\n\t            r.getOdfCanvas().refreshSize();\n\t            r.emit(ops.OdtDocument.signalParagraphChanged, {\n\t                paragraphElement: m,\n\t                memberId: k,\n\t                timeStamp: d\n\t            });\n\t            r.getOdfCanvas().rerenderAnnotations();\n\t            return !0\n\t        }\n\t        return !1\n\t    }\n\t    ;\n\t    this.spec = function() {\n\t        return {\n\t            optype: \"InsertText\",\n\t            memberid: k,\n\t            timestamp: d,\n\t            position: b,\n\t            text: n,\n\t            moveCursor: f\n\t        }\n\t    }\n\t}\n\t;\n\todf.CollapsingRules = function(g) {\n\t    function k(d) {\n\t        return b.isODFNode(d) || \"br\" === d.localName && b.isLineBreak(d.parentNode) || d.nodeType === Node.TEXT_NODE && b.isODFNode(d.parentNode) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT\n\t    }\n\t    function d(n) {\n\t        var p;\n\t        n.nodeType === Node.TEXT_NODE ? (p = n.parentNode,\n\t        p.removeChild(n)) : p = f.removeUnwantedNodes(n, k);\n\t        if (n = p)\n\t            n = p,\n\t            n = !b.isParagraph(n) && n !== g && b.hasNoODFContent(n);\n\t        return n ? d(p) : p\n\t    }\n\t    var b = odf.OdfUtils\n\t      , f = core.DomUtils;\n\t    this.mergeChildrenIntoParent = d\n\t}\n\t;\n\tops.OpMergeParagraph = function() {\n\t    function g(a) {\n\t        return odf.OdfUtils.isInlineRoot(a) ? NodeFilter.FILTER_SKIP : l.isGroupingElement(a) && l.hasNoODFContent(a) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT\n\t    }\n\t    function k(a) {\n\t        if (a.nodeType === Node.TEXT_NODE) {\n\t            if (0 === a.length)\n\t                return runtime.log(\"WARN: Empty text node found during merge operation\"),\n\t                !0;\n\t            if (l.isODFWhitespace(a.data) && !1 === l.isSignificantWhitespace(a, 0))\n\t                return !0;\n\t            a = \"#text\"\n\t        } else\n\t            a = (a.prefix ? a.prefix + \":\" : \"\") + a.localName;\n\t        runtime.log(\"WARN: Unexpected text element found near paragraph boundary [\" + a + \"]\");\n\t        return !1\n\t    }\n\t    function d(c) {\n\t        c.collapsed || (a.splitBoundaries(c),\n\t        c = l.getTextElements(c, !1, !0).filter(k),\n\t        c.forEach(function(a) {\n\t            a.parentNode.removeChild(a)\n\t        }))\n\t    }\n\t    function b(a, c, b) {\n\t        a = a.convertCursorStepToDomPoint(c);\n\t        var d = l.getParagraphElement(a.node, a.offset);\n\t        runtime.assert(Boolean(d), \"Paragraph not found at step \" + c);\n\t        b && b.setPosition(a.node, a.offset);\n\t        return d\n\t    }\n\t    var f, n, p, r, q, e, l = odf.OdfUtils, a = core.DomUtils, c = odf.Namespaces.textns;\n\t    this.init = function(a) {\n\t        f = a.memberid;\n\t        n = a.timestamp;\n\t        p = a.moveCursor;\n\t        r = a.paragraphStyleName;\n\t        q = parseInt(a.sourceStartPosition, 10);\n\t        e = parseInt(a.destinationStartPosition, 10)\n\t    }\n\t    ;\n\t    this.isEdit = !0;\n\t    this.group = void 0;\n\t    this.execute = function(m) {\n\t        var h, l, k = m.getCursor(f);\n\t        h = m.getRootNode();\n\t        var z = new odf.CollapsingRules(h), w = m.createStepIterator(h, 0, [m.getPositionFilter()], h), v;\n\t        runtime.assert(e < q, \"Destination paragraph (\" + e + \") must be before source paragraph (\" + q + \")\");\n\t        l = b(m, e);\n\t        h = b(m, q, w);\n\t        w.previousStep();\n\t        runtime.assert(a.containsNode(l, w.container()), \"Destination paragraph must be adjacent to the source paragraph\");\n\t        v = l.ownerDocument.createRange();\n\t        w.setPosition(l, l.childNodes.length);\n\t        w.roundToPreviousStep();\n\t        v.setStart(w.container(), w.offset());\n\t        v.setEnd(l, l.childNodes.length);\n\t        d(v);\n\t        v = l.childNodes.length;\n\t        var u = h.ownerDocument.createRange();\n\t        w.setPosition(h, 0);\n\t        w.roundToNextStep();\n\t        u.setStart(h, 0);\n\t        u.setEnd(w.container(), w.offset());\n\t        d(u);\n\t        for (u = h.firstChild; u; )\n\t            \"editinfo\" === u.localName ? h.removeChild(u) : (l.appendChild(u),\n\t            a.removeUnwantedNodes(u, g)),\n\t            u = h.firstChild;\n\t        runtime.assert(0 === h.childNodes.length, \"Source paragraph should be empty before it is removed\");\n\t        z.mergeChildrenIntoParent(h);\n\t        m.emit(ops.OdtDocument.signalStepsRemoved, {\n\t            position: q - 1\n\t        });\n\t        w.setPosition(l, v);\n\t        w.roundToClosestStep();\n\t        w.previousStep() || w.roundToNextStep();\n\t        m.downgradeWhitespaces(w);\n\t        r ? l.setAttributeNS(c, \"text:style-name\", r) : l.removeAttributeNS(c, \"style-name\");\n\t        k && p && (m.moveCursor(f, q - 1, 0),\n\t        m.emit(ops.Document.signalCursorMoved, k));\n\t        m.fixCursorPositions();\n\t        m.getOdfCanvas().refreshSize();\n\t        m.emit(ops.OdtDocument.signalParagraphChanged, {\n\t            paragraphElement: l,\n\t            memberId: f,\n\t            timeStamp: n\n\t        });\n\t        m.getOdfCanvas().rerenderAnnotations();\n\t        return !0\n\t    }\n\t    ;\n\t    this.spec = function() {\n\t        return {\n\t            optype: \"MergeParagraph\",\n\t            memberid: f,\n\t            timestamp: n,\n\t            moveCursor: p,\n\t            paragraphStyleName: r,\n\t            sourceStartPosition: q,\n\t            destinationStartPosition: e\n\t        }\n\t    }\n\t}\n\t;\n\tops.OpMoveCursor = function() {\n\t    var g, k, d, b, f;\n\t    this.init = function(n) {\n\t        g = n.memberid;\n\t        k = n.timestamp;\n\t        d = n.position;\n\t        b = n.length || 0;\n\t        f = n.selectionType || ops.OdtCursor.RangeSelection\n\t    }\n\t    ;\n\t    this.isEdit = !1;\n\t    this.group = void 0;\n\t    this.execute = function(n) {\n\t        var k = n.getCursor(g), r;\n\t        if (!k)\n\t            return !1;\n\t        r = n.convertCursorToDomRange(d, b);\n\t        k.setSelectedRange(r, 0 <= b);\n\t        k.setSelectionType(f);\n\t        n.emit(ops.Document.signalCursorMoved, k);\n\t        return !0\n\t    }\n\t    ;\n\t    this.spec = function() {\n\t        return {\n\t            optype: \"MoveCursor\",\n\t            memberid: g,\n\t            timestamp: k,\n\t            position: d,\n\t            length: b,\n\t            selectionType: f\n\t        }\n\t    }\n\t}\n\t;\n\tops.OpRemoveAnnotation = function() {\n\t    var g, k, d, b, f = core.DomUtils;\n\t    this.init = function(f) {\n\t        g = f.memberid;\n\t        k = f.timestamp;\n\t        d = parseInt(f.position, 10);\n\t        b = parseInt(f.length, 10)\n\t    }\n\t    ;\n\t    this.isEdit = !0;\n\t    this.group = void 0;\n\t    this.execute = function(b) {\n\t        function g(b) {\n\t            q.parentNode.insertBefore(b, q)\n\t        }\n\t        for (var k = b.getIteratorAtPosition(d).container(), q; k.namespaceURI !== odf.Namespaces.officens || \"annotation\" !== k.localName; )\n\t            k = k.parentNode;\n\t        if (null === k)\n\t            return !1;\n\t        q = k;\n\t        k = q.annotationEndElement;\n\t        b.getOdfCanvas().forgetAnnotation(q);\n\t        f.getElementsByTagNameNS(q, \"urn:webodf:names:cursor\", \"cursor\").forEach(g);\n\t        f.getElementsByTagNameNS(q, \"urn:webodf:names:cursor\", \"anchor\").forEach(g);\n\t        q.parentNode.removeChild(q);\n\t        k && k.parentNode.removeChild(k);\n\t        b.emit(ops.OdtDocument.signalStepsRemoved, {\n\t            position: 0 < d ? d - 1 : d\n\t        });\n\t        b.getOdfCanvas().rerenderAnnotations();\n\t        b.fixCursorPositions();\n\t        return !0\n\t    }\n\t    ;\n\t    this.spec = function() {\n\t        return {\n\t            optype: \"RemoveAnnotation\",\n\t            memberid: g,\n\t            timestamp: k,\n\t            position: d,\n\t            length: b\n\t        }\n\t    }\n\t}\n\t;\n\tops.OpRemoveBlob = function() {\n\t    var g, k, d;\n\t    this.init = function(b) {\n\t        g = b.memberid;\n\t        k = b.timestamp;\n\t        d = b.filename\n\t    }\n\t    ;\n\t    this.isEdit = !0;\n\t    this.group = void 0;\n\t    this.execute = function(b) {\n\t        b.getOdfCanvas().odfContainer().removeBlob(d);\n\t        return !0\n\t    }\n\t    ;\n\t    this.spec = function() {\n\t        return {\n\t            optype: \"RemoveBlob\",\n\t            memberid: g,\n\t            timestamp: k,\n\t            filename: d\n\t        }\n\t    }\n\t}\n\t;\n\tops.OpRemoveCursor = function() {\n\t    var g, k;\n\t    this.init = function(d) {\n\t        g = d.memberid;\n\t        k = d.timestamp\n\t    }\n\t    ;\n\t    this.isEdit = !1;\n\t    this.group = void 0;\n\t    this.execute = function(d) {\n\t        return d.removeCursor(g) ? !0 : !1\n\t    }\n\t    ;\n\t    this.spec = function() {\n\t        return {\n\t            optype: \"RemoveCursor\",\n\t            memberid: g,\n\t            timestamp: k\n\t        }\n\t    }\n\t}\n\t;\n\tops.OpRemoveHyperlink = function() {\n\t    var g, k, d, b, f = core.DomUtils, n = odf.OdfUtils;\n\t    this.init = function(f) {\n\t        g = f.memberid;\n\t        k = f.timestamp;\n\t        d = f.position;\n\t        b = f.length\n\t    }\n\t    ;\n\t    this.isEdit = !0;\n\t    this.group = void 0;\n\t    this.execute = function(p) {\n\t        var r = p.convertCursorToDomRange(d, b)\n\t          , q = n.getHyperlinkElements(r);\n\t        runtime.assert(1 === q.length, \"The given range should only contain a single link.\");\n\t        q = f.mergeIntoParent(q[0]);\n\t        r.detach();\n\t        p.fixCursorPositions();\n\t        p.getOdfCanvas().refreshSize();\n\t        p.getOdfCanvas().rerenderAnnotations();\n\t        p.emit(ops.OdtDocument.signalParagraphChanged, {\n\t            paragraphElement: n.getParagraphElement(q),\n\t            memberId: g,\n\t            timeStamp: k\n\t        });\n\t        return !0\n\t    }\n\t    ;\n\t    this.spec = function() {\n\t        return {\n\t            optype: \"RemoveHyperlink\",\n\t            memberid: g,\n\t            timestamp: k,\n\t            position: d,\n\t            length: b\n\t        }\n\t    }\n\t}\n\t;\n\tops.OpRemoveMember = function() {\n\t    var g, k;\n\t    this.init = function(d) {\n\t        g = d.memberid;\n\t        k = parseInt(d.timestamp, 10)\n\t    }\n\t    ;\n\t    this.isEdit = !1;\n\t    this.group = void 0;\n\t    this.execute = function(d) {\n\t        if (!d.getMember(g))\n\t            return !1;\n\t        d.removeMember(g);\n\t        d.emit(ops.Document.signalMemberRemoved, g);\n\t        return !0\n\t    }\n\t    ;\n\t    this.spec = function() {\n\t        return {\n\t            optype: \"RemoveMember\",\n\t            memberid: g,\n\t            timestamp: k\n\t        }\n\t    }\n\t}\n\t;\n\tops.OpRemoveStyle = function() {\n\t    var g, k, d, b;\n\t    this.init = function(f) {\n\t        g = f.memberid;\n\t        k = f.timestamp;\n\t        d = f.styleName;\n\t        b = f.styleFamily\n\t    }\n\t    ;\n\t    this.isEdit = !0;\n\t    this.group = void 0;\n\t    this.execute = function(f) {\n\t        var g = f.getFormatting().getStyleElement(d, b);\n\t        if (!g)\n\t            return !1;\n\t        g.parentNode.removeChild(g);\n\t        f.getOdfCanvas().refreshCSS();\n\t        f.emit(ops.OdtDocument.signalCommonStyleDeleted, {\n\t            name: d,\n\t            family: b\n\t        });\n\t        return !0\n\t    }\n\t    ;\n\t    this.spec = function() {\n\t        return {\n\t            optype: \"RemoveStyle\",\n\t            memberid: g,\n\t            timestamp: k,\n\t            styleName: d,\n\t            styleFamily: b\n\t        }\n\t    }\n\t}\n\t;\n\tops.OpRemoveText = function() {\n\t    var g, k, d, b, f = odf.OdfUtils, n = core.DomUtils;\n\t    this.init = function(f) {\n\t        runtime.assert(0 <= f.length, \"OpRemoveText only supports positive lengths\");\n\t        g = f.memberid;\n\t        k = f.timestamp;\n\t        d = parseInt(f.position, 10);\n\t        b = parseInt(f.length, 10)\n\t    }\n\t    ;\n\t    this.isEdit = !0;\n\t    this.group = void 0;\n\t    this.execute = function(p) {\n\t        var r, q, e, l = p.getCursor(g), a = new odf.CollapsingRules(p.getRootNode());\n\t        p.upgradeWhitespacesAtPosition(d);\n\t        p.upgradeWhitespacesAtPosition(d + b);\n\t        r = p.convertCursorToDomRange(d, b);\n\t        n.splitBoundaries(r);\n\t        q = f.getTextElements(r, !1, !0);\n\t        e = f.getParagraphElement(r.startContainer, r.startOffset);\n\t        runtime.assert(void 0 !== e, \"Attempting to remove text outside a paragraph element\");\n\t        r.detach();\n\t        q.forEach(function(c) {\n\t            c.parentNode ? (runtime.assert(n.containsNode(e, c), \"RemoveText only supports removing elements within the same paragraph\"),\n\t            a.mergeChildrenIntoParent(c)) : runtime.log(\"WARN: text element has already been removed from it's container\")\n\t        });\n\t        p.emit(ops.OdtDocument.signalStepsRemoved, {\n\t            position: d\n\t        });\n\t        p.downgradeWhitespacesAtPosition(d);\n\t        p.fixCursorPositions();\n\t        p.getOdfCanvas().refreshSize();\n\t        p.emit(ops.OdtDocument.signalParagraphChanged, {\n\t            paragraphElement: e,\n\t            memberId: g,\n\t            timeStamp: k\n\t        });\n\t        l && (l.resetSelectionType(),\n\t        p.emit(ops.Document.signalCursorMoved, l));\n\t        p.getOdfCanvas().rerenderAnnotations();\n\t        return !0\n\t    }\n\t    ;\n\t    this.spec = function() {\n\t        return {\n\t            optype: \"RemoveText\",\n\t            memberid: g,\n\t            timestamp: k,\n\t            position: d,\n\t            length: b\n\t        }\n\t    }\n\t}\n\t;\n\tops.OpSetBlob = function() {\n\t    var g, k, d, b, f;\n\t    this.init = function(n) {\n\t        g = n.memberid;\n\t        k = n.timestamp;\n\t        d = n.filename;\n\t        b = n.mimetype;\n\t        f = n.content\n\t    }\n\t    ;\n\t    this.isEdit = !0;\n\t    this.group = void 0;\n\t    this.execute = function(g) {\n\t        g.getOdfCanvas().odfContainer().setBlob(d, b, f);\n\t        return !0\n\t    }\n\t    ;\n\t    this.spec = function() {\n\t        return {\n\t            optype: \"SetBlob\",\n\t            memberid: g,\n\t            timestamp: k,\n\t            filename: d,\n\t            mimetype: b,\n\t            content: f\n\t        }\n\t    }\n\t}\n\t;\n\tops.OpSetParagraphStyle = function() {\n\t    function g(b, d, f) {\n\t        var e = [b.getPositionFilter()]\n\t          , g = f.container();\n\t        f = f.unfilteredDomOffset();\n\t        return !1 === b.createStepIterator(g, f, e, d).previousStep()\n\t    }\n\t    var k, d, b, f, n = odf.OdfUtils;\n\t    this.init = function(g) {\n\t        k = g.memberid;\n\t        d = g.timestamp;\n\t        b = g.position;\n\t        f = g.styleName\n\t    }\n\t    ;\n\t    this.isEdit = !0;\n\t    this.group = void 0;\n\t    this.execute = function(p) {\n\t        var r, q;\n\t        r = p.getIteratorAtPosition(b);\n\t        return (q = n.getParagraphElement(r.container())) ? (runtime.assert(g(p, q, r), \"SetParagraphStyle position should be the first position in the paragraph\"),\n\t        f ? q.setAttributeNS(\"urn:oasis:names:tc:opendocument:xmlns:text:1.0\", \"text:style-name\", f) : q.removeAttributeNS(\"urn:oasis:names:tc:opendocument:xmlns:text:1.0\", \"style-name\"),\n\t        p.getOdfCanvas().refreshSize(),\n\t        p.emit(ops.OdtDocument.signalParagraphChanged, {\n\t            paragraphElement: q,\n\t            timeStamp: d,\n\t            memberId: k\n\t        }),\n\t        p.getOdfCanvas().rerenderAnnotations(),\n\t        !0) : !1\n\t    }\n\t    ;\n\t    this.spec = function() {\n\t        return {\n\t            optype: \"SetParagraphStyle\",\n\t            memberid: k,\n\t            timestamp: d,\n\t            position: b,\n\t            styleName: f\n\t        }\n\t    }\n\t}\n\t;\n\tops.OpSplitParagraph = function() {\n\t    var g, k, d, b, f, n, p = odf.OdfUtils, r = odf.Namespaces.textns;\n\t    this.init = function(p) {\n\t        g = p.memberid;\n\t        k = p.timestamp;\n\t        b = p.position;\n\t        d = p.sourceParagraphPosition;\n\t        n = p.paragraphStyleName;\n\t        f = \"true\" === p.moveCursor || !0 === p.moveCursor\n\t    }\n\t    ;\n\t    this.isEdit = !0;\n\t    this.group = void 0;\n\t    this.execute = function(d) {\n\t        var e, l, a, c, m, h, y, x = d.getCursor(g);\n\t        d.upgradeWhitespacesAtPosition(b);\n\t        e = d.getTextNodeAtStep(b);\n\t        if (!e)\n\t            return !1;\n\t        l = p.getParagraphElement(e.textNode);\n\t        if (!l)\n\t            return !1;\n\t        a = p.isListItem(l.parentNode) ? l.parentNode : l;\n\t        0 === e.offset ? (y = e.textNode.previousSibling,\n\t        h = null) : (y = e.textNode,\n\t        h = e.offset >= e.textNode.length ? null : e.textNode.splitText(e.offset));\n\t        for (c = e.textNode; c !== a; ) {\n\t            c = c.parentNode;\n\t            m = c.cloneNode(!1);\n\t            h && m.appendChild(h);\n\t            if (y)\n\t                for (; y && y.nextSibling; )\n\t                    m.appendChild(y.nextSibling);\n\t            else\n\t                for (; c.firstChild; )\n\t                    m.appendChild(c.firstChild);\n\t            c.parentNode.insertBefore(m, c.nextSibling);\n\t            y = c;\n\t            h = m\n\t        }\n\t        p.isListItem(h) && (h = h.childNodes.item(0));\n\t        n ? h.setAttributeNS(r, \"text:style-name\", n) : h.removeAttributeNS(r, \"style-name\");\n\t        0 === e.textNode.length && e.textNode.parentNode.removeChild(e.textNode);\n\t        d.emit(ops.OdtDocument.signalStepsInserted, {\n\t            position: b\n\t        });\n\t        x && f && (d.moveCursor(g, b + 1, 0),\n\t        d.emit(ops.Document.signalCursorMoved, x));\n\t        d.fixCursorPositions();\n\t        d.getOdfCanvas().refreshSize();\n\t        d.emit(ops.OdtDocument.signalParagraphChanged, {\n\t            paragraphElement: l,\n\t            memberId: g,\n\t            timeStamp: k\n\t        });\n\t        d.emit(ops.OdtDocument.signalParagraphChanged, {\n\t            paragraphElement: h,\n\t            memberId: g,\n\t            timeStamp: k\n\t        });\n\t        d.getOdfCanvas().rerenderAnnotations();\n\t        return !0\n\t    }\n\t    ;\n\t    this.spec = function() {\n\t        return {\n\t            optype: \"SplitParagraph\",\n\t            memberid: g,\n\t            timestamp: k,\n\t            position: b,\n\t            sourceParagraphPosition: d,\n\t            paragraphStyleName: n,\n\t            moveCursor: f\n\t        }\n\t    }\n\t}\n\t;\n\tops.OpUpdateMember = function() {\n\t    function g(d) {\n\t        var f = \"//dc:creator[@editinfo:memberid='\" + k + \"']\";\n\t        d = xmldom.XPath.getODFElementsWithXPath(d.getRootNode(), f, function(b) {\n\t            return \"editinfo\" === b ? \"urn:webodf:names:editinfo\" : odf.Namespaces.lookupNamespaceURI(b)\n\t        });\n\t        for (f = 0; f < d.length; f += 1)\n\t            d[f].textContent = b.fullName\n\t    }\n\t    var k, d, b, f;\n\t    this.init = function(g) {\n\t        k = g.memberid;\n\t        d = parseInt(g.timestamp, 10);\n\t        b = g.setProperties;\n\t        f = g.removedProperties\n\t    }\n\t    ;\n\t    this.isEdit = !1;\n\t    this.group = void 0;\n\t    this.execute = function(d) {\n\t        var p = d.getMember(k);\n\t        if (!p)\n\t            return !1;\n\t        f && p.removeProperties(f);\n\t        b && (p.setProperties(b),\n\t        b.fullName && g(d));\n\t        d.emit(ops.Document.signalMemberUpdated, p);\n\t        return !0\n\t    }\n\t    ;\n\t    this.spec = function() {\n\t        return {\n\t            optype: \"UpdateMember\",\n\t            memberid: k,\n\t            timestamp: d,\n\t            setProperties: b,\n\t            removedProperties: f\n\t        }\n\t    }\n\t}\n\t;\n\tops.OpUpdateMetadata = function() {\n\t    var g, k, d, b;\n\t    this.init = function(f) {\n\t        g = f.memberid;\n\t        k = parseInt(f.timestamp, 10);\n\t        d = f.setProperties;\n\t        b = f.removedProperties\n\t    }\n\t    ;\n\t    this.isEdit = !0;\n\t    this.group = void 0;\n\t    this.execute = function(f) {\n\t        var g = f.getOdfCanvas().odfContainer()\n\t          , k = null;\n\t        b && (k = b.attributes.split(\",\"));\n\t        g.setMetadata(d, k);\n\t        f.emit(ops.OdtDocument.signalMetadataUpdated, {\n\t            setProperties: null !== d ? d : {},\n\t            removedProperties: null !== k ? k : []\n\t        });\n\t        return !0\n\t    }\n\t    ;\n\t    this.spec = function() {\n\t        return {\n\t            optype: \"UpdateMetadata\",\n\t            memberid: g,\n\t            timestamp: k,\n\t            setProperties: d,\n\t            removedProperties: b\n\t        }\n\t    }\n\t}\n\t;\n\tops.OpUpdateParagraphStyle = function() {\n\t    function g(b, d) {\n\t        var e, f, a = d ? d.split(\",\") : [];\n\t        for (e = 0; e < a.length; e += 1)\n\t            f = a[e].split(\":\"),\n\t            b.removeAttributeNS(odf.Namespaces.lookupNamespaceURI(f[0]), f[1])\n\t    }\n\t    var k, d, b, f, n, p = odf.Namespaces.stylens;\n\t    this.init = function(g) {\n\t        k = g.memberid;\n\t        d = g.timestamp;\n\t        b = g.styleName;\n\t        f = g.setProperties;\n\t        n = g.removedProperties\n\t    }\n\t    ;\n\t    this.isEdit = !0;\n\t    this.group = void 0;\n\t    this.execute = function(d) {\n\t        var k = d.getFormatting(), e, l, a;\n\t        return (e = \"\" !== b ? k.getStyleElement(b, \"paragraph\") : k.getDefaultStyleElement(\"paragraph\")) ? (l = e.getElementsByTagNameNS(p, \"paragraph-properties\").item(0),\n\t        a = e.getElementsByTagNameNS(p, \"text-properties\").item(0),\n\t        f && k.updateStyle(e, f),\n\t        n && (k = n[\"style:paragraph-properties\"],\n\t        l && k && (g(l, k.attributes),\n\t        0 === l.attributes.length && e.removeChild(l)),\n\t        k = n[\"style:text-properties\"],\n\t        a && k && (g(a, k.attributes),\n\t        0 === a.attributes.length && e.removeChild(a)),\n\t        g(e, n.attributes)),\n\t        d.getOdfCanvas().refreshCSS(),\n\t        d.emit(ops.OdtDocument.signalParagraphStyleModified, b),\n\t        d.getOdfCanvas().rerenderAnnotations(),\n\t        !0) : !1\n\t    }\n\t    ;\n\t    this.spec = function() {\n\t        return {\n\t            optype: \"UpdateParagraphStyle\",\n\t            memberid: k,\n\t            timestamp: d,\n\t            styleName: b,\n\t            setProperties: f,\n\t            removedProperties: n\n\t        }\n\t    }\n\t}\n\t;\n\tops.OperationFactory = function() {\n\t    function g(d) {\n\t        return function(b) {\n\t            return new d\n\t        }\n\t    }\n\t    var k;\n\t    this.register = function(d, b) {\n\t        k[d] = b\n\t    }\n\t    ;\n\t    this.create = function(d) {\n\t        var b = null\n\t          , f = k[d.optype];\n\t        f && (b = f(d),\n\t        b.init(d));\n\t        return b\n\t    }\n\t    ;\n\t    k = {\n\t        AddMember: g(ops.OpAddMember),\n\t        UpdateMember: g(ops.OpUpdateMember),\n\t        RemoveMember: g(ops.OpRemoveMember),\n\t        AddCursor: g(ops.OpAddCursor),\n\t        ApplyDirectStyling: g(ops.OpApplyDirectStyling),\n\t        SetBlob: g(ops.OpSetBlob),\n\t        RemoveBlob: g(ops.OpRemoveBlob),\n\t        InsertImage: g(ops.OpInsertImage),\n\t        InsertTable: g(ops.OpInsertTable),\n\t        InsertText: g(ops.OpInsertText),\n\t        RemoveText: g(ops.OpRemoveText),\n\t        MergeParagraph: g(ops.OpMergeParagraph),\n\t        SplitParagraph: g(ops.OpSplitParagraph),\n\t        SetParagraphStyle: g(ops.OpSetParagraphStyle),\n\t        UpdateParagraphStyle: g(ops.OpUpdateParagraphStyle),\n\t        AddStyle: g(ops.OpAddStyle),\n\t        RemoveStyle: g(ops.OpRemoveStyle),\n\t        MoveCursor: g(ops.OpMoveCursor),\n\t        RemoveCursor: g(ops.OpRemoveCursor),\n\t        AddAnnotation: g(ops.OpAddAnnotation),\n\t        RemoveAnnotation: g(ops.OpRemoveAnnotation),\n\t        UpdateMetadata: g(ops.OpUpdateMetadata),\n\t        ApplyHyperlink: g(ops.OpApplyHyperlink),\n\t        RemoveHyperlink: g(ops.OpRemoveHyperlink)\n\t    }\n\t}\n\t;\n\tops.OperationRouter = function() {}\n\t;\n\tops.OperationRouter.prototype.setOperationFactory = function(g) {}\n\t;\n\tops.OperationRouter.prototype.setPlaybackFunction = function(g) {}\n\t;\n\tops.OperationRouter.prototype.push = function(g) {}\n\t;\n\tops.OperationRouter.prototype.close = function(g) {}\n\t;\n\tops.OperationRouter.prototype.subscribe = function(g, k) {}\n\t;\n\tops.OperationRouter.prototype.unsubscribe = function(g, k) {}\n\t;\n\tops.OperationRouter.prototype.hasLocalUnsyncedOps = function() {}\n\t;\n\tops.OperationRouter.prototype.hasSessionHostConnection = function() {}\n\t;\n\tops.OperationRouter.signalProcessingBatchStart = \"router/batchstart\";\n\tops.OperationRouter.signalProcessingBatchEnd = \"router/batchend\";\n\tops.TrivialOperationRouter = function() {\n\t    var g = new core.EventNotifier([ops.OperationRouter.signalProcessingBatchStart, ops.OperationRouter.signalProcessingBatchEnd]), k, d, b = 0;\n\t    this.setOperationFactory = function(b) {\n\t        k = b\n\t    }\n\t    ;\n\t    this.setPlaybackFunction = function(b) {\n\t        d = b\n\t    }\n\t    ;\n\t    this.push = function(f) {\n\t        b += 1;\n\t        g.emit(ops.OperationRouter.signalProcessingBatchStart, {});\n\t        f.forEach(function(f) {\n\t            f = f.spec();\n\t            f.timestamp = Date.now();\n\t            f = k.create(f);\n\t            f.group = \"g\" + b;\n\t            d(f)\n\t        });\n\t        g.emit(ops.OperationRouter.signalProcessingBatchEnd, {})\n\t    }\n\t    ;\n\t    this.close = function(b) {\n\t        b()\n\t    }\n\t    ;\n\t    this.subscribe = function(b, d) {\n\t        g.subscribe(b, d)\n\t    }\n\t    ;\n\t    this.unsubscribe = function(b, d) {\n\t        g.unsubscribe(b, d)\n\t    }\n\t    ;\n\t    this.hasLocalUnsyncedOps = function() {\n\t        return !1\n\t    }\n\t    ;\n\t    this.hasSessionHostConnection = function() {\n\t        return !0\n\t    }\n\t}\n\t;\n\tops.Session = function(g) {\n\t    function k(b) {\n\t        f.emit(ops.OdtDocument.signalProcessingBatchStart, b)\n\t    }\n\t    function d(b) {\n\t        f.emit(ops.OdtDocument.signalProcessingBatchEnd, b)\n\t    }\n\t    var b = new ops.OperationFactory\n\t      , f = new ops.OdtDocument(g)\n\t      , n = null;\n\t    this.setOperationFactory = function(d) {\n\t        b = d;\n\t        n && n.setOperationFactory(b)\n\t    }\n\t    ;\n\t    this.setOperationRouter = function(g) {\n\t        n && (n.unsubscribe(ops.OperationRouter.signalProcessingBatchStart, k),\n\t        n.unsubscribe(ops.OperationRouter.signalProcessingBatchEnd, d));\n\t        n = g;\n\t        n.subscribe(ops.OperationRouter.signalProcessingBatchStart, k);\n\t        n.subscribe(ops.OperationRouter.signalProcessingBatchEnd, d);\n\t        g.setPlaybackFunction(function(b) {\n\t            f.emit(ops.OdtDocument.signalOperationStart, b);\n\t            return b.execute(f) ? (f.emit(ops.OdtDocument.signalOperationEnd, b),\n\t            !0) : !1\n\t        });\n\t        g.setOperationFactory(b)\n\t    }\n\t    ;\n\t    this.getOperationFactory = function() {\n\t        return b\n\t    }\n\t    ;\n\t    this.getOdtDocument = function() {\n\t        return f\n\t    }\n\t    ;\n\t    this.enqueue = function(b) {\n\t        n.push(b)\n\t    }\n\t    ;\n\t    this.close = function(b) {\n\t        n.close(function(d) {\n\t            d ? b(d) : f.close(b)\n\t        })\n\t    }\n\t    ;\n\t    this.destroy = function(b) {\n\t        f.destroy(b)\n\t    }\n\t    ;\n\t    this.setOperationRouter(new ops.TrivialOperationRouter)\n\t}\n\t;\n\tgui.AnnotationController = function(g, k, d) {\n\t    function b() {\n\t        var a = r.getCursor(d)\n\t          , a = a && a.getNode()\n\t          , b = !1;\n\t        a && (b = !l.isWithinAnnotation(a, r.getRootNode()));\n\t        b !== q && (q = b,\n\t        e.emit(gui.AnnotationController.annotatableChanged, q))\n\t    }\n\t    function f(a) {\n\t        a.getMemberId() === d && b()\n\t    }\n\t    function n(a) {\n\t        a === d && b()\n\t    }\n\t    function p(a) {\n\t        a.getMemberId() === d && b()\n\t    }\n\t    var r = g.getOdtDocument()\n\t      , q = !1\n\t      , e = new core.EventNotifier([gui.AnnotationController.annotatableChanged])\n\t      , l = odf.OdfUtils\n\t      , a = core.StepDirection.NEXT;\n\t    this.isAnnotatable = function() {\n\t        return q\n\t    }\n\t    ;\n\t    this.addAnnotation = function() {\n\t        var a = new ops.OpAddAnnotation\n\t          , b = r.getCursorSelection(d)\n\t          , e = b.length\n\t          , b = b.position;\n\t        q && (0 === e ? e = void 0 : (b = 0 <= e ? b : b + e,\n\t        e = Math.abs(e)),\n\t        a.init({\n\t            memberid: d,\n\t            position: b,\n\t            length: e,\n\t            name: d + Date.now()\n\t        }),\n\t        g.enqueue([a]))\n\t    }\n\t    ;\n\t    this.removeAnnotation = function(c) {\n\t        var b, e;\n\t        b = r.getMember(d).getProperties().fullName;\n\t        if (!0 !== k.getState(gui.CommonConstraints.EDIT.ANNOTATIONS.ONLY_DELETE_OWN) || b === l.getAnnotationCreator(c))\n\t            b = r.convertDomPointToCursorStep(c, 0, a),\n\t            e = r.convertDomPointToCursorStep(c, c.childNodes.length),\n\t            c = new ops.OpRemoveAnnotation,\n\t            c.init({\n\t                memberid: d,\n\t                position: b,\n\t                length: e - b\n\t            }),\n\t            e = new ops.OpMoveCursor,\n\t            e.init({\n\t                memberid: d,\n\t                position: 0 < b ? b - 1 : b,\n\t                length: 0\n\t            }),\n\t            g.enqueue([c, e])\n\t    }\n\t    ;\n\t    this.subscribe = function(a, b) {\n\t        e.subscribe(a, b)\n\t    }\n\t    ;\n\t    this.unsubscribe = function(a, b) {\n\t        e.unsubscribe(a, b)\n\t    }\n\t    ;\n\t    this.destroy = function(a) {\n\t        r.unsubscribe(ops.Document.signalCursorAdded, f);\n\t        r.unsubscribe(ops.Document.signalCursorRemoved, n);\n\t        r.unsubscribe(ops.Document.signalCursorMoved, p);\n\t        a()\n\t    }\n\t    ;\n\t    k.registerConstraint(gui.CommonConstraints.EDIT.ANNOTATIONS.ONLY_DELETE_OWN);\n\t    r.subscribe(ops.Document.signalCursorAdded, f);\n\t    r.subscribe(ops.Document.signalCursorRemoved, n);\n\t    r.subscribe(ops.Document.signalCursorMoved, p);\n\t    b()\n\t}\n\t;\n\tgui.AnnotationController.annotatableChanged = \"annotatable/changed\";\n\tgui.Avatar = function(g, k) {\n\t    var d = this, b, f, n;\n\t    this.setColor = function(b) {\n\t        f.style.borderColor = b\n\t    }\n\t    ;\n\t    this.setImageUrl = function(b) {\n\t        d.isVisible() ? f.src = b : n = b\n\t    }\n\t    ;\n\t    this.isVisible = function() {\n\t        return \"block\" === b.style.display\n\t    }\n\t    ;\n\t    this.show = function() {\n\t        n && (f.src = n,\n\t        n = void 0);\n\t        b.style.display = \"block\"\n\t    }\n\t    ;\n\t    this.hide = function() {\n\t        b.style.display = \"none\"\n\t    }\n\t    ;\n\t    this.markAsFocussed = function(d) {\n\t        d ? b.classList.add(\"active\") : b.classList.remove(\"active\")\n\t    }\n\t    ;\n\t    this.destroy = function(d) {\n\t        g.removeChild(b);\n\t        d()\n\t    }\n\t    ;\n\t    (function() {\n\t        var d = g.ownerDocument;\n\t        b = d.createElement(\"div\");\n\t        f = d.createElement(\"img\");\n\t        b.appendChild(f);\n\t        b.style.display = k ? \"block\" : \"none\";\n\t        b.className = \"handle\";\n\t        g.appendChild(b)\n\t    }\n\t    )()\n\t}\n\t;\n\tgui.StepInfo = function() {}\n\t;\n\tgui.StepInfo.VisualDirection = {\n\t    LEFT_TO_RIGHT: 0,\n\t    RIGHT_TO_LEFT: 1\n\t};\n\tgui.StepInfo.prototype.container = function() {}\n\t;\n\tgui.StepInfo.prototype.offset = function() {}\n\t;\n\tgui.VisualStepScanner = function() {}\n\t;\n\tgui.VisualStepScanner.prototype.process = function(g, k, d) {}\n\t;\n\tgui.GuiStepUtils = function() {\n\t    function g(f) {\n\t        f = d.getContentBounds(f);\n\t        var g, e = null;\n\t        if (f)\n\t            if (f.container.nodeType === Node.TEXT_NODE)\n\t                g = f.container.ownerDocument.createRange(),\n\t                g.setStart(f.container, f.startOffset),\n\t                g.setEnd(f.container, f.endOffset),\n\t                (e = 0 < g.getClientRects().length ? g.getBoundingClientRect() : null) && \" \" === f.container.data.substring(f.startOffset, f.endOffset) && 1 >= e.width && (e = null),\n\t                g.detach();\n\t            else if (k.isCharacterElement(f.container) || k.isCharacterFrame(f.container))\n\t                e = b.getBoundingClientRect(f.container);\n\t        return e\n\t    }\n\t    var k = odf.OdfUtils\n\t      , d = new odf.StepUtils\n\t      , b = core.DomUtils\n\t      , f = core.StepDirection.NEXT\n\t      , n = gui.StepInfo.VisualDirection.LEFT_TO_RIGHT\n\t      , p = gui.StepInfo.VisualDirection.RIGHT_TO_LEFT;\n\t    this.getContentRect = g;\n\t    this.moveToFilteredStep = function(b, d, e) {\n\t        function l(a, b) {\n\t            b.process(w, h, k) && (a = !0,\n\t            !x && b.token && (x = b.token));\n\t            return a\n\t        }\n\t        var a = d === f, c, m, h, k, x, z = b.snapshot();\n\t        c = !1;\n\t        var w;\n\t        do\n\t            c = g(b),\n\t            w = {\n\t                token: b.snapshot(),\n\t                container: b.container,\n\t                offset: b.offset,\n\t                direction: d,\n\t                visualDirection: d === f ? n : p\n\t            },\n\t            m = b.nextStep() ? g(b) : null,\n\t            b.restore(w.token),\n\t            a ? (h = c,\n\t            k = m) : (h = m,\n\t            k = c),\n\t            c = e.reduce(l, !1);\n\t        while (!c && b.advanceStep(d));\n\t        c || e.forEach(function(a) {\n\t            !x && a.token && (x = a.token)\n\t        });\n\t        b.restore(x || z);\n\t        return Boolean(x)\n\t    }\n\t}\n\t;\n\tgui.Caret = function(g, k, d, b) {\n\t    function f() {\n\t        a.style.opacity = \"0\" === a.style.opacity ? \"1\" : \"0\";\n\t        t.trigger()\n\t    }\n\t    function n() {\n\t        y.selectNodeContents(h);\n\t        return y.getBoundingClientRect()\n\t    }\n\t    function p(a) {\n\t        return E[a] !== L[a]\n\t    }\n\t    function r() {\n\t        Object.keys(L).forEach(function(a) {\n\t            E[a] = L[a]\n\t        })\n\t    }\n\t    function q() {\n\t        if (!1 === L.isShown || g.getSelectionType() !== ops.OdtCursor.RangeSelection || !b && !g.getSelectedRange().collapsed)\n\t            L.visibility = \"hidden\",\n\t            a.style.visibility = \"hidden\",\n\t            t.cancel();\n\t        else if (L.visibility = \"visible\",\n\t        a.style.visibility = \"visible\",\n\t        !1 === L.isFocused)\n\t            a.style.opacity = \"1\",\n\t            t.cancel();\n\t        else {\n\t            if (A || p(\"visibility\"))\n\t                a.style.opacity = \"1\",\n\t                t.cancel();\n\t            t.trigger()\n\t        }\n\t        if (K || I) {\n\t            var d;\n\t            d = g.getNode();\n\t            var e, h, f = z.getBoundingClientRect(x.getSizer()), q = !1, y = 0;\n\t            d.removeAttributeNS(\"urn:webodf:names:cursor\", \"caret-sizer-active\");\n\t            if (0 < d.getClientRects().length)\n\t                h = n(),\n\t                y = h.left - z.getBoundingClientRect(d).left,\n\t                q = !0;\n\t            else if (v.setPosition(d, 0),\n\t            h = w.getContentRect(v),\n\t            !h && v.nextStep() && (e = w.getContentRect(v)) && (h = e,\n\t            q = !0),\n\t            h || (d.setAttributeNS(\"urn:webodf:names:cursor\", \"caret-sizer-active\", \"true\"),\n\t            h = n(),\n\t            q = !0),\n\t            !h)\n\t                for (runtime.log(\"WARN: No suitable client rectangle found for visual caret for \" + g.getMemberId()); d; ) {\n\t                    if (0 < d.getClientRects().length) {\n\t                        h = z.getBoundingClientRect(d);\n\t                        q = !0;\n\t                        break\n\t                    }\n\t                    d = d.parentNode\n\t                }\n\t            h = z.translateRect(h, f, x.getZoomLevel());\n\t            d = {\n\t                top: h.top,\n\t                height: h.height,\n\t                right: q ? h.left : h.right,\n\t                width: z.adaptRangeDifferenceToZoomLevel(y, x.getZoomLevel())\n\t            };\n\t            8 > d.height && (d = {\n\t                top: d.top - (8 - d.height) / 2,\n\t                height: 8,\n\t                right: d.right\n\t            });\n\t            l.style.height = d.height + \"px\";\n\t            l.style.top = d.top + \"px\";\n\t            l.style.left = d.right - d.width + \"px\";\n\t            l.style.width = d.width ? d.width + \"px\" : \"\";\n\t            m && (d = runtime.getWindow().getComputedStyle(g.getNode(), null),\n\t            d.font ? m.style.font = d.font : (m.style.fontStyle = d.fontStyle,\n\t            m.style.fontVariant = d.fontVariant,\n\t            m.style.fontWeight = d.fontWeight,\n\t            m.style.fontSize = d.fontSize,\n\t            m.style.lineHeight = d.lineHeight,\n\t            m.style.fontFamily = d.fontFamily))\n\t        }\n\t        L.isShown && I && k.scrollIntoView(a.getBoundingClientRect());\n\t        p(\"isFocused\") && c.markAsFocussed(L.isFocused);\n\t        r();\n\t        K = I = A = !1\n\t    }\n\t    function e(a) {\n\t        l.parentNode.removeChild(l);\n\t        h.parentNode.removeChild(h);\n\t        a()\n\t    }\n\t    var l, a, c, m, h, y, x = g.getDocument().getCanvas(), z = core.DomUtils, w = new gui.GuiStepUtils, v, u, t, A = !1, I = !1, K = !1, L = {\n\t        isFocused: !1,\n\t        isShown: !0,\n\t        visibility: \"hidden\"\n\t    }, E = {\n\t        isFocused: !L.isFocused,\n\t        isShown: !L.isShown,\n\t        visibility: \"hidden\"\n\t    };\n\t    this.handleUpdate = function() {\n\t        K = !0;\n\t        u.trigger()\n\t    }\n\t    ;\n\t    this.refreshCursorBlinking = function() {\n\t        A = !0;\n\t        u.trigger()\n\t    }\n\t    ;\n\t    this.setFocus = function() {\n\t        L.isFocused = !0;\n\t        u.trigger()\n\t    }\n\t    ;\n\t    this.removeFocus = function() {\n\t        L.isFocused = !1;\n\t        u.trigger()\n\t    }\n\t    ;\n\t    this.show = function() {\n\t        L.isShown = !0;\n\t        u.trigger()\n\t    }\n\t    ;\n\t    this.hide = function() {\n\t        L.isShown = !1;\n\t        u.trigger()\n\t    }\n\t    ;\n\t    this.setAvatarImageUrl = function(a) {\n\t        c.setImageUrl(a)\n\t    }\n\t    ;\n\t    this.setColor = function(b) {\n\t        a.style.borderColor = b;\n\t        c.setColor(b)\n\t    }\n\t    ;\n\t    this.getCursor = function() {\n\t        return g\n\t    }\n\t    ;\n\t    this.getFocusElement = function() {\n\t        return a\n\t    }\n\t    ;\n\t    this.toggleHandleVisibility = function() {\n\t        c.isVisible() ? c.hide() : c.show()\n\t    }\n\t    ;\n\t    this.showHandle = function() {\n\t        c.show()\n\t    }\n\t    ;\n\t    this.hideHandle = function() {\n\t        c.hide()\n\t    }\n\t    ;\n\t    this.setOverlayElement = function(a) {\n\t        m = a;\n\t        l.appendChild(a);\n\t        K = !0;\n\t        u.trigger()\n\t    }\n\t    ;\n\t    this.ensureVisible = function() {\n\t        I = !0;\n\t        u.trigger()\n\t    }\n\t    ;\n\t    this.getBoundingClientRect = function() {\n\t        return z.getBoundingClientRect(l)\n\t    }\n\t    ;\n\t    this.destroy = function(a) {\n\t        core.Async.destroyAll([u.destroy, t.destroy, c.destroy, e], a)\n\t    }\n\t    ;\n\t    (function() {\n\t        var b = g.getDocument()\n\t          , e = [b.createRootFilter(g.getMemberId()), b.getPositionFilter()]\n\t          , m = b.getDOMDocument();\n\t        y = m.createRange();\n\t        h = m.createElement(\"span\");\n\t        h.className = \"webodf-caretSizer\";\n\t        h.textContent = \"|\";\n\t        g.getNode().appendChild(h);\n\t        l = m.createElement(\"div\");\n\t        l.setAttributeNS(\"urn:webodf:names:editinfo\", \"editinfo:memberid\", g.getMemberId());\n\t        l.className = \"webodf-caretOverlay\";\n\t        a = m.createElement(\"div\");\n\t        a.className = \"caret\";\n\t        l.appendChild(a);\n\t        c = new gui.Avatar(l,d);\n\t        x.getSizer().appendChild(l);\n\t        v = b.createStepIterator(g.getNode(), 0, e, b.getRootNode());\n\t        u = core.Task.createRedrawTask(q);\n\t        t = core.Task.createTimeoutTask(f, 500);\n\t        u.triggerImmediate()\n\t    }\n\t    )()\n\t}\n\t;\n\todf.TextSerializer = function() {\n\t    function g(b) {\n\t        var f = \"\", n = k.filter ? k.filter.acceptNode(b) : NodeFilter.FILTER_ACCEPT, p = b.nodeType, r;\n\t        if ((n === NodeFilter.FILTER_ACCEPT || n === NodeFilter.FILTER_SKIP) && d.isTextContentContainingNode(b))\n\t            for (r = b.firstChild; r; )\n\t                f += g(r),\n\t                r = r.nextSibling;\n\t        n === NodeFilter.FILTER_ACCEPT && (p === Node.ELEMENT_NODE && d.isParagraph(b) ? f += \"\\n\" : p === Node.TEXT_NODE && b.textContent && (f += b.textContent));\n\t        return f\n\t    }\n\t    var k = this\n\t      , d = odf.OdfUtils;\n\t    this.filter = null;\n\t    this.writeToString = function(b) {\n\t        if (!b)\n\t            return \"\";\n\t        b = g(b);\n\t        \"\\n\" === b[b.length - 1] && (b = b.substr(0, b.length - 1));\n\t        return b\n\t    }\n\t}\n\t;\n\tgui.MimeDataExporter = function() {\n\t    var g;\n\t    this.exportRangeToDataTransfer = function(k, d) {\n\t        var b;\n\t        b = d.startContainer.ownerDocument.createElement(\"span\");\n\t        b.appendChild(d.cloneContents());\n\t        b = g.writeToString(b);\n\t        try {\n\t            k.setData(\"text/plain\", b)\n\t        } catch (f) {\n\t            k.setData(\"Text\", b)\n\t        }\n\t    }\n\t    ;\n\t    g = new odf.TextSerializer;\n\t    g.filter = new odf.OdfNodeFilter\n\t}\n\t;\n\tgui.Clipboard = function(g) {\n\t    this.setDataFromRange = function(k, d) {\n\t        var b, f = k.clipboardData;\n\t        b = runtime.getWindow();\n\t        !f && b && (f = b.clipboardData);\n\t        f ? (b = !0,\n\t        g.exportRangeToDataTransfer(f, d),\n\t        k.preventDefault()) : b = !1;\n\t        return b\n\t    }\n\t}\n\t;\n\tgui.SessionContext = function(g, k) {\n\t    var d = g.getOdtDocument()\n\t      , b = odf.OdfUtils;\n\t    this.isLocalCursorWithinOwnAnnotation = function() {\n\t        var f = d.getCursor(k), g;\n\t        if (!f)\n\t            return !1;\n\t        g = f && f.getNode();\n\t        f = d.getMember(k).getProperties().fullName;\n\t        return (g = b.getParentAnnotation(g, d.getRootNode())) && b.getAnnotationCreator(g) === f ? !0 : !1\n\t    }\n\t}\n\t;\n\tgui.StyleSummary = function(g) {\n\t    function k(b, d) {\n\t        var k = b + \"|\" + d, q;\n\t        f.hasOwnProperty(k) || (q = [],\n\t        g.forEach(function(e) {\n\t            e = (e = e.styleProperties[b]) && e[d];\n\t            -1 === q.indexOf(e) && q.push(e)\n\t        }),\n\t        f[k] = q);\n\t        return f[k]\n\t    }\n\t    function d(b, d, f) {\n\t        return function() {\n\t            var g = k(b, d);\n\t            return f.length >= g.length && g.every(function(b) {\n\t                return -1 !== f.indexOf(b)\n\t            })\n\t        }\n\t    }\n\t    function b(b, d) {\n\t        var f = k(b, d);\n\t        return 1 === f.length ? f[0] : void 0\n\t    }\n\t    var f = {};\n\t    this.getPropertyValues = k;\n\t    this.getCommonValue = b;\n\t    this.isBold = d(\"style:text-properties\", \"fo:font-weight\", [\"bold\"]);\n\t    this.isItalic = d(\"style:text-properties\", \"fo:font-style\", [\"italic\"]);\n\t    this.hasUnderline = d(\"style:text-properties\", \"style:text-underline-style\", [\"solid\"]);\n\t    this.hasStrikeThrough = d(\"style:text-properties\", \"style:text-line-through-style\", [\"solid\"]);\n\t    this.fontSize = function() {\n\t        var d = b(\"style:text-properties\", \"fo:font-size\");\n\t        return d && parseFloat(d)\n\t    }\n\t    ;\n\t    this.fontName = function() {\n\t        return b(\"style:text-properties\", \"style:font-name\")\n\t    }\n\t    ;\n\t    this.isAlignedLeft = d(\"style:paragraph-properties\", \"fo:text-align\", [\"left\", \"start\"]);\n\t    this.isAlignedCenter = d(\"style:paragraph-properties\", \"fo:text-align\", [\"center\"]);\n\t    this.isAlignedRight = d(\"style:paragraph-properties\", \"fo:text-align\", [\"right\", \"end\"]);\n\t    this.isAlignedJustified = d(\"style:paragraph-properties\", \"fo:text-align\", [\"justify\"]);\n\t    this.text = {\n\t        isBold: this.isBold,\n\t        isItalic: this.isItalic,\n\t        hasUnderline: this.hasUnderline,\n\t        hasStrikeThrough: this.hasStrikeThrough,\n\t        fontSize: this.fontSize,\n\t        fontName: this.fontName\n\t    };\n\t    this.paragraph = {\n\t        isAlignedLeft: this.isAlignedLeft,\n\t        isAlignedCenter: this.isAlignedCenter,\n\t        isAlignedRight: this.isAlignedRight,\n\t        isAlignedJustified: this.isAlignedJustified\n\t    }\n\t}\n\t;\n\tgui.DirectFormattingController = function(g, k, d, b, f, n, p) {\n\t    function r() {\n\t        return U.value().styleSummary\n\t    }\n\t    function q() {\n\t        return U.value().enabledFeatures\n\t    }\n\t    function e(a) {\n\t        var b;\n\t        a.collapsed ? (b = a.startContainer,\n\t        b.hasChildNodes() && a.startOffset < b.childNodes.length && (b = b.childNodes.item(a.startOffset)),\n\t        a = [b]) : a = S.getTextElements(a, !0, !1);\n\t        return a\n\t    }\n\t    function l() {\n\t        var a = P.getCursor(b)\n\t          , c = a && a.getSelectedRange()\n\t          , h = []\n\t          , h = []\n\t          , f = !0\n\t          , g = {\n\t            directTextStyling: !0,\n\t            directParagraphStyling: !0\n\t        };\n\t        c && (h = e(c),\n\t        0 === h.length && (h = [c.startContainer, c.endContainer],\n\t        f = !1),\n\t        h = P.getFormatting().getAppliedStyles(h));\n\t        void 0 !== h[0] && Z && (h[0].styleProperties = aa.mergeObjects(h[0].styleProperties, Z));\n\t        !0 === k.getState(gui.CommonConstraints.EDIT.REVIEW_MODE) && (g.directTextStyling = g.directParagraphStyling = d.isLocalCursorWithinOwnAnnotation());\n\t        g.directTextStyling && (g.directTextStyling = f && void 0 !== a && a.getSelectionType() === ops.OdtCursor.RangeSelection);\n\t        return {\n\t            enabledFeatures: g,\n\t            appliedStyles: h,\n\t            styleSummary: new gui.StyleSummary(h)\n\t        }\n\t    }\n\t    function a(a, b) {\n\t        var c = {};\n\t        Object.keys(a).forEach(function(d) {\n\t            var e = a[d]()\n\t              , h = b[d]();\n\t            e !== h && (c[d] = h)\n\t        });\n\t        return c\n\t    }\n\t    function c() {\n\t        var b, c;\n\t        c = ba.styleSummary;\n\t        var d = U.value()\n\t          , e = d.styleSummary\n\t          , h = ba.enabledFeatures\n\t          , f = d.enabledFeatures;\n\t        b = a(c.text, e.text);\n\t        c = a(c.paragraph, e.paragraph);\n\t        h = !(f.directTextStyling === h.directTextStyling && f.directParagraphStyling === h.directParagraphStyling);\n\t        ba = d;\n\t        h && fa.emit(gui.DirectFormattingController.enabledChanged, f);\n\t        0 < Object.keys(b).length && fa.emit(gui.DirectFormattingController.textStylingChanged, b);\n\t        0 < Object.keys(c).length && fa.emit(gui.DirectFormattingController.paragraphStylingChanged, c)\n\t    }\n\t    function m() {\n\t        U.reset();\n\t        c()\n\t    }\n\t    function h(a) {\n\t        (\"string\" === typeof a ? a : a.getMemberId()) === b && U.reset()\n\t    }\n\t    function y() {\n\t        U.reset()\n\t    }\n\t    function x(a) {\n\t        var c = P.getCursor(b);\n\t        a = a.paragraphElement;\n\t        c && S.getParagraphElement(c.getNode()) === a && U.reset()\n\t    }\n\t    function z(a, b) {\n\t        b(!a());\n\t        return !0\n\t    }\n\t    function w(a) {\n\t        if (q().directTextStyling) {\n\t            var c = P.getCursorSelection(b)\n\t              , d = {\n\t                \"style:text-properties\": a\n\t            };\n\t            0 !== c.length ? (a = new ops.OpApplyDirectStyling,\n\t            a.init({\n\t                memberid: b,\n\t                position: c.position,\n\t                length: c.length,\n\t                setProperties: d\n\t            }),\n\t            g.enqueue([a])) : (Z = aa.mergeObjects(Z || {}, d),\n\t            U.reset())\n\t        }\n\t    }\n\t    function v(a, b) {\n\t        var c = {};\n\t        c[a] = b;\n\t        w(c)\n\t    }\n\t    function u(a) {\n\t        a = a.spec();\n\t        Z && a.memberid === b && \"SplitParagraph\" !== a.optype && (Z = null,\n\t        U.reset())\n\t    }\n\t    function t(a) {\n\t        v(\"fo:font-weight\", a ? \"bold\" : \"normal\")\n\t    }\n\t    function A(a) {\n\t        v(\"fo:font-style\", a ? \"italic\" : \"normal\")\n\t    }\n\t    function I(a) {\n\t        v(\"style:text-underline-style\", a ? \"solid\" : \"none\")\n\t    }\n\t    function K(a) {\n\t        v(\"style:text-line-through-style\", a ? \"solid\" : \"none\")\n\t    }\n\t    function L(a) {\n\t        if (q().directParagraphStyling) {\n\t            var c = P.getCursor(b).getSelectedRange(), c = S.getParagraphElements(c), d = P.getFormatting(), e = [], h = {}, m;\n\t            c.forEach(function(c) {\n\t                var g = P.convertDomPointToCursorStep(c, 0, C), l = c.getAttributeNS(odf.Namespaces.textns, \"style-name\"), k;\n\t                c = l ? h.hasOwnProperty(l) ? h[l] : void 0 : m;\n\t                c || (c = f.generateStyleName(),\n\t                l ? (h[l] = c,\n\t                k = d.createDerivedStyleObject(l, \"paragraph\", {})) : (m = c,\n\t                k = {}),\n\t                k = a(k),\n\t                l = new ops.OpAddStyle,\n\t                l.init({\n\t                    memberid: b,\n\t                    styleName: c.toString(),\n\t                    styleFamily: \"paragraph\",\n\t                    isAutomaticStyle: !0,\n\t                    setProperties: k\n\t                }),\n\t                e.push(l));\n\t                l = new ops.OpSetParagraphStyle;\n\t                l.init({\n\t                    memberid: b,\n\t                    styleName: c.toString(),\n\t                    position: g\n\t                });\n\t                e.push(l)\n\t            });\n\t            g.enqueue(e)\n\t        }\n\t    }\n\t    function E(a) {\n\t        L(function(b) {\n\t            return aa.mergeObjects(b, a)\n\t        })\n\t    }\n\t    function N(a) {\n\t        E({\n\t            \"style:paragraph-properties\": {\n\t                \"fo:text-align\": a\n\t            }\n\t        })\n\t    }\n\t    function O(a, b) {\n\t        var c = P.getFormatting().getDefaultTabStopDistance(), d = b[\"style:paragraph-properties\"], e;\n\t        d && (d = d[\"fo:margin-left\"],\n\t        e = S.parseLength(d));\n\t        return aa.mergeObjects(b, {\n\t            \"style:paragraph-properties\": {\n\t                \"fo:margin-left\": e && e.unit === c.unit ? e.value + a * c.value + e.unit : a * c.value + c.unit\n\t            }\n\t        })\n\t    }\n\t    function D(a, b) {\n\t        var c = e(a)\n\t          , c = 0 === c.length ? [a.startContainer] : c\n\t          , c = P.getFormatting().getAppliedStyles(c)\n\t          , d = 0 < c.length ? c[0].styleProperties : void 0\n\t          , h = P.getFormatting().getAppliedStylesForElement(b).styleProperties;\n\t        if (!d || \"text\" !== d[\"style:family\"] || !d[\"style:text-properties\"])\n\t            return !1;\n\t        if (!h || !h[\"style:text-properties\"])\n\t            return !0;\n\t        d = d[\"style:text-properties\"];\n\t        h = h[\"style:text-properties\"];\n\t        return !Object.keys(d).every(function(a) {\n\t            return d[a] === h[a]\n\t        })\n\t    }\n\t    function V() {}\n\t    function W() {\n\t        return !1\n\t    }\n\t    function J() {\n\t        return !1\n\t    }\n\t    var R = this, P = g.getOdtDocument(), aa = new core.Utils, S = odf.OdfUtils, fa = new core.EventNotifier([gui.DirectFormattingController.enabledChanged, gui.DirectFormattingController.textStylingChanged, gui.DirectFormattingController.paragraphStylingChanged]), ha = odf.Namespaces.textns, C = core.StepDirection.NEXT, Z = null, ba, U;\n\t    this.enabledFeatures = q;\n\t    this.formatTextSelection = w;\n\t    this.createCursorStyleOp = function(a, c, d) {\n\t        var e = null\n\t          , h = Z;\n\t        d && (h = (d = U.value().appliedStyles[0]) && d.styleProperties);\n\t        h && h[\"style:text-properties\"] && (e = new ops.OpApplyDirectStyling,\n\t        e.init({\n\t            memberid: b,\n\t            position: a,\n\t            length: c,\n\t            setProperties: {\n\t                \"style:text-properties\": h[\"style:text-properties\"]\n\t            }\n\t        }),\n\t        Z = null,\n\t        U.reset());\n\t        return e\n\t    }\n\t    ;\n\t    this.setBold = t;\n\t    this.setItalic = A;\n\t    this.setHasUnderline = I;\n\t    this.setHasStrikethrough = K;\n\t    this.setFontSize = function(a) {\n\t        v(\"fo:font-size\", a + \"pt\")\n\t    }\n\t    ;\n\t    this.setFontName = function(a) {\n\t        v(\"style:font-name\", a)\n\t    }\n\t    ;\n\t    this.getAppliedStyles = function() {\n\t        return U.value().appliedStyles\n\t    }\n\t    ;\n\t    this.toggleBold = z.bind(R, function() {\n\t        return r().isBold()\n\t    }, t);\n\t    this.toggleItalic = z.bind(R, function() {\n\t        return r().isItalic()\n\t    }, A);\n\t    this.toggleUnderline = z.bind(R, function() {\n\t        return r().hasUnderline()\n\t    }, I);\n\t    this.toggleStrikethrough = z.bind(R, function() {\n\t        return r().hasStrikeThrough()\n\t    }, K);\n\t    this.isBold = function() {\n\t        return r().isBold()\n\t    }\n\t    ;\n\t    this.isItalic = function() {\n\t        return r().isItalic()\n\t    }\n\t    ;\n\t    this.hasUnderline = function() {\n\t        return r().hasUnderline()\n\t    }\n\t    ;\n\t    this.hasStrikeThrough = function() {\n\t        return r().hasStrikeThrough()\n\t    }\n\t    ;\n\t    this.fontSize = function() {\n\t        return r().fontSize()\n\t    }\n\t    ;\n\t    this.fontName = function() {\n\t        return r().fontName()\n\t    }\n\t    ;\n\t    this.isAlignedLeft = function() {\n\t        return r().isAlignedLeft()\n\t    }\n\t    ;\n\t    this.isAlignedCenter = function() {\n\t        return r().isAlignedCenter()\n\t    }\n\t    ;\n\t    this.isAlignedRight = function() {\n\t        return r().isAlignedRight()\n\t    }\n\t    ;\n\t    this.isAlignedJustified = function() {\n\t        return r().isAlignedJustified()\n\t    }\n\t    ;\n\t    this.alignParagraphLeft = function() {\n\t        N(\"left\");\n\t        return !0\n\t    }\n\t    ;\n\t    this.alignParagraphCenter = function() {\n\t        N(\"center\");\n\t        return !0\n\t    }\n\t    ;\n\t    this.alignParagraphRight = function() {\n\t        N(\"right\");\n\t        return !0\n\t    }\n\t    ;\n\t    this.alignParagraphJustified = function() {\n\t        N(\"justify\");\n\t        return !0\n\t    }\n\t    ;\n\t    this.indent = function() {\n\t        L(O.bind(null, 1));\n\t        return !0\n\t    }\n\t    ;\n\t    this.outdent = function() {\n\t        L(O.bind(null, -1));\n\t        return !0\n\t    }\n\t    ;\n\t    this.createParagraphStyleOps = function(a) {\n\t        if (!q().directParagraphStyling)\n\t            return [];\n\t        var c = P.getCursor(b), d = c.getSelectedRange(), e = [], h, g;\n\t        c.hasForwardSelection() ? (h = c.getAnchorNode(),\n\t        g = c.getNode()) : (h = c.getNode(),\n\t        g = c.getAnchorNode());\n\t        c = S.getParagraphElement(g);\n\t        runtime.assert(Boolean(c), \"DirectFormattingController: Cursor outside paragraph\");\n\t        var m = c\n\t          , l = [P.getPositionFilter(), P.createRootFilter(b)];\n\t        if (!1 !== P.createStepIterator(d.endContainer, d.endOffset, l, m).nextStep())\n\t            return e;\n\t        g !== h && (c = S.getParagraphElement(h));\n\t        if (!Z && !D(d, c))\n\t            return e;\n\t        d = (d = U.value().appliedStyles[0]) && d.styleProperties;\n\t        if (!d)\n\t            return e;\n\t        if (c = c.getAttributeNS(ha, \"style-name\"))\n\t            d = {\n\t                \"style:text-properties\": d[\"style:text-properties\"]\n\t            },\n\t            d = P.getFormatting().createDerivedStyleObject(c, \"paragraph\", d);\n\t        h = f.generateStyleName();\n\t        c = new ops.OpAddStyle;\n\t        c.init({\n\t            memberid: b,\n\t            styleName: h,\n\t            styleFamily: \"paragraph\",\n\t            isAutomaticStyle: !0,\n\t            setProperties: d\n\t        });\n\t        e.push(c);\n\t        c = new ops.OpSetParagraphStyle;\n\t        c.init({\n\t            memberid: b,\n\t            styleName: h,\n\t            position: a\n\t        });\n\t        e.push(c);\n\t        return e\n\t    }\n\t    ;\n\t    this.subscribe = function(a, c) {\n\t        fa.subscribe(a, c)\n\t    }\n\t    ;\n\t    this.unsubscribe = function(a, c) {\n\t        fa.unsubscribe(a, c)\n\t    }\n\t    ;\n\t    this.destroy = function(a) {\n\t        P.unsubscribe(ops.Document.signalCursorAdded, h);\n\t        P.unsubscribe(ops.Document.signalCursorRemoved, h);\n\t        P.unsubscribe(ops.Document.signalCursorMoved, h);\n\t        P.unsubscribe(ops.OdtDocument.signalParagraphStyleModified, y);\n\t        P.unsubscribe(ops.OdtDocument.signalParagraphChanged, x);\n\t        P.unsubscribe(ops.OdtDocument.signalOperationEnd, u);\n\t        P.unsubscribe(ops.OdtDocument.signalProcessingBatchEnd, c);\n\t        k.unsubscribe(gui.CommonConstraints.EDIT.REVIEW_MODE, m);\n\t        a()\n\t    }\n\t    ;\n\t    (function() {\n\t        P.subscribe(ops.Document.signalCursorAdded, h);\n\t        P.subscribe(ops.Document.signalCursorRemoved, h);\n\t        P.subscribe(ops.Document.signalCursorMoved, h);\n\t        P.subscribe(ops.OdtDocument.signalParagraphStyleModified, y);\n\t        P.subscribe(ops.OdtDocument.signalParagraphChanged, x);\n\t        P.subscribe(ops.OdtDocument.signalOperationEnd, u);\n\t        P.subscribe(ops.OdtDocument.signalProcessingBatchEnd, c);\n\t        k.subscribe(gui.CommonConstraints.EDIT.REVIEW_MODE, m);\n\t        U = new core.LazyProperty(l);\n\t        ba = U.value();\n\t        n || (R.formatTextSelection = V,\n\t        R.setBold = V,\n\t        R.setItalic = V,\n\t        R.setHasUnderline = V,\n\t        R.setHasStrikethrough = V,\n\t        R.setFontSize = V,\n\t        R.setFontName = V,\n\t        R.toggleBold = J,\n\t        R.toggleItalic = J,\n\t        R.toggleUnderline = J,\n\t        R.toggleStrikethrough = J);\n\t        p || (R.alignParagraphCenter = W,\n\t        R.alignParagraphJustified = W,\n\t        R.alignParagraphLeft = W,\n\t        R.alignParagraphRight = W,\n\t        R.createParagraphStyleOps = function() {\n\t            return []\n\t        }\n\t        ,\n\t        R.indent = W,\n\t        R.outdent = W)\n\t    }\n\t    )()\n\t}\n\t;\n\tgui.DirectFormattingController.enabledChanged = \"enabled/changed\";\n\tgui.DirectFormattingController.textStylingChanged = \"textStyling/changed\";\n\tgui.DirectFormattingController.paragraphStylingChanged = \"paragraphStyling/changed\";\n\tgui.DirectFormattingController.SelectionInfo = function() {}\n\t;\n\tgui.KeyboardHandler = function() {\n\t    function g(b, d) {\n\t        d || (d = k.None);\n\t        switch (b) {\n\t        case gui.KeyboardHandler.KeyCode.LeftMeta:\n\t        case gui.KeyboardHandler.KeyCode.RightMeta:\n\t        case gui.KeyboardHandler.KeyCode.MetaInMozilla:\n\t            d |= k.Meta;\n\t            break;\n\t        case gui.KeyboardHandler.KeyCode.Ctrl:\n\t            d |= k.Ctrl;\n\t            break;\n\t        case gui.KeyboardHandler.KeyCode.Alt:\n\t            d |= k.Alt;\n\t            break;\n\t        case gui.KeyboardHandler.KeyCode.Shift:\n\t            d |= k.Shift\n\t        }\n\t        return b + \":\" + d\n\t    }\n\t    var k = gui.KeyboardHandler.Modifier\n\t      , d = null\n\t      , b = {};\n\t    this.setDefault = function(b) {\n\t        d = b\n\t    }\n\t    ;\n\t    this.bind = function(d, k, p, r) {\n\t        d = g(d, k);\n\t        runtime.assert(r || !1 === b.hasOwnProperty(d), \"tried to overwrite the callback handler of key combo: \" + d);\n\t        b[d] = p\n\t    }\n\t    ;\n\t    this.unbind = function(d, k) {\n\t        var p = g(d, k);\n\t        delete b[p]\n\t    }\n\t    ;\n\t    this.reset = function() {\n\t        d = null;\n\t        b = {}\n\t    }\n\t    ;\n\t    this.handleEvent = function(f) {\n\t        var n = f.keyCode\n\t          , p = k.None;\n\t        f.metaKey && (p |= k.Meta);\n\t        f.ctrlKey && (p |= k.Ctrl);\n\t        f.altKey && (p |= k.Alt);\n\t        f.shiftKey && (p |= k.Shift);\n\t        n = g(n, p);\n\t        n = b[n];\n\t        p = !1;\n\t        n ? p = n() : null !== d && (p = d(f));\n\t        p && (f.preventDefault ? f.preventDefault() : f.returnValue = !1)\n\t    }\n\t}\n\t;\n\tgui.KeyboardHandler.Modifier = {\n\t    None: 0,\n\t    Meta: 1,\n\t    Ctrl: 2,\n\t    Alt: 4,\n\t    CtrlAlt: 6,\n\t    Shift: 8,\n\t    MetaShift: 9,\n\t    CtrlShift: 10,\n\t    AltShift: 12\n\t};\n\tgui.KeyboardHandler.KeyCode = {\n\t    Backspace: 8,\n\t    Tab: 9,\n\t    Clear: 12,\n\t    Enter: 13,\n\t    Shift: 16,\n\t    Ctrl: 17,\n\t    Alt: 18,\n\t    End: 35,\n\t    Home: 36,\n\t    Left: 37,\n\t    Up: 38,\n\t    Right: 39,\n\t    Down: 40,\n\t    Delete: 46,\n\t    A: 65,\n\t    B: 66,\n\t    C: 67,\n\t    D: 68,\n\t    E: 69,\n\t    F: 70,\n\t    G: 71,\n\t    H: 72,\n\t    I: 73,\n\t    J: 74,\n\t    K: 75,\n\t    L: 76,\n\t    M: 77,\n\t    N: 78,\n\t    O: 79,\n\t    P: 80,\n\t    Q: 81,\n\t    R: 82,\n\t    S: 83,\n\t    T: 84,\n\t    U: 85,\n\t    V: 86,\n\t    W: 87,\n\t    X: 88,\n\t    Y: 89,\n\t    Z: 90,\n\t    LeftMeta: 91,\n\t    RightMeta: 93,\n\t    MetaInMozilla: 224\n\t};\n\tgui.HyperlinkClickHandler = function(g, k, d) {\n\t    function b() {\n\t        var a = g();\n\t        runtime.assert(Boolean(a.classList), \"Document container has no classList element\");\n\t        a.classList.remove(\"webodf-inactiveLinks\")\n\t    }\n\t    function f() {\n\t        var a = g();\n\t        runtime.assert(Boolean(a.classList), \"Document container has no classList element\");\n\t        a.classList.add(\"webodf-inactiveLinks\")\n\t    }\n\t    function n() {\n\t        a.removeEventListener(\"focus\", f, !1);\n\t        m.forEach(function(a) {\n\t            k.unbind(a.keyCode, a.modifier);\n\t            d.unbind(a.keyCode, a.modifier)\n\t        });\n\t        m.length = 0\n\t    }\n\t    function p(c) {\n\t        n();\n\t        if (c !== r.None) {\n\t            a.addEventListener(\"focus\", f, !1);\n\t            switch (c) {\n\t            case r.Ctrl:\n\t                m.push({\n\t                    keyCode: q.Ctrl,\n\t                    modifier: r.None\n\t                });\n\t                break;\n\t            case r.Meta:\n\t                m.push({\n\t                    keyCode: q.LeftMeta,\n\t                    modifier: r.None\n\t                }),\n\t                m.push({\n\t                    keyCode: q.RightMeta,\n\t                    modifier: r.None\n\t                }),\n\t                m.push({\n\t                    keyCode: q.MetaInMozilla,\n\t                    modifier: r.None\n\t                })\n\t            }\n\t            m.forEach(function(a) {\n\t                k.bind(a.keyCode, a.modifier, b);\n\t                d.bind(a.keyCode, a.modifier, f)\n\t            })\n\t        }\n\t    }\n\t    var r = gui.KeyboardHandler.Modifier\n\t      , q = gui.KeyboardHandler.KeyCode\n\t      , e = xmldom.XPath\n\t      , l = odf.OdfUtils\n\t      , a = runtime.getWindow()\n\t      , c = r.None\n\t      , m = [];\n\t    runtime.assert(null !== a, \"Expected to be run in an environment which has a global window, like a browser.\");\n\t    this.handleClick = function(b) {\n\t        var d = b.target || b.srcElement, f, m;\n\t        b.ctrlKey ? f = r.Ctrl : b.metaKey && (f = r.Meta);\n\t        if (c === r.None || c === f) {\n\t            a: {\n\t                for (; null !== d; ) {\n\t                    if (l.isHyperlink(d))\n\t                        break a;\n\t                    if (l.isParagraph(d))\n\t                        break;\n\t                    d = d.parentNode\n\t                }\n\t                d = null\n\t            }\n\t            d && (d = l.getHyperlinkTarget(d),\n\t            \"\" !== d && (\"#\" === d[0] ? (d = d.substring(1),\n\t            f = g(),\n\t            m = e.getODFElementsWithXPath(f, \"//text:bookmark-start[@text:name='\" + d + \"']\", odf.Namespaces.lookupNamespaceURI),\n\t            0 === m.length && (m = e.getODFElementsWithXPath(f, \"//text:bookmark[@text:name='\" + d + \"']\", odf.Namespaces.lookupNamespaceURI)),\n\t            0 < m.length && m[0].scrollIntoView(!0)) : /^\\s*(javascript|data):/.test(d) ? runtime.log(\"WARN:\", \"potentially malicious URL ignored\") : a.open(d),\n\t            b.preventDefault ? b.preventDefault() : b.returnValue = !1))\n\t        }\n\t    }\n\t    ;\n\t    this.setModifier = function(a) {\n\t        c !== a && (runtime.assert(a === r.None || a === r.Ctrl || a === r.Meta, \"Unsupported KeyboardHandler.Modifier value: \" + a),\n\t        c = a,\n\t        c !== r.None ? f() : b(),\n\t        p(c))\n\t    }\n\t    ;\n\t    this.getModifier = function() {\n\t        return c\n\t    }\n\t    ;\n\t    this.destroy = function(a) {\n\t        f();\n\t        n();\n\t        a()\n\t    }\n\t}\n\t;\n\tgui.EventManager = function(g) {\n\t    function k(a) {\n\t        function b(a, c, d) {\n\t            var e, h = !1;\n\t            e = \"on\" + c;\n\t            a.attachEvent && (a.attachEvent(e, d),\n\t            h = !0);\n\t            !h && a.addEventListener && (a.addEventListener(c, d, !1),\n\t            h = !0);\n\t            h && !u[c] || !a.hasOwnProperty(e) || (a[e] = d)\n\t        }\n\t        function c(a, b, d) {\n\t            var e = \"on\" + b;\n\t            a.detachEvent && a.detachEvent(e, d);\n\t            a.removeEventListener && a.removeEventListener(b, d, !1);\n\t            a[e] === d && (a[e] = null)\n\t        }\n\t        function d(c) {\n\t            if (-1 === h.indexOf(c)) {\n\t                h.push(c);\n\t                if (e.filters.every(function(a) {\n\t                    return a(c)\n\t                }))\n\t                    try {\n\t                        f.emit(a, c)\n\t                    } catch (b) {\n\t                        runtime.log(\"Error occurred while processing \" + a + \":\\n\" + b.message + \"\\n\" + b.stack)\n\t                    }\n\t                runtime.setTimeout(function() {\n\t                    h.splice(h.indexOf(c), 1)\n\t                }, 0)\n\t            }\n\t        }\n\t        var e = this\n\t          , h = []\n\t          , f = new core.EventNotifier([a]);\n\t        this.filters = [];\n\t        this.subscribe = function(c) {\n\t            f.subscribe(a, c)\n\t        }\n\t        ;\n\t        this.unsubscribe = function(c) {\n\t            f.unsubscribe(a, c)\n\t        }\n\t        ;\n\t        this.destroy = function() {\n\t            c(v, a, d);\n\t            c(K, a, d);\n\t            c(L, a, d)\n\t        }\n\t        ;\n\t        t[a] && b(v, a, d);\n\t        b(K, a, d);\n\t        b(L, a, d)\n\t    }\n\t    function d(a, c, b) {\n\t        function d(c) {\n\t            b(c, e, function(c) {\n\t                c.type = a;\n\t                h.emit(a, c)\n\t            })\n\t        }\n\t        var e = {}\n\t          , h = new core.EventNotifier([a]);\n\t        this.subscribe = function(c) {\n\t            h.subscribe(a, c)\n\t        }\n\t        ;\n\t        this.unsubscribe = function(c) {\n\t            h.unsubscribe(a, c)\n\t        }\n\t        ;\n\t        this.destroy = function() {\n\t            c.forEach(function(a) {\n\t                E.unsubscribe(a, d)\n\t            })\n\t        }\n\t        ;\n\t        (function() {\n\t            c.forEach(function(a) {\n\t                E.subscribe(a, d)\n\t            })\n\t        }\n\t        )()\n\t    }\n\t    function b(a) {\n\t        runtime.clearTimeout(a);\n\t        delete N[a]\n\t    }\n\t    function f(a, c) {\n\t        var d = runtime.setTimeout(function() {\n\t            a();\n\t            b(d)\n\t        }, c);\n\t        N[d] = !0;\n\t        return d\n\t    }\n\t    function n(a, c, d) {\n\t        var e = a.touches.length\n\t          , h = a.touches[0]\n\t          , g = c.timer;\n\t        \"touchmove\" === a.type || \"touchend\" === a.type ? g && b(g) : \"touchstart\" === a.type && (1 !== e ? runtime.clearTimeout(g) : g = f(function() {\n\t            d({\n\t                clientX: h.clientX,\n\t                clientY: h.clientY,\n\t                pageX: h.pageX,\n\t                pageY: h.pageY,\n\t                target: a.target || a.srcElement || null,\n\t                detail: 1\n\t            })\n\t        }, 400));\n\t        c.timer = g\n\t    }\n\t    function p(a, c, b) {\n\t        var d = a.touches[0]\n\t          , e = a.target || a.srcElement || null\n\t          , h = c.target;\n\t        1 !== a.touches.length || \"touchend\" === a.type ? h = null : \"touchstart\" === a.type && \"webodf-draggable\" === e.getAttribute(\"class\") ? h = e : \"touchmove\" === a.type && h && (a.preventDefault(),\n\t        a.stopPropagation(),\n\t        b({\n\t            clientX: d.clientX,\n\t            clientY: d.clientY,\n\t            pageX: d.pageX,\n\t            pageY: d.pageY,\n\t            target: h,\n\t            detail: 1\n\t        }));\n\t        c.target = h\n\t    }\n\t    function r(a, c, b) {\n\t        var d = a.target || a.srcElement || null\n\t          , e = c.dragging;\n\t        \"drag\" === a.type ? e = !0 : \"touchend\" === a.type && e && (e = !1,\n\t        a = a.changedTouches[0],\n\t        b({\n\t            clientX: a.clientX,\n\t            clientY: a.clientY,\n\t            pageX: a.pageX,\n\t            pageY: a.pageY,\n\t            target: d,\n\t            detail: 1\n\t        }));\n\t        c.dragging = e\n\t    }\n\t    function q() {\n\t        L.classList.add(\"webodf-touchEnabled\");\n\t        E.unsubscribe(\"touchstart\", q)\n\t    }\n\t    function e(a) {\n\t        var c = a.scrollX\n\t          , b = a.scrollY;\n\t        this.restore = function() {\n\t            a.scrollX === c && a.scrollY === b || a.scrollTo(c, b)\n\t        }\n\t    }\n\t    function l(a) {\n\t        var c = a.scrollTop\n\t          , b = a.scrollLeft;\n\t        this.restore = function() {\n\t            if (a.scrollTop !== c || a.scrollLeft !== b)\n\t                a.scrollTop = c,\n\t                a.scrollLeft = b\n\t        }\n\t    }\n\t    function a(a, c) {\n\t        var b = I[a] || A[a] || null;\n\t        !b && c && (b = I[a] = new k(a));\n\t        return b\n\t    }\n\t    function c(c, b) {\n\t        a(c, !0).subscribe(b)\n\t    }\n\t    function m(c, b) {\n\t        var d = a(c, !1);\n\t        d && d.unsubscribe(b)\n\t    }\n\t    function h() {\n\t        return g.getDOMDocument().activeElement === K\n\t    }\n\t    function y() {\n\t        h() && K.blur();\n\t        K.setAttribute(\"disabled\", \"true\")\n\t    }\n\t    function x() {\n\t        K.removeAttribute(\"disabled\")\n\t    }\n\t    function z(a) {\n\t        for (var c = []; a; )\n\t            (a.scrollWidth > a.clientWidth || a.scrollHeight > a.clientHeight) && c.push(new l(a)),\n\t            a = a.parentNode;\n\t        c.push(new e(v));\n\t        return c\n\t    }\n\t    function w() {\n\t        var a;\n\t        h() || (a = z(K),\n\t        x(),\n\t        K.focus(),\n\t        a.forEach(function(a) {\n\t            a.restore()\n\t        }))\n\t    }\n\t    var v = runtime.getWindow(), u = {\n\t        beforecut: !0,\n\t        beforepaste: !0,\n\t        longpress: !0,\n\t        drag: !0,\n\t        dragstop: !0\n\t    }, t = {\n\t        mousedown: !0,\n\t        mouseup: !0,\n\t        focus: !0\n\t    }, A = {}, I = {}, K, L = g.getCanvas().getElement(), E = this, N = {};\n\t    this.addFilter = function(c, b) {\n\t        a(c, !0).filters.push(b)\n\t    }\n\t    ;\n\t    this.removeFilter = function(c, b) {\n\t        var d = a(c, !0)\n\t          , e = d.filters.indexOf(b);\n\t        -1 !== e && d.filters.splice(e, 1)\n\t    }\n\t    ;\n\t    this.subscribe = c;\n\t    this.unsubscribe = m;\n\t    this.hasFocus = h;\n\t    this.focus = w;\n\t    this.getEventTrap = function() {\n\t        return K\n\t    }\n\t    ;\n\t    this.setEditing = function(a) {\n\t        var c = h();\n\t        c && K.blur();\n\t        a ? K.removeAttribute(\"readOnly\") : K.setAttribute(\"readOnly\", \"true\");\n\t        c && w()\n\t    }\n\t    ;\n\t    this.destroy = function(a) {\n\t        m(\"touchstart\", q);\n\t        Object.keys(N).forEach(function(a) {\n\t            b(parseInt(a, 10))\n\t        });\n\t        N.length = 0;\n\t        Object.keys(A).forEach(function(a) {\n\t            A[a].destroy()\n\t        });\n\t        A = {};\n\t        m(\"mousedown\", y);\n\t        m(\"mouseup\", x);\n\t        m(\"contextmenu\", x);\n\t        Object.keys(I).forEach(function(a) {\n\t            I[a].destroy()\n\t        });\n\t        I = {};\n\t        K.parentNode.removeChild(K);\n\t        a()\n\t    }\n\t    ;\n\t    (function() {\n\t        var a = g.getOdfCanvas().getSizer()\n\t          , b = a.ownerDocument;\n\t        runtime.assert(Boolean(v), \"EventManager requires a window object to operate correctly\");\n\t        K = b.createElement(\"textarea\");\n\t        K.id = \"eventTrap\";\n\t        K.setAttribute(\"tabindex\", \"-1\");\n\t        K.setAttribute(\"readOnly\", \"true\");\n\t        K.setAttribute(\"rows\", \"1\");\n\t        a.appendChild(K);\n\t        c(\"mousedown\", y);\n\t        c(\"mouseup\", x);\n\t        c(\"contextmenu\", x);\n\t        A.longpress = new d(\"longpress\",[\"touchstart\", \"touchmove\", \"touchend\"],n);\n\t        A.drag = new d(\"drag\",[\"touchstart\", \"touchmove\", \"touchend\"],p);\n\t        A.dragstop = new d(\"dragstop\",[\"drag\", \"touchend\"],r);\n\t        c(\"touchstart\", q)\n\t    }\n\t    )()\n\t}\n\t;\n\tgui.IOSSafariSupport = function(g) {\n\t    function k() {\n\t        d.innerHeight !== d.outerHeight && (b.style.display = \"none\",\n\t        runtime.requestAnimationFrame(function() {\n\t            b.style.display = \"block\"\n\t        }))\n\t    }\n\t    var d = runtime.getWindow()\n\t      , b = g.getEventTrap();\n\t    this.destroy = function(d) {\n\t        g.unsubscribe(\"focus\", k);\n\t        b.removeAttribute(\"autocapitalize\");\n\t        b.style.WebkitTransform = \"\";\n\t        d()\n\t    }\n\t    ;\n\t    g.subscribe(\"focus\", k);\n\t    b.setAttribute(\"autocapitalize\", \"off\");\n\t    b.style.WebkitTransform = \"translateX(-10000px)\"\n\t}\n\t;\n\tgui.HyperlinkController = function(g, k, d, b) {\n\t    function f() {\n\t        var b = !0;\n\t        !0 === k.getState(gui.CommonConstraints.EDIT.REVIEW_MODE) && (b = d.isLocalCursorWithinOwnAnnotation());\n\t        b !== e && (e = b,\n\t        q.emit(gui.HyperlinkController.enabledChanged, e))\n\t    }\n\t    function n(d) {\n\t        d.getMemberId() === b && f()\n\t    }\n\t    var p = odf.OdfUtils\n\t      , r = g.getOdtDocument()\n\t      , q = new core.EventNotifier([gui.HyperlinkController.enabledChanged])\n\t      , e = !1;\n\t    this.isEnabled = function() {\n\t        return e\n\t    }\n\t    ;\n\t    this.subscribe = function(b, a) {\n\t        q.subscribe(b, a)\n\t    }\n\t    ;\n\t    this.unsubscribe = function(b, a) {\n\t        q.unsubscribe(b, a)\n\t    }\n\t    ;\n\t    this.addHyperlink = function(d, a) {\n\t        if (e) {\n\t            var c = r.getCursorSelection(b)\n\t              , f = new ops.OpApplyHyperlink\n\t              , h = [];\n\t            if (0 === c.length || a)\n\t                a = a || d,\n\t                f = new ops.OpInsertText,\n\t                f.init({\n\t                    memberid: b,\n\t                    position: c.position,\n\t                    text: a\n\t                }),\n\t                c.length = a.length,\n\t                h.push(f);\n\t            f = new ops.OpApplyHyperlink;\n\t            f.init({\n\t                memberid: b,\n\t                position: c.position,\n\t                length: c.length,\n\t                hyperlink: d\n\t            });\n\t            h.push(f);\n\t            g.enqueue(h)\n\t        }\n\t    }\n\t    ;\n\t    this.removeHyperlinks = function() {\n\t        if (e) {\n\t            var d = r.createPositionIterator(r.getRootNode()), a = r.getCursor(b).getSelectedRange(), c = p.getHyperlinkElements(a), f = a.collapsed && 1 === c.length, h = r.getDOMDocument().createRange(), k = [], n, q;\n\t            0 !== c.length && (c.forEach(function(a) {\n\t                h.selectNodeContents(a);\n\t                n = r.convertDomToCursorRange({\n\t                    anchorNode: h.startContainer,\n\t                    anchorOffset: h.startOffset,\n\t                    focusNode: h.endContainer,\n\t                    focusOffset: h.endOffset\n\t                });\n\t                q = new ops.OpRemoveHyperlink;\n\t                q.init({\n\t                    memberid: b,\n\t                    position: n.position,\n\t                    length: n.length\n\t                });\n\t                k.push(q)\n\t            }),\n\t            f || (f = c[0],\n\t            -1 === a.comparePoint(f, 0) && (h.setStart(f, 0),\n\t            h.setEnd(a.startContainer, a.startOffset),\n\t            n = r.convertDomToCursorRange({\n\t                anchorNode: h.startContainer,\n\t                anchorOffset: h.startOffset,\n\t                focusNode: h.endContainer,\n\t                focusOffset: h.endOffset\n\t            }),\n\t            0 < n.length && (q = new ops.OpApplyHyperlink,\n\t            q.init({\n\t                memberid: b,\n\t                position: n.position,\n\t                length: n.length,\n\t                hyperlink: p.getHyperlinkTarget(f)\n\t            }),\n\t            k.push(q))),\n\t            c = c[c.length - 1],\n\t            d.moveToEndOfNode(c),\n\t            d = d.unfilteredDomOffset(),\n\t            1 === a.comparePoint(c, d) && (h.setStart(a.endContainer, a.endOffset),\n\t            h.setEnd(c, d),\n\t            n = r.convertDomToCursorRange({\n\t                anchorNode: h.startContainer,\n\t                anchorOffset: h.startOffset,\n\t                focusNode: h.endContainer,\n\t                focusOffset: h.endOffset\n\t            }),\n\t            0 < n.length && (q = new ops.OpApplyHyperlink,\n\t            q.init({\n\t                memberid: b,\n\t                position: n.position,\n\t                length: n.length,\n\t                hyperlink: p.getHyperlinkTarget(c)\n\t            }),\n\t            k.push(q)))),\n\t            g.enqueue(k),\n\t            h.detach())\n\t        }\n\t    }\n\t    ;\n\t    this.destroy = function(b) {\n\t        r.unsubscribe(ops.Document.signalCursorMoved, n);\n\t        k.unsubscribe(gui.CommonConstraints.EDIT.REVIEW_MODE, f);\n\t        b()\n\t    }\n\t    ;\n\t    r.subscribe(ops.Document.signalCursorMoved, n);\n\t    k.subscribe(gui.CommonConstraints.EDIT.REVIEW_MODE, f);\n\t    f()\n\t}\n\t;\n\tgui.HyperlinkController.enabledChanged = \"enabled/changed\";\n\tgui.ImageController = function(g, k, d, b, f) {\n\t    function n() {\n\t        var a = !0;\n\t        !0 === k.getState(gui.CommonConstraints.EDIT.REVIEW_MODE) && (a = d.isLocalCursorWithinOwnAnnotation());\n\t        a !== m && (m = a,\n\t        c.emit(gui.ImageController.enabledChanged, m))\n\t    }\n\t    function p(a) {\n\t        a.getMemberId() === b && n()\n\t    }\n\t    var r = {\n\t        \"image/gif\": \".gif\",\n\t        \"image/jpeg\": \".jpg\",\n\t        \"image/png\": \".png\"\n\t    }\n\t      , q = odf.Namespaces.textns\n\t      , e = g.getOdtDocument()\n\t      , l = odf.OdfUtils\n\t      , a = e.getFormatting()\n\t      , c = new core.EventNotifier([gui.HyperlinkController.enabledChanged])\n\t      , m = !1;\n\t    this.isEnabled = function() {\n\t        return m\n\t    }\n\t    ;\n\t    this.subscribe = function(a, b) {\n\t        c.subscribe(a, b)\n\t    }\n\t    ;\n\t    this.unsubscribe = function(a, b) {\n\t        c.unsubscribe(a, b)\n\t    }\n\t    ;\n\t    this.insertImage = function(c, d, k, n) {\n\t        if (m) {\n\t            var p = new core.CSSUnits;\n\t            runtime.assert(0 < k && 0 < n, \"Both width and height of the image should be greater than 0px.\");\n\t            n = {\n\t                width: k,\n\t                height: n\n\t            };\n\t            if (k = l.getParagraphElement(e.getCursor(b).getNode()).getAttributeNS(q, \"style-name\")) {\n\t                k = a.getContentSize(k, \"paragraph\");\n\t                var v = 1\n\t                  , u = 1;\n\t                n.width > k.width && (v = k.width / n.width);\n\t                n.height > k.height && (u = k.height / n.height);\n\t                k = Math.min(v, u);\n\t                n = {\n\t                    width: n.width * k,\n\t                    height: n.height * k\n\t                }\n\t            }\n\t            k = p.convert(n.width, \"px\", \"cm\") + \"cm\";\n\t            p = p.convert(n.height, \"px\", \"cm\") + \"cm\";\n\t            u = e.getOdfCanvas().odfContainer().rootElement.styles;\n\t            n = c.toLowerCase();\n\t            var v = r.hasOwnProperty(n) ? r[n] : null, t;\n\t            n = [];\n\t            runtime.assert(null !== v, \"Image type is not supported: \" + c);\n\t            v = \"Pictures/\" + f.generateImageName() + v;\n\t            t = new ops.OpSetBlob;\n\t            t.init({\n\t                memberid: b,\n\t                filename: v,\n\t                mimetype: c,\n\t                content: d\n\t            });\n\t            n.push(t);\n\t            a.getStyleElement(\"Graphics\", \"graphic\", [u]) || (c = new ops.OpAddStyle,\n\t            c.init({\n\t                memberid: b,\n\t                styleName: \"Graphics\",\n\t                styleFamily: \"graphic\",\n\t                isAutomaticStyle: !1,\n\t                setProperties: {\n\t                    \"style:graphic-properties\": {\n\t                        \"text:anchor-type\": \"paragraph\",\n\t                        \"svg:x\": \"0cm\",\n\t                        \"svg:y\": \"0cm\",\n\t                        \"style:wrap\": \"dynamic\",\n\t                        \"style:number-wrapped-paragraphs\": \"no-limit\",\n\t                        \"style:wrap-contour\": \"false\",\n\t                        \"style:vertical-pos\": \"top\",\n\t                        \"style:vertical-rel\": \"paragraph\",\n\t                        \"style:horizontal-pos\": \"center\",\n\t                        \"style:horizontal-rel\": \"paragraph\"\n\t                    }\n\t                }\n\t            }),\n\t            n.push(c));\n\t            c = f.generateStyleName();\n\t            d = new ops.OpAddStyle;\n\t            d.init({\n\t                memberid: b,\n\t                styleName: c,\n\t                styleFamily: \"graphic\",\n\t                isAutomaticStyle: !0,\n\t                setProperties: {\n\t                    \"style:parent-style-name\": \"Graphics\",\n\t                    \"style:graphic-properties\": {\n\t                        \"style:vertical-pos\": \"top\",\n\t                        \"style:vertical-rel\": \"baseline\",\n\t                        \"style:horizontal-pos\": \"center\",\n\t                        \"style:horizontal-rel\": \"paragraph\",\n\t                        \"fo:background-color\": \"transparent\",\n\t                        \"style:background-transparency\": \"100%\",\n\t                        \"style:shadow\": \"none\",\n\t                        \"style:mirror\": \"none\",\n\t                        \"fo:clip\": \"rect(0cm, 0cm, 0cm, 0cm)\",\n\t                        \"draw:luminance\": \"0%\",\n\t                        \"draw:contrast\": \"0%\",\n\t                        \"draw:red\": \"0%\",\n\t                        \"draw:green\": \"0%\",\n\t                        \"draw:blue\": \"0%\",\n\t                        \"draw:gamma\": \"100%\",\n\t                        \"draw:color-inversion\": \"false\",\n\t                        \"draw:image-opacity\": \"100%\",\n\t                        \"draw:color-mode\": \"standard\"\n\t                    }\n\t                }\n\t            });\n\t            n.push(d);\n\t            t = new ops.OpInsertImage;\n\t            t.init({\n\t                memberid: b,\n\t                position: e.getCursorPosition(b),\n\t                filename: v,\n\t                frameWidth: k,\n\t                frameHeight: p,\n\t                frameStyleName: c,\n\t                frameName: f.generateFrameName()\n\t            });\n\t            n.push(t);\n\t            g.enqueue(n)\n\t        }\n\t    }\n\t    ;\n\t    this.destroy = function(a) {\n\t        e.unsubscribe(ops.Document.signalCursorMoved, p);\n\t        k.unsubscribe(gui.CommonConstraints.EDIT.REVIEW_MODE, n);\n\t        a()\n\t    }\n\t    ;\n\t    e.subscribe(ops.Document.signalCursorMoved, p);\n\t    k.subscribe(gui.CommonConstraints.EDIT.REVIEW_MODE, n);\n\t    n()\n\t}\n\t;\n\tgui.ImageController.enabledChanged = \"enabled/changed\";\n\tgui.ImageSelector = function(g) {\n\t    function k() {\n\t        var d = g.getSizer()\n\t          , k = f.createElement(\"div\");\n\t        k.id = \"imageSelector\";\n\t        k.style.borderWidth = \"1px\";\n\t        d.appendChild(k);\n\t        b.forEach(function(b) {\n\t            var d = f.createElement(\"div\");\n\t            d.className = b;\n\t            k.appendChild(d)\n\t        });\n\t        return k\n\t    }\n\t    var d = odf.Namespaces.svgns\n\t      , b = \"topLeft topRight bottomRight bottomLeft topMiddle rightMiddle bottomMiddle leftMiddle\".split(\" \")\n\t      , f = g.getElement().ownerDocument\n\t      , n = !1;\n\t    this.select = function(b) {\n\t        var r, q, e = f.getElementById(\"imageSelector\");\n\t        e || (e = k());\n\t        n = !0;\n\t        r = e.parentNode;\n\t        q = b.getBoundingClientRect();\n\t        var l = r.getBoundingClientRect()\n\t          , a = g.getZoomLevel();\n\t        r = (q.left - l.left) / a - 1;\n\t        q = (q.top - l.top) / a - 1;\n\t        e.style.display = \"block\";\n\t        e.style.left = r + \"px\";\n\t        e.style.top = q + \"px\";\n\t        e.style.width = b.getAttributeNS(d, \"width\");\n\t        e.style.height = b.getAttributeNS(d, \"height\")\n\t    }\n\t    ;\n\t    this.clearSelection = function() {\n\t        var b;\n\t        n && (b = f.getElementById(\"imageSelector\")) && (b.style.display = \"none\");\n\t        n = !1\n\t    }\n\t    ;\n\t    this.isSelectorElement = function(b) {\n\t        var d = f.getElementById(\"imageSelector\");\n\t        return d ? b === d || b.parentNode === d : !1\n\t    }\n\t}\n\t;\n\t(function() {\n\t    function g(g) {\n\t        function d(b) {\n\t            p = b.which && String.fromCharCode(b.which) === n;\n\t            n = void 0;\n\t            return !1 === p\n\t        }\n\t        function b() {\n\t            p = !1\n\t        }\n\t        function f(b) {\n\t            n = b.data;\n\t            p = !1\n\t        }\n\t        var n, p = !1;\n\t        this.destroy = function(n) {\n\t            g.unsubscribe(\"textInput\", b);\n\t            g.unsubscribe(\"compositionend\", f);\n\t            g.removeFilter(\"keypress\", d);\n\t            n()\n\t        }\n\t        ;\n\t        g.subscribe(\"textInput\", b);\n\t        g.subscribe(\"compositionend\", f);\n\t        g.addFilter(\"keypress\", d)\n\t    }\n\t    gui.InputMethodEditor = function(k, d) {\n\t        function b(c) {\n\t            a && (c ? a.getNode().setAttributeNS(\"urn:webodf:names:cursor\", \"composing\", \"true\") : (a.getNode().removeAttributeNS(\"urn:webodf:names:cursor\", \"composing\"),\n\t            h.textContent = \"\"))\n\t        }\n\t        function f() {\n\t            x && (x = !1,\n\t            b(!1),\n\t            w.emit(gui.InputMethodEditor.signalCompositionEnd, {\n\t                data: z\n\t            }),\n\t            z = \"\")\n\t        }\n\t        function n() {\n\t            I || (I = !0,\n\t            f(),\n\t            a && a.getSelectedRange().collapsed ? c.value = \"\" : c.value = u.writeToString(a.getSelectedRange().cloneContents()),\n\t            c.setSelectionRange(0, c.value.length),\n\t            I = !1)\n\t        }\n\t        function p() {\n\t            d.hasFocus() && y.trigger()\n\t        }\n\t        function r() {\n\t            v = void 0;\n\t            y.cancel();\n\t            b(!0);\n\t            x || w.emit(gui.InputMethodEditor.signalCompositionStart, {\n\t                data: \"\"\n\t            })\n\t        }\n\t        function q(a) {\n\t            a = v = a.data;\n\t            x = !0;\n\t            z += a;\n\t            y.trigger()\n\t        }\n\t        function e(a) {\n\t            a.data !== v && (a = a.data,\n\t            x = !0,\n\t            z += a,\n\t            y.trigger());\n\t            v = void 0\n\t        }\n\t        function l() {\n\t            h.textContent = c.value\n\t        }\n\t        var a = null, c = d.getEventTrap(), m = c.ownerDocument, h, y, x = !1, z = \"\", w = new core.EventNotifier([gui.InputMethodEditor.signalCompositionStart, gui.InputMethodEditor.signalCompositionEnd]), v, u, t = [], A, I = !1;\n\t        this.subscribe = w.subscribe;\n\t        this.unsubscribe = w.unsubscribe;\n\t        this.registerCursor = function(c) {\n\t            c.getMemberId() === k && (a = c,\n\t            a.getNode().appendChild(h),\n\t            c.subscribe(ops.OdtCursor.signalCursorUpdated, p),\n\t            d.subscribe(\"input\", l),\n\t            d.subscribe(\"compositionupdate\", l))\n\t        }\n\t        ;\n\t        this.removeCursor = function(c) {\n\t            a && c === k && (a.getNode().removeChild(h),\n\t            a.unsubscribe(ops.OdtCursor.signalCursorUpdated, p),\n\t            d.unsubscribe(\"input\", l),\n\t            d.unsubscribe(\"compositionupdate\", l),\n\t            a = null)\n\t        }\n\t        ;\n\t        this.destroy = function(a) {\n\t            d.unsubscribe(\"compositionstart\", r);\n\t            d.unsubscribe(\"compositionend\", q);\n\t            d.unsubscribe(\"textInput\", e);\n\t            d.unsubscribe(\"keypress\", f);\n\t            d.unsubscribe(\"focus\", n);\n\t            core.Async.destroyAll(A, a)\n\t        }\n\t        ;\n\t        (function() {\n\t            u = new odf.TextSerializer;\n\t            u.filter = new odf.OdfNodeFilter;\n\t            d.subscribe(\"compositionstart\", r);\n\t            d.subscribe(\"compositionend\", q);\n\t            d.subscribe(\"textInput\", e);\n\t            d.subscribe(\"keypress\", f);\n\t            d.subscribe(\"focus\", n);\n\t            t.push(new g(d));\n\t            A = t.map(function(a) {\n\t                return a.destroy\n\t            });\n\t            h = m.createElement(\"span\");\n\t            h.setAttribute(\"id\", \"composer\");\n\t            y = core.Task.createTimeoutTask(n, 1);\n\t            A.push(y.destroy)\n\t        }\n\t        )()\n\t    }\n\t    ;\n\t    gui.InputMethodEditor.signalCompositionStart = \"input/compositionstart\";\n\t    gui.InputMethodEditor.signalCompositionEnd = \"input/compositionend\"\n\t}\n\t)();\n\tgui.MetadataController = function(g, k) {\n\t    function d(b) {\n\t        n.emit(gui.MetadataController.signalMetadataChanged, b)\n\t    }\n\t    function b(b) {\n\t        var d = -1 === p.indexOf(b);\n\t        d || runtime.log(\"Setting \" + b + \" is restricted.\");\n\t        return d\n\t    }\n\t    var f = g.getOdtDocument()\n\t      , n = new core.EventNotifier([gui.MetadataController.signalMetadataChanged])\n\t      , p = [\"dc:creator\", \"dc:date\", \"meta:editing-cycles\", \"meta:editing-duration\", \"meta:document-statistic\"];\n\t    this.setMetadata = function(d, f) {\n\t        var e = {}, l = \"\", a;\n\t        d && Object.keys(d).filter(b).forEach(function(a) {\n\t            e[a] = d[a]\n\t        });\n\t        f && (l = f.filter(b).join(\",\"));\n\t        if (0 < l.length || 0 < Object.keys(e).length)\n\t            a = new ops.OpUpdateMetadata,\n\t            a.init({\n\t                memberid: k,\n\t                setProperties: e,\n\t                removedProperties: 0 < l.length ? {\n\t                    attributes: l\n\t                } : null\n\t            }),\n\t            g.enqueue([a])\n\t    }\n\t    ;\n\t    this.getMetadata = function(b) {\n\t        var d;\n\t        runtime.assert(\"string\" === typeof b, \"Property must be a string\");\n\t        d = b.split(\":\");\n\t        runtime.assert(2 === d.length, \"Property must be a namespace-prefixed string\");\n\t        b = odf.Namespaces.lookupNamespaceURI(d[0]);\n\t        runtime.assert(Boolean(b), \"Prefix must be for an ODF namespace.\");\n\t        return f.getOdfCanvas().odfContainer().getMetadata(b, d[1])\n\t    }\n\t    ;\n\t    this.subscribe = function(b, d) {\n\t        n.subscribe(b, d)\n\t    }\n\t    ;\n\t    this.unsubscribe = function(b, d) {\n\t        n.unsubscribe(b, d)\n\t    }\n\t    ;\n\t    this.destroy = function(b) {\n\t        f.unsubscribe(ops.OdtDocument.signalMetadataUpdated, d);\n\t        b()\n\t    }\n\t    ;\n\t    f.subscribe(ops.OdtDocument.signalMetadataUpdated, d)\n\t}\n\t;\n\tgui.MetadataController.signalMetadataChanged = \"metadata/changed\";\n\tgui.PasteController = function(g, k, d, b) {\n\t    function f() {\n\t        r = !0 === k.getState(gui.CommonConstraints.EDIT.REVIEW_MODE) ? d.isLocalCursorWithinOwnAnnotation() : !0\n\t    }\n\t    function n(a) {\n\t        a.getMemberId() === b && f()\n\t    }\n\t    var p = g.getOdtDocument()\n\t      , r = !1\n\t      , q = odf.Namespaces.textns\n\t      , e = core.StepDirection.NEXT\n\t      , l = odf.OdfUtils;\n\t    this.isEnabled = function() {\n\t        return r\n\t    }\n\t    ;\n\t    this.paste = function(a) {\n\t        if (r) {\n\t            var c = p.getCursorPosition(b)\n\t              , d = p.getCursor(b).getNode()\n\t              , d = l.getParagraphElement(d)\n\t              , h = d.getAttributeNS(q, \"style-name\") || \"\"\n\t              , f = c\n\t              , k = []\n\t              , n = p.convertDomPointToCursorStep(d, 0, e);\n\t            a.replace(/\\r/g, \"\").split(\"\\n\").forEach(function(a) {\n\t                var c = new ops.OpInsertText\n\t                  , d = new ops.OpSplitParagraph;\n\t                c.init({\n\t                    memberid: b,\n\t                    position: f,\n\t                    text: a,\n\t                    moveCursor: !0\n\t                });\n\t                k.push(c);\n\t                f += a.length;\n\t                d.init({\n\t                    memberid: b,\n\t                    position: f,\n\t                    paragraphStyleName: h,\n\t                    sourceParagraphPosition: n,\n\t                    moveCursor: !0\n\t                });\n\t                k.push(d);\n\t                n = f += 1\n\t            });\n\t            k.pop();\n\t            g.enqueue(k)\n\t        }\n\t    }\n\t    ;\n\t    this.destroy = function(a) {\n\t        p.unsubscribe(ops.Document.signalCursorMoved, n);\n\t        k.unsubscribe(gui.CommonConstraints.EDIT.REVIEW_MODE, f);\n\t        a()\n\t    }\n\t    ;\n\t    p.subscribe(ops.Document.signalCursorMoved, n);\n\t    k.subscribe(gui.CommonConstraints.EDIT.REVIEW_MODE, f);\n\t    f()\n\t}\n\t;\n\tgui.ClosestXOffsetScanner = function(g) {\n\t    function k(b) {\n\t        return null !== b && void 0 !== f ? Math.abs(b - g) > f : !1\n\t    }\n\t    function d(b) {\n\t        null !== b && !1 === k(b) && (f = Math.abs(b - g))\n\t    }\n\t    var b = this, f, n = gui.StepInfo.VisualDirection.LEFT_TO_RIGHT;\n\t    this.token = void 0;\n\t    this.process = function(f, g, q) {\n\t        var e, l;\n\t        f.visualDirection === n ? (e = g && g.right,\n\t        l = q && q.left) : (e = g && g.left,\n\t        l = q && q.right);\n\t        if (k(e) || k(l))\n\t            return !0;\n\t        if (g || q)\n\t            d(e),\n\t            d(l),\n\t            b.token = f.token;\n\t        return !1\n\t    }\n\t}\n\t;\n\tgui.LineBoundaryScanner = function() {\n\t    var g = this\n\t      , k = null;\n\t    this.token = void 0;\n\t    this.process = function(d, b, f) {\n\t        var n;\n\t        if (n = f)\n\t            if (k) {\n\t                var p = k;\n\t                n = Math.min(p.bottom - p.top, f.bottom - f.top);\n\t                var r = Math.max(p.top, f.top)\n\t                  , p = Math.min(p.bottom, f.bottom) - r;\n\t                n = .4 >= (0 < n ? p / n : 0)\n\t            } else\n\t                n = !1;\n\t        !b || f && !n || (g.token = d.token);\n\t        if (n)\n\t            return !0;\n\t        k = (d = k) && b ? {\n\t            left: Math.min(d.left, b.left),\n\t            right: Math.max(d.right, b.right),\n\t            top: Math.min(d.top, b.top),\n\t            bottom: Math.min(d.bottom, b.bottom)\n\t        } : d || b;\n\t        return !1\n\t    }\n\t}\n\t;\n\tgui.ParagraphBoundaryScanner = function() {\n\t    var g = this, k = !1, d, b = odf.OdfUtils;\n\t    this.token = void 0;\n\t    this.process = function(f) {\n\t        var n = b.getParagraphElement(f.container());\n\t        k || (d = n,\n\t        k = !0);\n\t        if (d !== n)\n\t            return !0;\n\t        g.token = f.token;\n\t        return !1\n\t    }\n\t}\n\t;\n\todf.WordBoundaryFilter = function(g, k) {\n\t    function d(a, b, c) {\n\t        for (var d = null, e = g.getRootNode(), f; a !== e && null !== a && null === d; )\n\t            f = 0 > b ? a.previousSibling : a.nextSibling,\n\t            c(f) === NodeFilter.FILTER_ACCEPT && (d = f),\n\t            a = a.parentNode;\n\t        return d\n\t    }\n\t    function b(a, b) {\n\t        var c;\n\t        return null === a ? m.NO_NEIGHBOUR : p.isCharacterElement(a) ? m.SPACE_CHAR : a.nodeType === f || p.isTextSpan(a) || p.isHyperlink(a) ? (c = a.textContent.charAt(b()),\n\t        q.test(c) ? m.SPACE_CHAR : r.test(c) ? m.PUNCTUATION_CHAR : m.WORD_CHAR) : m.OTHER\n\t    }\n\t    var f = Node.TEXT_NODE\n\t      , n = Node.ELEMENT_NODE\n\t      , p = odf.OdfUtils\n\t      , r = /[!-#%-*,-\\/:-;?-@\\[-\\]_{}\\u00a1\\u00ab\\u00b7\\u00bb\\u00bf;\\u00b7\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0964-\\u0965\\u0970\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u104a-\\u104f\\u10fb\\u1361-\\u1368\\u166d-\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u19de-\\u19df\\u1a1e-\\u1a1f\\u1b5a-\\u1b60\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u2000-\\u206e\\u207d-\\u207e\\u208d-\\u208e\\u3008-\\u3009\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2e00-\\u2e7e\\u3000-\\u303f\\u30a0\\u30fb\\ua60d-\\ua60f\\ua673\\ua67e\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua92e-\\ua92f\\ua95f\\uaa5c-\\uaa5f\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd01\\udf9f\\udfd0]|\\ud802[\\udd1f\\udd3f\\ude50-\\ude58]|\\ud809[\\udc00-\\udc7e]/\n\t      , q = /\\s/\n\t      , e = core.PositionFilter.FilterResult.FILTER_ACCEPT\n\t      , l = core.PositionFilter.FilterResult.FILTER_REJECT\n\t      , a = odf.WordBoundaryFilter.IncludeWhitespace.TRAILING\n\t      , c = odf.WordBoundaryFilter.IncludeWhitespace.LEADING\n\t      , m = {\n\t        NO_NEIGHBOUR: 0,\n\t        SPACE_CHAR: 1,\n\t        PUNCTUATION_CHAR: 2,\n\t        WORD_CHAR: 3,\n\t        OTHER: 4\n\t    };\n\t    this.acceptPosition = function(f) {\n\t        var g = f.container()\n\t          , p = f.leftNode()\n\t          , r = f.rightNode()\n\t          , q = f.unfilteredDomOffset\n\t          , v = function() {\n\t            return f.unfilteredDomOffset() - 1\n\t        };\n\t        g.nodeType === n && (null === r && (r = d(g, 1, f.getNodeFilter())),\n\t        null === p && (p = d(g, -1, f.getNodeFilter())));\n\t        g !== r && (q = function() {\n\t            return 0\n\t        }\n\t        );\n\t        g !== p && null !== p && (v = function() {\n\t            return p.textContent.length - 1\n\t        }\n\t        );\n\t        g = b(p, v);\n\t        r = b(r, q);\n\t        return g === m.WORD_CHAR && r === m.WORD_CHAR || g === m.PUNCTUATION_CHAR && r === m.PUNCTUATION_CHAR || k === a && g !== m.NO_NEIGHBOUR && r === m.SPACE_CHAR || k === c && g === m.SPACE_CHAR && r !== m.NO_NEIGHBOUR ? l : e\n\t    }\n\t}\n\t;\n\todf.WordBoundaryFilter.IncludeWhitespace = {\n\t    None: 0,\n\t    TRAILING: 1,\n\t    LEADING: 2\n\t};\n\tgui.SelectionController = function(g, k) {\n\t    function d(a) {\n\t        var b = a.spec();\n\t        if (a.isEdit || b.memberid === k)\n\t            I = void 0,\n\t            K.cancel()\n\t    }\n\t    function b() {\n\t        var a = x.getCursor(k).getNode();\n\t        return x.createStepIterator(a, 0, [v, t], x.getRootElement(a))\n\t    }\n\t    function f(a, b, c) {\n\t        c = new odf.WordBoundaryFilter(x,c);\n\t        var d = x.getRootElement(a) || x.getRootNode()\n\t          , e = x.createRootFilter(d);\n\t        return x.createStepIterator(a, b, [v, e, c], d)\n\t    }\n\t    function n(a, b) {\n\t        return b ? {\n\t            anchorNode: a.startContainer,\n\t            anchorOffset: a.startOffset,\n\t            focusNode: a.endContainer,\n\t            focusOffset: a.endOffset\n\t        } : {\n\t            anchorNode: a.endContainer,\n\t            anchorOffset: a.endOffset,\n\t            focusNode: a.startContainer,\n\t            focusOffset: a.startOffset\n\t        }\n\t    }\n\t    function p(a, b, c) {\n\t        var d = new ops.OpMoveCursor;\n\t        d.init({\n\t            memberid: k,\n\t            position: a,\n\t            length: b || 0,\n\t            selectionType: c\n\t        });\n\t        return d\n\t    }\n\t    function r(a, b, c) {\n\t        var d;\n\t        d = x.getCursor(k);\n\t        d = n(d.getSelectedRange(), d.hasForwardSelection());\n\t        d.focusNode = a;\n\t        d.focusOffset = b;\n\t        c || (d.anchorNode = d.focusNode,\n\t        d.anchorOffset = d.focusOffset);\n\t        a = x.convertDomToCursorRange(d);\n\t        g.enqueue([p(a.position, a.length)])\n\t    }\n\t    function q(a) {\n\t        var b;\n\t        b = f(a.startContainer, a.startOffset, L);\n\t        b.roundToPreviousStep() && a.setStart(b.container(), b.offset());\n\t        b = f(a.endContainer, a.endOffset, E);\n\t        b.roundToNextStep() && a.setEnd(b.container(), b.offset())\n\t    }\n\t    function e(a) {\n\t        var b = w.getParagraphElements(a)\n\t          , c = b[0]\n\t          , b = b[b.length - 1];\n\t        c && a.setStart(c, 0);\n\t        b && (w.isParagraph(a.endContainer) && 0 === a.endOffset ? a.setEndBefore(b) : a.setEnd(b, b.childNodes.length))\n\t    }\n\t    function l(a, b, c, d) {\n\t        var e, f;\n\t        d ? (e = c.startContainer,\n\t        f = c.startOffset) : (e = c.endContainer,\n\t        f = c.endOffset);\n\t        z.containsNode(a, e) || (f = 0 > z.comparePoints(a, 0, e, f) ? 0 : a.childNodes.length,\n\t        e = a);\n\t        a = x.createStepIterator(e, f, b, w.getParagraphElement(e) || a);\n\t        a.roundToClosestStep() || runtime.assert(!1, \"No step found in requested range\");\n\t        d ? c.setStart(a.container(), a.offset()) : c.setEnd(a.container(), a.offset())\n\t    }\n\t    function a(a, c) {\n\t        var d = b();\n\t        d.advanceStep(a) && r(d.container(), d.offset(), c)\n\t    }\n\t    function c(a, c) {\n\t        var d, e = I, f = [new gui.LineBoundaryScanner, new gui.ParagraphBoundaryScanner];\n\t        void 0 === e && A && (e = A());\n\t        isNaN(e) || (d = b(),\n\t        u.moveToFilteredStep(d, a, f) && d.advanceStep(a) && (f = [new gui.ClosestXOffsetScanner(e), new gui.LineBoundaryScanner, new gui.ParagraphBoundaryScanner],\n\t        u.moveToFilteredStep(d, a, f) && (r(d.container(), d.offset(), c),\n\t        I = e,\n\t        K.restart())))\n\t    }\n\t    function m(a, c) {\n\t        var d = b()\n\t          , e = [new gui.LineBoundaryScanner, new gui.ParagraphBoundaryScanner];\n\t        u.moveToFilteredStep(d, a, e) && r(d.container(), d.offset(), c)\n\t    }\n\t    function h(a, b) {\n\t        var c = x.getCursor(k)\n\t          , c = n(c.getSelectedRange(), c.hasForwardSelection())\n\t          , c = f(c.focusNode, c.focusOffset, L);\n\t        c.advanceStep(a) && r(c.container(), c.offset(), b)\n\t    }\n\t    function y(a, b, c) {\n\t        var d = !1\n\t          , e = x.getCursor(k)\n\t          , e = n(e.getSelectedRange(), e.hasForwardSelection())\n\t          , d = x.getRootElement(e.focusNode);\n\t        runtime.assert(Boolean(d), \"SelectionController: Cursor outside root\");\n\t        e = x.createStepIterator(e.focusNode, e.focusOffset, [v, t], d);\n\t        e.roundToClosestStep();\n\t        e.advanceStep(a) && (c = c(e.container())) && (a === N ? (e.setPosition(c, 0),\n\t        d = e.roundToNextStep()) : (e.setPosition(c, c.childNodes.length),\n\t        d = e.roundToPreviousStep()),\n\t        d && r(e.container(), e.offset(), b))\n\t    }\n\t    var x = g.getOdtDocument(), z = core.DomUtils, w = odf.OdfUtils, v = x.getPositionFilter(), u = new gui.GuiStepUtils, t = x.createRootFilter(k), A = null, I, K, L = odf.WordBoundaryFilter.IncludeWhitespace.TRAILING, E = odf.WordBoundaryFilter.IncludeWhitespace.LEADING, N = core.StepDirection.PREVIOUS, O = core.StepDirection.NEXT;\n\t    this.selectionToRange = function(a) {\n\t        var b = 0 <= z.comparePoints(a.anchorNode, a.anchorOffset, a.focusNode, a.focusOffset)\n\t          , c = a.focusNode.ownerDocument.createRange();\n\t        b ? (c.setStart(a.anchorNode, a.anchorOffset),\n\t        c.setEnd(a.focusNode, a.focusOffset)) : (c.setStart(a.focusNode, a.focusOffset),\n\t        c.setEnd(a.anchorNode, a.anchorOffset));\n\t        return {\n\t            range: c,\n\t            hasForwardSelection: b\n\t        }\n\t    }\n\t    ;\n\t    this.rangeToSelection = n;\n\t    this.selectImage = function(a) {\n\t        var c = x.getRootElement(a), b = x.createRootFilter(c), c = x.createStepIterator(a, 0, [b, x.getPositionFilter()], c), d;\n\t        c.roundToPreviousStep() || runtime.assert(!1, \"No walkable position before frame\");\n\t        b = c.container();\n\t        d = c.offset();\n\t        c.setPosition(a, a.childNodes.length);\n\t        c.roundToNextStep() || runtime.assert(!1, \"No walkable position after frame\");\n\t        a = x.convertDomToCursorRange({\n\t            anchorNode: b,\n\t            anchorOffset: d,\n\t            focusNode: c.container(),\n\t            focusOffset: c.offset()\n\t        });\n\t        a = p(a.position, a.length, ops.OdtCursor.RegionSelection);\n\t        g.enqueue([a])\n\t    }\n\t    ;\n\t    this.expandToWordBoundaries = q;\n\t    this.expandToParagraphBoundaries = e;\n\t    this.selectRange = function(a, c, b) {\n\t        var d = x.getOdfCanvas().getElement(), f, h = [v];\n\t        f = z.containsNode(d, a.startContainer);\n\t        d = z.containsNode(d, a.endContainer);\n\t        if (f || d)\n\t            if (f && d && (2 === b ? q(a) : 3 <= b && e(a)),\n\t            (b = c ? x.getRootElement(a.startContainer) : x.getRootElement(a.endContainer)) || (b = x.getRootNode()),\n\t            h.push(x.createRootFilter(b)),\n\t            l(b, h, a, !0),\n\t            l(b, h, a, !1),\n\t            a = n(a, c),\n\t            c = x.convertDomToCursorRange(a),\n\t            a = x.getCursorSelection(k),\n\t            c.position !== a.position || c.length !== a.length)\n\t                a = p(c.position, c.length, ops.OdtCursor.RangeSelection),\n\t                g.enqueue([a])\n\t    }\n\t    ;\n\t    this.moveCursorToLeft = function() {\n\t        a(N, !1);\n\t        return !0\n\t    }\n\t    ;\n\t    this.moveCursorToRight = function() {\n\t        a(O, !1);\n\t        return !0\n\t    }\n\t    ;\n\t    this.extendSelectionToLeft = function() {\n\t        a(N, !0);\n\t        return !0\n\t    }\n\t    ;\n\t    this.extendSelectionToRight = function() {\n\t        a(O, !0);\n\t        return !0\n\t    }\n\t    ;\n\t    this.setCaretXPositionLocator = function(a) {\n\t        A = a\n\t    }\n\t    ;\n\t    this.moveCursorUp = function() {\n\t        c(N, !1);\n\t        return !0\n\t    }\n\t    ;\n\t    this.moveCursorDown = function() {\n\t        c(O, !1);\n\t        return !0\n\t    }\n\t    ;\n\t    this.extendSelectionUp = function() {\n\t        c(N, !0);\n\t        return !0\n\t    }\n\t    ;\n\t    this.extendSelectionDown = function() {\n\t        c(O, !0);\n\t        return !0\n\t    }\n\t    ;\n\t    this.moveCursorBeforeWord = function() {\n\t        h(N, !1);\n\t        return !0\n\t    }\n\t    ;\n\t    this.moveCursorPastWord = function() {\n\t        h(O, !1);\n\t        return !0\n\t    }\n\t    ;\n\t    this.extendSelectionBeforeWord = function() {\n\t        h(N, !0);\n\t        return !0\n\t    }\n\t    ;\n\t    this.extendSelectionPastWord = function() {\n\t        h(O, !0);\n\t        return !0\n\t    }\n\t    ;\n\t    this.moveCursorToLineStart = function() {\n\t        m(N, !1);\n\t        return !0\n\t    }\n\t    ;\n\t    this.moveCursorToLineEnd = function() {\n\t        m(O, !1);\n\t        return !0\n\t    }\n\t    ;\n\t    this.extendSelectionToLineStart = function() {\n\t        m(N, !0);\n\t        return !0\n\t    }\n\t    ;\n\t    this.extendSelectionToLineEnd = function() {\n\t        m(O, !0);\n\t        return !0\n\t    }\n\t    ;\n\t    this.extendSelectionToParagraphStart = function() {\n\t        y(N, !0, w.getParagraphElement);\n\t        return !0\n\t    }\n\t    ;\n\t    this.extendSelectionToParagraphEnd = function() {\n\t        y(O, !0, w.getParagraphElement);\n\t        return !0\n\t    }\n\t    ;\n\t    this.moveCursorToParagraphStart = function() {\n\t        y(N, !1, w.getParagraphElement);\n\t        return !0\n\t    }\n\t    ;\n\t    this.moveCursorToParagraphEnd = function() {\n\t        y(O, !1, w.getParagraphElement);\n\t        return !0\n\t    }\n\t    ;\n\t    this.moveCursorToDocumentStart = function() {\n\t        y(N, !1, x.getRootElement);\n\t        return !0\n\t    }\n\t    ;\n\t    this.moveCursorToDocumentEnd = function() {\n\t        y(O, !1, x.getRootElement);\n\t        return !0\n\t    }\n\t    ;\n\t    this.extendSelectionToDocumentStart = function() {\n\t        y(N, !0, x.getRootElement);\n\t        return !0\n\t    }\n\t    ;\n\t    this.extendSelectionToDocumentEnd = function() {\n\t        y(O, !0, x.getRootElement);\n\t        return !0\n\t    }\n\t    ;\n\t    this.extendSelectionToEntireDocument = function() {\n\t        var a = x.getCursor(k), a = x.getRootElement(a.getNode()), c, b, d;\n\t        runtime.assert(Boolean(a), \"SelectionController: Cursor outside root\");\n\t        d = x.createStepIterator(a, 0, [v, t], a);\n\t        d.roundToClosestStep();\n\t        c = d.container();\n\t        b = d.offset();\n\t        d.setPosition(a, a.childNodes.length);\n\t        d.roundToClosestStep();\n\t        a = x.convertDomToCursorRange({\n\t            anchorNode: c,\n\t            anchorOffset: b,\n\t            focusNode: d.container(),\n\t            focusOffset: d.offset()\n\t        });\n\t        g.enqueue([p(a.position, a.length)]);\n\t        return !0\n\t    }\n\t    ;\n\t    this.destroy = function(a) {\n\t        x.unsubscribe(ops.OdtDocument.signalOperationStart, d);\n\t        core.Async.destroyAll([K.destroy], a)\n\t    }\n\t    ;\n\t    (function() {\n\t        K = core.Task.createTimeoutTask(function() {\n\t            I = void 0\n\t        }, 2E3);\n\t        x.subscribe(ops.OdtDocument.signalOperationStart, d)\n\t    }\n\t    )()\n\t}\n\t;\n\tgui.TextController = function(g, k, d, b, f, n) {\n\t    function p() {\n\t        y = !0 === k.getState(gui.CommonConstraints.EDIT.REVIEW_MODE) ? d.isLocalCursorWithinOwnAnnotation() : !0\n\t    }\n\t    function r(a) {\n\t        a.getMemberId() === b && p()\n\t    }\n\t    function q(a, b, d) {\n\t        var e = [c.getPositionFilter()];\n\t        d && e.push(c.createRootFilter(a.startContainer));\n\t        d = c.createStepIterator(a.startContainer, a.startOffset, e, b);\n\t        d.roundToClosestStep() || runtime.assert(!1, \"No walkable step found in paragraph element at range start\");\n\t        b = c.convertDomPointToCursorStep(d.container(), d.offset());\n\t        a.collapsed ? a = b : (d.setPosition(a.endContainer, a.endOffset),\n\t        d.roundToClosestStep() || runtime.assert(!1, \"No walkable step found in paragraph element at range end\"),\n\t        a = c.convertDomPointToCursorStep(d.container(), d.offset()));\n\t        return {\n\t            position: b,\n\t            length: a - b\n\t        }\n\t    }\n\t    function e(a) {\n\t        var c, d, e, f = m.getParagraphElements(a), g = a.cloneRange(), l = [];\n\t        c = f[0];\n\t        1 < f.length && (m.hasNoODFContent(c) && (c = f[f.length - 1]),\n\t        d = c.getAttributeNS(odf.Namespaces.textns, \"style-name\") || \"\");\n\t        f.forEach(function(c, f) {\n\t            var m, k;\n\t            g.setStart(c, 0);\n\t            g.collapse(!0);\n\t            m = q(g, c, !1).position;\n\t            0 < f && (k = new ops.OpMergeParagraph,\n\t            k.init({\n\t                memberid: b,\n\t                paragraphStyleName: d,\n\t                destinationStartPosition: e,\n\t                sourceStartPosition: m,\n\t                moveCursor: 1 === f\n\t            }),\n\t            l.unshift(k));\n\t            e = m;\n\t            g.selectNodeContents(c);\n\t            if (m = h.rangeIntersection(g, a))\n\t                m = q(m, c, !0),\n\t                0 < m.length && (k = new ops.OpRemoveText,\n\t                k.init({\n\t                    memberid: b,\n\t                    position: m.position,\n\t                    length: m.length\n\t                }),\n\t                l.unshift(k))\n\t        });\n\t        return l\n\t    }\n\t    function l(a) {\n\t        0 > a.length && (a.position += a.length,\n\t        a.length = -a.length);\n\t        return a\n\t    }\n\t    function a(a) {\n\t        if (!y)\n\t            return !1;\n\t        var d, f = c.getCursor(b).getSelectedRange().cloneRange(), h = l(c.getCursorSelection(b)), m;\n\t        if (0 === h.length) {\n\t            h = void 0;\n\t            d = c.getCursor(b).getNode();\n\t            m = c.getRootElement(d);\n\t            var k = [c.getPositionFilter(), c.createRootFilter(m)];\n\t            m = c.createStepIterator(d, 0, k, m);\n\t            m.roundToClosestStep() && (a ? m.nextStep() : m.previousStep()) && (h = l(c.convertDomToCursorRange({\n\t                anchorNode: d,\n\t                anchorOffset: 0,\n\t                focusNode: m.container(),\n\t                focusOffset: m.offset()\n\t            })),\n\t            a ? (f.setStart(d, 0),\n\t            f.setEnd(m.container(), m.offset())) : (f.setStart(m.container(), m.offset()),\n\t            f.setEnd(d, 0)))\n\t        }\n\t        h && g.enqueue(e(f));\n\t        return void 0 !== h\n\t    }\n\t    var c = g.getOdtDocument()\n\t      , m = odf.OdfUtils\n\t      , h = core.DomUtils\n\t      , y = !1\n\t      , x = odf.Namespaces.textns\n\t      , z = core.StepDirection.NEXT;\n\t    this.isEnabled = function() {\n\t        return y\n\t    }\n\t    ;\n\t    this.enqueueParagraphSplittingOps = function() {\n\t        if (!y)\n\t            return !1;\n\t        var a = c.getCursor(b)\n\t          , d = a.getSelectedRange()\n\t          , f = l(c.getCursorSelection(b))\n\t          , h = []\n\t          , a = m.getParagraphElement(a.getNode())\n\t          , k = a.getAttributeNS(x, \"style-name\") || \"\";\n\t        0 < f.length && (h = h.concat(e(d)));\n\t        d = new ops.OpSplitParagraph;\n\t        d.init({\n\t            memberid: b,\n\t            position: f.position,\n\t            paragraphStyleName: k,\n\t            sourceParagraphPosition: c.convertDomPointToCursorStep(a, 0, z),\n\t            moveCursor: !0\n\t        });\n\t        h.push(d);\n\t        n && (f = n(f.position + 1),\n\t        h = h.concat(f));\n\t        g.enqueue(h);\n\t        return !0\n\t    }\n\t    ;\n\t    this.removeTextByBackspaceKey = function() {\n\t        return a(!1)\n\t    }\n\t    ;\n\t    this.removeTextByDeleteKey = function() {\n\t        return a(!0)\n\t    }\n\t    ;\n\t    this.removeCurrentSelection = function() {\n\t        if (!y)\n\t            return !1;\n\t        var a = c.getCursor(b).getSelectedRange();\n\t        g.enqueue(e(a));\n\t        return !0\n\t    }\n\t    ;\n\t    this.insertText = function(a) {\n\t        if (y) {\n\t            var d = c.getCursor(b).getSelectedRange()\n\t              , h = l(c.getCursorSelection(b))\n\t              , m = []\n\t              , k = !1;\n\t            0 < h.length && (m = m.concat(e(d)),\n\t            k = !0);\n\t            d = new ops.OpInsertText;\n\t            d.init({\n\t                memberid: b,\n\t                position: h.position,\n\t                text: a,\n\t                moveCursor: !0\n\t            });\n\t            m.push(d);\n\t            f && (a = f(h.position, a.length, k)) && m.push(a);\n\t            g.enqueue(m)\n\t        }\n\t    }\n\t    ;\n\t    this.destroy = function(a) {\n\t        c.unsubscribe(ops.Document.signalCursorMoved, r);\n\t        k.unsubscribe(gui.CommonConstraints.EDIT.REVIEW_MODE, p);\n\t        a()\n\t    }\n\t    ;\n\t    c.subscribe(ops.Document.signalCursorMoved, r);\n\t    k.subscribe(gui.CommonConstraints.EDIT.REVIEW_MODE, p);\n\t    p()\n\t}\n\t;\n\tgui.UndoManager = function() {}\n\t;\n\tgui.UndoManager.prototype.subscribe = function(g, k) {}\n\t;\n\tgui.UndoManager.prototype.unsubscribe = function(g, k) {}\n\t;\n\tgui.UndoManager.prototype.setDocument = function(g) {}\n\t;\n\tgui.UndoManager.prototype.setInitialState = function() {}\n\t;\n\tgui.UndoManager.prototype.initialize = function() {}\n\t;\n\tgui.UndoManager.prototype.purgeInitialState = function() {}\n\t;\n\tgui.UndoManager.prototype.setPlaybackFunction = function(g) {}\n\t;\n\tgui.UndoManager.prototype.hasUndoStates = function() {}\n\t;\n\tgui.UndoManager.prototype.hasRedoStates = function() {}\n\t;\n\tgui.UndoManager.prototype.moveForward = function(g) {}\n\t;\n\tgui.UndoManager.prototype.moveBackward = function(g) {}\n\t;\n\tgui.UndoManager.prototype.onOperationExecuted = function(g) {}\n\t;\n\tgui.UndoManager.prototype.isDocumentModified = function() {}\n\t;\n\tgui.UndoManager.prototype.setDocumentModified = function(g) {}\n\t;\n\tgui.UndoManager.signalUndoStackChanged = \"undoStackChanged\";\n\tgui.UndoManager.signalUndoStateCreated = \"undoStateCreated\";\n\tgui.UndoManager.signalUndoStateModified = \"undoStateModified\";\n\tgui.UndoManager.signalDocumentModifiedChanged = \"documentModifiedChanged\";\n\tgui.SessionControllerOptions = function() {\n\t    this.annotationsEnabled = this.directParagraphStylingEnabled = this.directTextStylingEnabled = !1\n\t}\n\t;\n\t(function() {\n\t    var g = core.PositionFilter.FilterResult.FILTER_ACCEPT;\n\t    gui.SessionController = function(k, d, b, f) {\n\t        function n(a, c) {\n\t            var b = J.getDOMDocument()\n\t              , d = null;\n\t            b.caretRangeFromPoint ? (b = b.caretRangeFromPoint(a, c),\n\t            d = {\n\t                container: b.startContainer,\n\t                offset: b.startOffset\n\t            }) : b.caretPositionFromPoint && (b = b.caretPositionFromPoint(a, c)) && b.offsetNode && (d = {\n\t                container: b.offsetNode,\n\t                offset: b.offset\n\t            });\n\t            return d\n\t        }\n\t        function p(a) {\n\t            var c = J.getCursor(d).getSelectedRange();\n\t            c.collapsed ? a.preventDefault() : ha.setDataFromRange(a, c) ? da.removeCurrentSelection() : runtime.log(\"Cut operation failed\")\n\t        }\n\t        function r() {\n\t            return !1 !== J.getCursor(d).getSelectedRange().collapsed\n\t        }\n\t        function q(a) {\n\t            var c = J.getCursor(d).getSelectedRange();\n\t            c.collapsed ? a.preventDefault() : ha.setDataFromRange(a, c) || runtime.log(\"Copy operation failed\")\n\t        }\n\t        function e(a) {\n\t            var c;\n\t            W.clipboardData && W.clipboardData.getData ? c = W.clipboardData.getData(\"Text\") : a.clipboardData && a.clipboardData.getData && (c = a.clipboardData.getData(\"text/plain\"));\n\t            c && (da.removeCurrentSelection(),\n\t            ea.paste(c));\n\t            a.preventDefault ? a.preventDefault() : a.returnValue = !1\n\t        }\n\t        function l() {\n\t            return !1\n\t        }\n\t        function a(a) {\n\t            if (Q)\n\t                Q.onOperationExecuted(a)\n\t        }\n\t        function c(a) {\n\t            J.emit(ops.OdtDocument.signalUndoStackChanged, a)\n\t        }\n\t        function m() {\n\t            var a;\n\t            return Q ? (a = F.hasFocus(),\n\t            Q.moveBackward(1),\n\t            a && F.focus(),\n\t            !0) : !1\n\t        }\n\t        function h() {\n\t            var a;\n\t            return Q ? (a = F.hasFocus(),\n\t            Q.moveForward(1),\n\t            a && F.focus(),\n\t            !0) : !1\n\t        }\n\t        function y(a) {\n\t            var c = J.getCursor(d).getSelectedRange()\n\t              , e = (a.target || a.srcElement || null).getAttribute(\"end\");\n\t            c && e && (a = n(a.clientX, a.clientY)) && (ia.setUnfilteredPosition(a.container, a.offset),\n\t            Y.acceptPosition(ia) === g && (c = c.cloneRange(),\n\t            \"left\" === e ? c.setStart(ia.container(), ia.unfilteredDomOffset()) : c.setEnd(ia.container(), ia.unfilteredDomOffset()),\n\t            b.setSelectedRange(c, \"right\" === e),\n\t            J.emit(ops.Document.signalCursorMoved, b)))\n\t        }\n\t        function x() {\n\t            T.selectRange(b.getSelectedRange(), b.hasForwardSelection(), 1)\n\t        }\n\t        function z() {\n\t            var a = W.getSelection()\n\t              , c = 0 < a.rangeCount && T.selectionToRange(a);\n\t            U && c && (B = !0,\n\t            la.clearSelection(),\n\t            ia.setUnfilteredPosition(a.focusNode, a.focusOffset),\n\t            Y.acceptPosition(ia) === g && (2 === oa ? T.expandToWordBoundaries(c.range) : 3 <= oa && T.expandToParagraphBoundaries(c.range),\n\t            b.setSelectedRange(c.range, c.hasForwardSelection),\n\t            J.emit(ops.Document.signalCursorMoved, b)))\n\t        }\n\t        function w(a) {\n\t            var c = a.target || a.srcElement || null\n\t              , b = J.getCursor(d);\n\t            if (U = null !== c && aa.containsNode(J.getOdfCanvas().getElement(), c))\n\t                B = !1,\n\t                c = J.getRootElement(c) || J.getRootNode(),\n\t                Y = J.createRootFilter(c),\n\t                oa = 0 === a.button ? a.detail : 0,\n\t                b && a.shiftKey ? W.getSelection().collapse(b.getAnchorNode(), 0) : (a = W.getSelection(),\n\t                c = b.getSelectedRange(),\n\t                a.extend ? b.hasForwardSelection() ? (a.collapse(c.startContainer, c.startOffset),\n\t                a.extend(c.endContainer, c.endOffset)) : (a.collapse(c.endContainer, c.endOffset),\n\t                a.extend(c.startContainer, c.startOffset)) : (a.removeAllRanges(),\n\t                a.addRange(c.cloneRange()))),\n\t                1 < oa && z()\n\t        }\n\t        function v(a) {\n\t            var c = J.getRootElement(a)\n\t              , b = J.createRootFilter(c)\n\t              , c = J.createStepIterator(a, 0, [b, J.getPositionFilter()], c);\n\t            c.setPosition(a, a.childNodes.length);\n\t            return c.roundToNextStep() ? {\n\t                container: c.container(),\n\t                offset: c.offset()\n\t            } : null\n\t        }\n\t        function u(a) {\n\t            var c;\n\t            c = (c = W.getSelection()) ? {\n\t                anchorNode: c.anchorNode,\n\t                anchorOffset: c.anchorOffset,\n\t                focusNode: c.focusNode,\n\t                focusOffset: c.focusOffset\n\t            } : null;\n\t            var b = W.getSelection().isCollapsed, d, e;\n\t            c.anchorNode || c.focusNode || !(d = n(a.clientX, a.clientY)) || (c.anchorNode = d.container,\n\t            c.anchorOffset = d.offset,\n\t            c.focusNode = c.anchorNode,\n\t            c.focusOffset = c.anchorOffset);\n\t            if (S.isImage(c.focusNode) && 0 === c.focusOffset && S.isCharacterFrame(c.focusNode.parentNode)) {\n\t                if (e = c.focusNode.parentNode,\n\t                d = e.getBoundingClientRect(),\n\t                a.clientX > d.left && (d = v(e)))\n\t                    c.focusNode = d.container,\n\t                    c.focusOffset = d.offset,\n\t                    b && (c.anchorNode = c.focusNode,\n\t                    c.anchorOffset = c.focusOffset)\n\t            } else\n\t                S.isImage(c.focusNode.firstChild) && 1 === c.focusOffset && S.isCharacterFrame(c.focusNode) && (d = v(c.focusNode)) && (c.anchorNode = c.focusNode = d.container,\n\t                c.anchorOffset = c.focusOffset = d.offset);\n\t            c.anchorNode && c.focusNode && (c = T.selectionToRange(c),\n\t            T.selectRange(c.range, c.hasForwardSelection, 0 === a.button ? a.detail : 0));\n\t            F.focus()\n\t        }\n\t        function t(a) {\n\t            var c;\n\t            if (c = n(a.clientX, a.clientY))\n\t                a = c.container,\n\t                c = c.offset,\n\t                a = {\n\t                    anchorNode: a,\n\t                    anchorOffset: c,\n\t                    focusNode: a,\n\t                    focusOffset: c\n\t                },\n\t                a = T.selectionToRange(a),\n\t                T.selectRange(a.range, a.hasForwardSelection, 2),\n\t                F.focus()\n\t        }\n\t        function A(a) {\n\t            var c = a.target || a.srcElement || null, d, e, f;\n\t            ma.processRequests();\n\t            U && (S.isImage(c) && S.isCharacterFrame(c.parentNode) && W.getSelection().isCollapsed ? (T.selectImage(c.parentNode),\n\t            F.focus()) : la.isSelectorElement(c) ? F.focus() : B ? (c = b.getSelectedRange(),\n\t            e = c.collapsed,\n\t            S.isImage(c.endContainer) && 0 === c.endOffset && S.isCharacterFrame(c.endContainer.parentNode) && (f = c.endContainer.parentNode,\n\t            f = v(f)) && (c.setEnd(f.container, f.offset),\n\t            e && c.collapse(!1)),\n\t            T.selectRange(c, b.hasForwardSelection(), 0 === a.button ? a.detail : 0),\n\t            F.focus()) : ua ? u(a) : (d = aa.cloneEvent(a),\n\t            M = runtime.setTimeout(function() {\n\t                u(d)\n\t            }, 0)),\n\t            oa = 0,\n\t            B = U = !1)\n\t        }\n\t        function I(a) {\n\t            var c = J.getCursor(d).getSelectedRange();\n\t            c.collapsed || fa.exportRangeToDataTransfer(a.dataTransfer, c)\n\t        }\n\t        function K() {\n\t            U && F.focus();\n\t            oa = 0;\n\t            B = U = !1\n\t        }\n\t        function L(a) {\n\t            A(a)\n\t        }\n\t        function E(a) {\n\t            var c = a.target || a.srcElement || null\n\t              , b = null;\n\t            \"annotationRemoveButton\" === c.className ? (runtime.assert(ja, \"Remove buttons are displayed on annotations while annotation editing is disabled in the controller.\"),\n\t            b = c.parentNode.getElementsByTagNameNS(odf.Namespaces.officens, \"annotation\").item(0),\n\t            ca.removeAnnotation(b),\n\t            F.focus()) : \"webodf-draggable\" !== c.getAttribute(\"class\") && A(a)\n\t        }\n\t        function N(a) {\n\t            (a = a.data) && (-1 === a.indexOf(\"\\n\") ? da.insertText(a) : ea.paste(a))\n\t        }\n\t        function O(a) {\n\t            return function() {\n\t                a();\n\t                return !0\n\t            }\n\t        }\n\t        function D(a) {\n\t            return function(c) {\n\t                return J.getCursor(d).getSelectionType() === ops.OdtCursor.RangeSelection ? a(c) : !0\n\t            }\n\t        }\n\t        function V(c) {\n\t            F.unsubscribe(\"keydown\", C.handleEvent);\n\t            F.unsubscribe(\"keypress\", Z.handleEvent);\n\t            F.unsubscribe(\"keyup\", ba.handleEvent);\n\t            F.unsubscribe(\"copy\", q);\n\t            F.unsubscribe(\"mousedown\", w);\n\t            F.unsubscribe(\"mousemove\", ma.trigger);\n\t            F.unsubscribe(\"mouseup\", E);\n\t            F.unsubscribe(\"contextmenu\", L);\n\t            F.unsubscribe(\"dragstart\", I);\n\t            F.unsubscribe(\"dragend\", K);\n\t            F.unsubscribe(\"click\", pa.handleClick);\n\t            F.unsubscribe(\"longpress\", t);\n\t            F.unsubscribe(\"drag\", y);\n\t            F.unsubscribe(\"dragstop\", x);\n\t            J.unsubscribe(ops.OdtDocument.signalOperationEnd, na.trigger);\n\t            J.unsubscribe(ops.Document.signalCursorAdded, ka.registerCursor);\n\t            J.unsubscribe(ops.Document.signalCursorRemoved, ka.removeCursor);\n\t            J.unsubscribe(ops.OdtDocument.signalOperationEnd, a);\n\t            c()\n\t        }\n\t        var W = runtime.getWindow(), J = k.getOdtDocument(), R = new gui.SessionConstraints, P = new gui.SessionContext(k,d), aa = core.DomUtils, S = odf.OdfUtils, fa = new gui.MimeDataExporter, ha = new gui.Clipboard(fa), C = new gui.KeyboardHandler, Z = new gui.KeyboardHandler, ba = new gui.KeyboardHandler, U = !1, ga = new odf.ObjectNameGenerator(J.getOdfCanvas().odfContainer(),d), B = !1, Y = null, M, Q = null, F = new gui.EventManager(J), ja = f.annotationsEnabled, ca = new gui.AnnotationController(k,R,d), X = new gui.DirectFormattingController(k,R,P,d,ga,f.directTextStylingEnabled,f.directParagraphStylingEnabled), da = new gui.TextController(k,R,P,d,X.createCursorStyleOp,X.createParagraphStyleOps), qa = new gui.ImageController(k,R,P,d,ga), la = new gui.ImageSelector(J.getOdfCanvas()), ia = J.createPositionIterator(J.getRootNode()), ma, na, ea = new gui.PasteController(k,R,P,d), ka = new gui.InputMethodEditor(d,F), oa = 0, pa = new gui.HyperlinkClickHandler(J.getOdfCanvas().getElement,C,ba), ta = new gui.HyperlinkController(k,R,P,d), T = new gui.SelectionController(k,d), va = new gui.MetadataController(k,d), G = gui.KeyboardHandler.Modifier, H = gui.KeyboardHandler.KeyCode, ra = -1 !== W.navigator.appVersion.toLowerCase().indexOf(\"mac\"), ua = -1 !== [\"iPad\", \"iPod\", \"iPhone\"].indexOf(W.navigator.platform), sa;\n\t        runtime.assert(null !== W, \"Expected to be run in an environment which has a global window, like a browser.\");\n\t        this.undo = m;\n\t        this.redo = h;\n\t        this.insertLocalCursor = function() {\n\t            runtime.assert(void 0 === k.getOdtDocument().getCursor(d), \"Inserting local cursor a second time.\");\n\t            var a = new ops.OpAddCursor;\n\t            a.init({\n\t                memberid: d\n\t            });\n\t            k.enqueue([a]);\n\t            F.focus()\n\t        }\n\t        ;\n\t        this.removeLocalCursor = function() {\n\t            runtime.assert(void 0 !== k.getOdtDocument().getCursor(d), \"Removing local cursor without inserting before.\");\n\t            var a = new ops.OpRemoveCursor;\n\t            a.init({\n\t                memberid: d\n\t            });\n\t            k.enqueue([a])\n\t        }\n\t        ;\n\t        this.startEditing = function() {\n\t            ka.subscribe(gui.InputMethodEditor.signalCompositionStart, da.removeCurrentSelection);\n\t            ka.subscribe(gui.InputMethodEditor.signalCompositionEnd, N);\n\t            F.subscribe(\"beforecut\", r);\n\t            F.subscribe(\"cut\", p);\n\t            F.subscribe(\"beforepaste\", l);\n\t            F.subscribe(\"paste\", e);\n\t            Q && Q.initialize();\n\t            F.setEditing(!0);\n\t            pa.setModifier(ra ? G.Meta : G.Ctrl);\n\t            C.bind(H.Backspace, G.None, O(da.removeTextByBackspaceKey), !0);\n\t            C.bind(H.Delete, G.None, da.removeTextByDeleteKey);\n\t            C.bind(H.Tab, G.None, D(function() {\n\t                da.insertText(\"\\t\");\n\t                return !0\n\t            }));\n\t            ra ? (C.bind(H.Clear, G.None, da.removeCurrentSelection),\n\t            C.bind(H.B, G.Meta, D(X.toggleBold)),\n\t            C.bind(H.I, G.Meta, D(X.toggleItalic)),\n\t            C.bind(H.U, G.Meta, D(X.toggleUnderline)),\n\t            C.bind(H.L, G.MetaShift, D(X.alignParagraphLeft)),\n\t            C.bind(H.E, G.MetaShift, D(X.alignParagraphCenter)),\n\t            C.bind(H.R, G.MetaShift, D(X.alignParagraphRight)),\n\t            C.bind(H.J, G.MetaShift, D(X.alignParagraphJustified)),\n\t            ja && C.bind(H.C, G.MetaShift, ca.addAnnotation),\n\t            C.bind(H.Z, G.Meta, m),\n\t            C.bind(H.Z, G.MetaShift, h)) : (C.bind(H.B, G.Ctrl, D(X.toggleBold)),\n\t            C.bind(H.I, G.Ctrl, D(X.toggleItalic)),\n\t            C.bind(H.U, G.Ctrl, D(X.toggleUnderline)),\n\t            C.bind(H.L, G.CtrlShift, D(X.alignParagraphLeft)),\n\t            C.bind(H.E, G.CtrlShift, D(X.alignParagraphCenter)),\n\t            C.bind(H.R, G.CtrlShift, D(X.alignParagraphRight)),\n\t            C.bind(H.J, G.CtrlShift, D(X.alignParagraphJustified)),\n\t            ja && C.bind(H.C, G.CtrlAlt, ca.addAnnotation),\n\t            C.bind(H.Z, G.Ctrl, m),\n\t            C.bind(H.Z, G.CtrlShift, h));\n\t            Z.setDefault(D(function(a) {\n\t                var c;\n\t                c = null === a.which || void 0 === a.which ? String.fromCharCode(a.keyCode) : 0 !== a.which && 0 !== a.charCode ? String.fromCharCode(a.which) : null;\n\t                return !c || a.altKey || a.ctrlKey || a.metaKey ? !1 : (da.insertText(c),\n\t                !0)\n\t            }));\n\t            Z.bind(H.Enter, G.None, D(da.enqueueParagraphSplittingOps))\n\t        }\n\t        ;\n\t        this.endEditing = function() {\n\t            ka.unsubscribe(gui.InputMethodEditor.signalCompositionStart, da.removeCurrentSelection);\n\t            ka.unsubscribe(gui.InputMethodEditor.signalCompositionEnd, N);\n\t            F.unsubscribe(\"cut\", p);\n\t            F.unsubscribe(\"beforecut\", r);\n\t            F.unsubscribe(\"paste\", e);\n\t            F.unsubscribe(\"beforepaste\", l);\n\t            F.setEditing(!1);\n\t            pa.setModifier(G.None);\n\t            C.bind(H.Backspace, G.None, function() {\n\t                return !0\n\t            }, !0);\n\t            C.unbind(H.Delete, G.None);\n\t            C.unbind(H.Tab, G.None);\n\t            ra ? (C.unbind(H.Clear, G.None),\n\t            C.unbind(H.B, G.Meta),\n\t            C.unbind(H.I, G.Meta),\n\t            C.unbind(H.U, G.Meta),\n\t            C.unbind(H.L, G.MetaShift),\n\t            C.unbind(H.E, G.MetaShift),\n\t            C.unbind(H.R, G.MetaShift),\n\t            C.unbind(H.J, G.MetaShift),\n\t            ja && C.unbind(H.C, G.MetaShift),\n\t            C.unbind(H.Z, G.Meta),\n\t            C.unbind(H.Z, G.MetaShift)) : (C.unbind(H.B, G.Ctrl),\n\t            C.unbind(H.I, G.Ctrl),\n\t            C.unbind(H.U, G.Ctrl),\n\t            C.unbind(H.L, G.CtrlShift),\n\t            C.unbind(H.E, G.CtrlShift),\n\t            C.unbind(H.R, G.CtrlShift),\n\t            C.unbind(H.J, G.CtrlShift),\n\t            ja && C.unbind(H.C, G.CtrlAlt),\n\t            C.unbind(H.Z, G.Ctrl),\n\t            C.unbind(H.Z, G.CtrlShift));\n\t            Z.setDefault(null);\n\t            Z.unbind(H.Enter, G.None)\n\t        }\n\t        ;\n\t        this.getInputMemberId = function() {\n\t            return d\n\t        }\n\t        ;\n\t        this.getSession = function() {\n\t            return k\n\t        }\n\t        ;\n\t        this.getSessionConstraints = function() {\n\t            return R\n\t        }\n\t        ;\n\t        this.setUndoManager = function(a) {\n\t            Q && Q.unsubscribe(gui.UndoManager.signalUndoStackChanged, c);\n\t            if (Q = a)\n\t                Q.setDocument(J),\n\t                Q.setPlaybackFunction(k.enqueue),\n\t                Q.subscribe(gui.UndoManager.signalUndoStackChanged, c)\n\t        }\n\t        ;\n\t        this.getUndoManager = function() {\n\t            return Q\n\t        }\n\t        ;\n\t        this.getMetadataController = function() {\n\t            return va\n\t        }\n\t        ;\n\t        this.getAnnotationController = function() {\n\t            return ca\n\t        }\n\t        ;\n\t        this.getDirectFormattingController = function() {\n\t            return X\n\t        }\n\t        ;\n\t        this.getHyperlinkClickHandler = function() {\n\t            return pa\n\t        }\n\t        ;\n\t        this.getHyperlinkController = function() {\n\t            return ta\n\t        }\n\t        ;\n\t        this.getImageController = function() {\n\t            return qa\n\t        }\n\t        ;\n\t        this.getSelectionController = function() {\n\t            return T\n\t        }\n\t        ;\n\t        this.getTextController = function() {\n\t            return da\n\t        }\n\t        ;\n\t        this.getEventManager = function() {\n\t            return F\n\t        }\n\t        ;\n\t        this.getKeyboardHandlers = function() {\n\t            return {\n\t                keydown: C,\n\t                keypress: Z\n\t            }\n\t        }\n\t        ;\n\t        this.destroy = function(a) {\n\t            var c = [ma.destroy, na.destroy, X.destroy, ka.destroy, F.destroy, pa.destroy, ta.destroy, va.destroy, T.destroy, da.destroy, V];\n\t            sa && c.unshift(sa.destroy);\n\t            runtime.clearTimeout(M);\n\t            core.Async.destroyAll(c, a)\n\t        }\n\t        ;\n\t        ma = core.Task.createRedrawTask(z);\n\t        na = core.Task.createRedrawTask(function() {\n\t            var a = J.getCursor(d);\n\t            if (a && a.getSelectionType() === ops.OdtCursor.RegionSelection && (a = S.getImageElements(a.getSelectedRange())[0])) {\n\t                la.select(a.parentNode);\n\t                return\n\t            }\n\t            la.clearSelection()\n\t        });\n\t        C.bind(H.Left, G.None, D(T.moveCursorToLeft));\n\t        C.bind(H.Right, G.None, D(T.moveCursorToRight));\n\t        C.bind(H.Up, G.None, D(T.moveCursorUp));\n\t        C.bind(H.Down, G.None, D(T.moveCursorDown));\n\t        C.bind(H.Left, G.Shift, D(T.extendSelectionToLeft));\n\t        C.bind(H.Right, G.Shift, D(T.extendSelectionToRight));\n\t        C.bind(H.Up, G.Shift, D(T.extendSelectionUp));\n\t        C.bind(H.Down, G.Shift, D(T.extendSelectionDown));\n\t        C.bind(H.Home, G.None, D(T.moveCursorToLineStart));\n\t        C.bind(H.End, G.None, D(T.moveCursorToLineEnd));\n\t        C.bind(H.Home, G.Ctrl, D(T.moveCursorToDocumentStart));\n\t        C.bind(H.End, G.Ctrl, D(T.moveCursorToDocumentEnd));\n\t        C.bind(H.Home, G.Shift, D(T.extendSelectionToLineStart));\n\t        C.bind(H.End, G.Shift, D(T.extendSelectionToLineEnd));\n\t        C.bind(H.Up, G.CtrlShift, D(T.extendSelectionToParagraphStart));\n\t        C.bind(H.Down, G.CtrlShift, D(T.extendSelectionToParagraphEnd));\n\t        C.bind(H.Home, G.CtrlShift, D(T.extendSelectionToDocumentStart));\n\t        C.bind(H.End, G.CtrlShift, D(T.extendSelectionToDocumentEnd));\n\t        ra ? (C.bind(H.Left, G.Alt, D(T.moveCursorBeforeWord)),\n\t        C.bind(H.Right, G.Alt, D(T.moveCursorPastWord)),\n\t        C.bind(H.Left, G.Meta, D(T.moveCursorToLineStart)),\n\t        C.bind(H.Right, G.Meta, D(T.moveCursorToLineEnd)),\n\t        C.bind(H.Home, G.Meta, D(T.moveCursorToDocumentStart)),\n\t        C.bind(H.End, G.Meta, D(T.moveCursorToDocumentEnd)),\n\t        C.bind(H.Left, G.AltShift, D(T.extendSelectionBeforeWord)),\n\t        C.bind(H.Right, G.AltShift, D(T.extendSelectionPastWord)),\n\t        C.bind(H.Left, G.MetaShift, D(T.extendSelectionToLineStart)),\n\t        C.bind(H.Right, G.MetaShift, D(T.extendSelectionToLineEnd)),\n\t        C.bind(H.Up, G.AltShift, D(T.extendSelectionToParagraphStart)),\n\t        C.bind(H.Down, G.AltShift, D(T.extendSelectionToParagraphEnd)),\n\t        C.bind(H.Up, G.MetaShift, D(T.extendSelectionToDocumentStart)),\n\t        C.bind(H.Down, G.MetaShift, D(T.extendSelectionToDocumentEnd)),\n\t        C.bind(H.A, G.Meta, D(T.extendSelectionToEntireDocument))) : (C.bind(H.Left, G.Ctrl, D(T.moveCursorBeforeWord)),\n\t        C.bind(H.Right, G.Ctrl, D(T.moveCursorPastWord)),\n\t        C.bind(H.Left, G.CtrlShift, D(T.extendSelectionBeforeWord)),\n\t        C.bind(H.Right, G.CtrlShift, D(T.extendSelectionPastWord)),\n\t        C.bind(H.A, G.Ctrl, D(T.extendSelectionToEntireDocument)));\n\t        ua && (sa = new gui.IOSSafariSupport(F));\n\t        F.subscribe(\"keydown\", C.handleEvent);\n\t        F.subscribe(\"keypress\", Z.handleEvent);\n\t        F.subscribe(\"keyup\", ba.handleEvent);\n\t        F.subscribe(\"copy\", q);\n\t        F.subscribe(\"mousedown\", w);\n\t        F.subscribe(\"mousemove\", ma.trigger);\n\t        F.subscribe(\"mouseup\", E);\n\t        F.subscribe(\"contextmenu\", L);\n\t        F.subscribe(\"dragstart\", I);\n\t        F.subscribe(\"dragend\", K);\n\t        F.subscribe(\"click\", pa.handleClick);\n\t        F.subscribe(\"longpress\", t);\n\t        F.subscribe(\"drag\", y);\n\t        F.subscribe(\"dragstop\", x);\n\t        J.subscribe(ops.OdtDocument.signalOperationEnd, na.trigger);\n\t        J.subscribe(ops.Document.signalCursorAdded, ka.registerCursor);\n\t        J.subscribe(ops.Document.signalCursorRemoved, ka.removeCursor);\n\t        J.subscribe(ops.OdtDocument.signalOperationEnd, a)\n\t    }\n\t}\n\t)();\n\tgui.CaretManager = function(g, k) {\n\t    function d(b) {\n\t        return n.hasOwnProperty(b) ? n[b] : null\n\t    }\n\t    function b() {\n\t        return Object.keys(n).map(function(b) {\n\t            return n[b]\n\t        })\n\t    }\n\t    function f(b) {\n\t        var d = n[b];\n\t        d && (delete n[b],\n\t        b === g.getInputMemberId() ? (r.unsubscribe(ops.OdtDocument.signalProcessingBatchEnd, d.ensureVisible),\n\t        r.unsubscribe(ops.Document.signalCursorMoved, d.refreshCursorBlinking),\n\t        q.unsubscribe(\"compositionupdate\", d.handleUpdate),\n\t        q.unsubscribe(\"compositionend\", d.handleUpdate),\n\t        q.unsubscribe(\"focus\", d.setFocus),\n\t        q.unsubscribe(\"blur\", d.removeFocus),\n\t        p.removeEventListener(\"focus\", d.show, !1),\n\t        p.removeEventListener(\"blur\", d.hide, !1)) : r.unsubscribe(ops.OdtDocument.signalProcessingBatchEnd, d.handleUpdate),\n\t        d.destroy(function() {}))\n\t    }\n\t    var n = {}\n\t      , p = runtime.getWindow()\n\t      , r = g.getSession().getOdtDocument()\n\t      , q = g.getEventManager();\n\t    this.registerCursor = function(b, d, a) {\n\t        var c = b.getMemberId();\n\t        b = new gui.Caret(b,k,d,a);\n\t        n[c] = b;\n\t        c === g.getInputMemberId() ? (runtime.log(\"Starting to track input on new cursor of \" + c),\n\t        r.subscribe(ops.OdtDocument.signalProcessingBatchEnd, b.ensureVisible),\n\t        r.subscribe(ops.Document.signalCursorMoved, b.refreshCursorBlinking),\n\t        q.subscribe(\"compositionupdate\", b.handleUpdate),\n\t        q.subscribe(\"compositionend\", b.handleUpdate),\n\t        q.subscribe(\"focus\", b.setFocus),\n\t        q.subscribe(\"blur\", b.removeFocus),\n\t        p.addEventListener(\"focus\", b.show, !1),\n\t        p.addEventListener(\"blur\", b.hide, !1),\n\t        b.setOverlayElement(q.getEventTrap())) : r.subscribe(ops.OdtDocument.signalProcessingBatchEnd, b.handleUpdate);\n\t        return b\n\t    }\n\t    ;\n\t    this.getCaret = d;\n\t    this.getCarets = b;\n\t    this.destroy = function(d) {\n\t        var l = b().map(function(a) {\n\t            return a.destroy\n\t        });\n\t        g.getSelectionController().setCaretXPositionLocator(null);\n\t        r.unsubscribe(ops.Document.signalCursorRemoved, f);\n\t        n = {};\n\t        core.Async.destroyAll(l, d)\n\t    }\n\t    ;\n\t    g.getSelectionController().setCaretXPositionLocator(function() {\n\t        var b = d(g.getInputMemberId()), f;\n\t        b && (f = b.getBoundingClientRect());\n\t        return f ? f.right : void 0\n\t    });\n\t    r.subscribe(ops.Document.signalCursorRemoved, f)\n\t}\n\t;\n\tgui.EditInfoHandle = function(g) {\n\t    var k = [], d, b = g.ownerDocument, f = b.documentElement.namespaceURI;\n\t    this.setEdits = function(g) {\n\t        k = g;\n\t        var p, r, q, e;\n\t        core.DomUtils.removeAllChildNodes(d);\n\t        for (g = 0; g < k.length; g += 1)\n\t            p = b.createElementNS(f, \"div\"),\n\t            p.className = \"editInfo\",\n\t            r = b.createElementNS(f, \"span\"),\n\t            r.className = \"editInfoColor\",\n\t            r.setAttributeNS(\"urn:webodf:names:editinfo\", \"editinfo:memberid\", k[g].memberid),\n\t            q = b.createElementNS(f, \"span\"),\n\t            q.className = \"editInfoAuthor\",\n\t            q.setAttributeNS(\"urn:webodf:names:editinfo\", \"editinfo:memberid\", k[g].memberid),\n\t            e = b.createElementNS(f, \"span\"),\n\t            e.className = \"editInfoTime\",\n\t            e.setAttributeNS(\"urn:webodf:names:editinfo\", \"editinfo:memberid\", k[g].memberid),\n\t            e.appendChild(b.createTextNode(k[g].time.toString())),\n\t            p.appendChild(r),\n\t            p.appendChild(q),\n\t            p.appendChild(e),\n\t            d.appendChild(p)\n\t    }\n\t    ;\n\t    this.show = function() {\n\t        d.style.display = \"block\"\n\t    }\n\t    ;\n\t    this.hide = function() {\n\t        d.style.display = \"none\"\n\t    }\n\t    ;\n\t    this.destroy = function(b) {\n\t        g.removeChild(d);\n\t        b()\n\t    }\n\t    ;\n\t    d = b.createElementNS(f, \"div\");\n\t    d.setAttribute(\"class\", \"editInfoHandle\");\n\t    d.style.display = \"none\";\n\t    g.appendChild(d)\n\t}\n\t;\n\tops.EditInfo = function(g, k) {\n\t    function d() {\n\t        var b = [], d;\n\t        for (d in f)\n\t            f.hasOwnProperty(d) && b.push({\n\t                memberid: d,\n\t                time: f[d].time\n\t            });\n\t        b.sort(function(b, d) {\n\t            return b.time - d.time\n\t        });\n\t        return b\n\t    }\n\t    var b, f = {};\n\t    this.getNode = function() {\n\t        return b\n\t    }\n\t    ;\n\t    this.getOdtDocument = function() {\n\t        return k\n\t    }\n\t    ;\n\t    this.getEdits = function() {\n\t        return f\n\t    }\n\t    ;\n\t    this.getSortedEdits = function() {\n\t        return d()\n\t    }\n\t    ;\n\t    this.addEdit = function(b, d) {\n\t        f[b] = {\n\t            time: d\n\t        }\n\t    }\n\t    ;\n\t    this.clearEdits = function() {\n\t        f = {}\n\t    }\n\t    ;\n\t    this.destroy = function(d) {\n\t        g.parentNode && g.removeChild(b);\n\t        d()\n\t    }\n\t    ;\n\t    b = k.getDOMDocument().createElementNS(\"urn:webodf:names:editinfo\", \"editinfo\");\n\t    g.insertBefore(b, g.firstChild)\n\t}\n\t;\n\tgui.EditInfoMarker = function(g, k) {\n\t    function d(b, a) {\n\t        return runtime.setTimeout(function() {\n\t            p.style.opacity = b\n\t        }, a)\n\t    }\n\t    var b = this, f, n, p, r, q, e;\n\t    this.addEdit = function(b, a) {\n\t        var c = Date.now() - a;\n\t        g.addEdit(b, a);\n\t        n.setEdits(g.getSortedEdits());\n\t        p.setAttributeNS(\"urn:webodf:names:editinfo\", \"editinfo:memberid\", b);\n\t        runtime.clearTimeout(q);\n\t        runtime.clearTimeout(e);\n\t        1E4 > c ? (r = d(1, 0),\n\t        q = d(.5, 1E4 - c),\n\t        e = d(.2, 2E4 - c)) : 1E4 <= c && 2E4 > c ? (r = d(.5, 0),\n\t        e = d(.2, 2E4 - c)) : r = d(.2, 0)\n\t    }\n\t    ;\n\t    this.getEdits = function() {\n\t        return g.getEdits()\n\t    }\n\t    ;\n\t    this.clearEdits = function() {\n\t        g.clearEdits();\n\t        n.setEdits([]);\n\t        p.hasAttributeNS(\"urn:webodf:names:editinfo\", \"editinfo:memberid\") && p.removeAttributeNS(\"urn:webodf:names:editinfo\", \"editinfo:memberid\")\n\t    }\n\t    ;\n\t    this.getEditInfo = function() {\n\t        return g\n\t    }\n\t    ;\n\t    this.show = function() {\n\t        p.style.display = \"block\"\n\t    }\n\t    ;\n\t    this.hide = function() {\n\t        b.hideHandle();\n\t        p.style.display = \"none\"\n\t    }\n\t    ;\n\t    this.showHandle = function() {\n\t        n.show()\n\t    }\n\t    ;\n\t    this.hideHandle = function() {\n\t        n.hide()\n\t    }\n\t    ;\n\t    this.destroy = function(b) {\n\t        runtime.clearTimeout(r);\n\t        runtime.clearTimeout(q);\n\t        runtime.clearTimeout(e);\n\t        f.removeChild(p);\n\t        n.destroy(function(a) {\n\t            a ? b(a) : g.destroy(b)\n\t        })\n\t    }\n\t    ;\n\t    (function() {\n\t        var d = g.getOdtDocument().getDOMDocument();\n\t        p = d.createElementNS(d.documentElement.namespaceURI, \"div\");\n\t        p.setAttribute(\"class\", \"editInfoMarker\");\n\t        p.onmouseover = function() {\n\t            b.showHandle()\n\t        }\n\t        ;\n\t        p.onmouseout = function() {\n\t            b.hideHandle()\n\t        }\n\t        ;\n\t        f = g.getNode();\n\t        f.appendChild(p);\n\t        n = new gui.EditInfoHandle(f);\n\t        k || b.hide()\n\t    }\n\t    )()\n\t}\n\t;\n\tgui.HyperlinkTooltipView = function(g, k) {\n\t    var d = core.DomUtils, b = odf.OdfUtils, f = runtime.getWindow(), n, p, r;\n\t    runtime.assert(null !== f, \"Expected to be run in an environment which has a global window, like a browser.\");\n\t    this.showTooltip = function(q) {\n\t        var e = q.target || q.srcElement, l = g.getSizer(), a = g.getZoomLevel(), c;\n\t        a: {\n\t            for (; e; ) {\n\t                if (b.isHyperlink(e))\n\t                    break a;\n\t                if (b.isParagraph(e) || b.isInlineRoot(e))\n\t                    break;\n\t                e = e.parentNode\n\t            }\n\t            e = null\n\t        }\n\t        if (e) {\n\t            d.containsNode(l, r) || l.appendChild(r);\n\t            c = p;\n\t            var m;\n\t            switch (k()) {\n\t            case gui.KeyboardHandler.Modifier.Ctrl:\n\t                m = runtime.tr(\"Ctrl-click to follow link\");\n\t                break;\n\t            case gui.KeyboardHandler.Modifier.Meta:\n\t                m = runtime.tr(\"\\u2318-click to follow link\");\n\t                break;\n\t            default:\n\t                m = \"\"\n\t            }\n\t            c.textContent = m;\n\t            n.textContent = b.getHyperlinkTarget(e);\n\t            r.style.display = \"block\";\n\t            c = f.innerWidth - r.offsetWidth - 15;\n\t            e = q.clientX > c ? c : q.clientX + 15;\n\t            c = f.innerHeight - r.offsetHeight - 10;\n\t            q = q.clientY > c ? c : q.clientY + 10;\n\t            l = l.getBoundingClientRect();\n\t            e = (e - l.left) / a;\n\t            q = (q - l.top) / a;\n\t            r.style.left = e + \"px\";\n\t            r.style.top = q + \"px\"\n\t        }\n\t    }\n\t    ;\n\t    this.hideTooltip = function() {\n\t        r.style.display = \"none\"\n\t    }\n\t    ;\n\t    this.destroy = function(b) {\n\t        r.parentNode && r.parentNode.removeChild(r);\n\t        b()\n\t    }\n\t    ;\n\t    (function() {\n\t        var b = g.getElement().ownerDocument;\n\t        n = b.createElement(\"span\");\n\t        p = b.createElement(\"span\");\n\t        n.className = \"webodf-hyperlinkTooltipLink\";\n\t        p.className = \"webodf-hyperlinkTooltipText\";\n\t        r = b.createElement(\"div\");\n\t        r.className = \"webodf-hyperlinkTooltip\";\n\t        r.appendChild(n);\n\t        r.appendChild(p);\n\t        g.getElement().appendChild(r)\n\t    }\n\t    )()\n\t}\n\t;\n\tgui.OdfFieldView = function(g) {\n\t    function k() {\n\t        var b = odf.OdfSchema.getFields().map(function(b) {\n\t            return b.replace(\":\", \"|\")\n\t        })\n\t          , d = b.join(\",\\n\") + \"\\n{ background-color: #D0D0D0; }\\n\"\n\t          , b = b.map(function(b) {\n\t            return b + \":empty::after\"\n\t        }).join(\",\\n\") + \"\\n{ content:' '; white-space: pre; }\\n\";\n\t        return d + \"\\n\" + b\n\t    }\n\t    var d, b = g.getElement().ownerDocument;\n\t    this.showFieldHighlight = function() {\n\t        d.appendChild(b.createTextNode(k()))\n\t    }\n\t    ;\n\t    this.hideFieldHighlight = function() {\n\t        for (var b = d.sheet, g = b.cssRules; g.length; )\n\t            b.deleteRule(g.length - 1)\n\t    }\n\t    ;\n\t    this.destroy = function(b) {\n\t        d.parentNode && d.parentNode.removeChild(d);\n\t        b()\n\t    }\n\t    ;\n\t    d = function() {\n\t        var d = b.getElementsByTagName(\"head\").item(0)\n\t          , g = b.createElement(\"style\")\n\t          , k = \"\";\n\t        g.type = \"text/css\";\n\t        g.media = \"screen, print, handheld, projection\";\n\t        odf.Namespaces.forEachPrefix(function(b, d) {\n\t            k += \"@namespace \" + b + \" url(\" + d + \");\\n\"\n\t        });\n\t        g.appendChild(b.createTextNode(k));\n\t        d.appendChild(g);\n\t        return g\n\t    }()\n\t}\n\t;\n\tgui.ShadowCursor = function(g) {\n\t    var k = g.getDOMDocument().createRange()\n\t      , d = !0;\n\t    this.removeFromDocument = function() {}\n\t    ;\n\t    this.getMemberId = function() {\n\t        return gui.ShadowCursor.ShadowCursorMemberId\n\t    }\n\t    ;\n\t    this.getSelectedRange = function() {\n\t        return k\n\t    }\n\t    ;\n\t    this.setSelectedRange = function(b, f) {\n\t        k = b;\n\t        d = !1 !== f\n\t    }\n\t    ;\n\t    this.hasForwardSelection = function() {\n\t        return d\n\t    }\n\t    ;\n\t    this.getDocument = function() {\n\t        return g\n\t    }\n\t    ;\n\t    this.getSelectionType = function() {\n\t        return ops.OdtCursor.RangeSelection\n\t    }\n\t    ;\n\t    k.setStart(g.getRootNode(), 0)\n\t}\n\t;\n\tgui.ShadowCursor.ShadowCursorMemberId = \"\";\n\tgui.SelectionView = function(g) {}\n\t;\n\tgui.SelectionView.prototype.rerender = function() {}\n\t;\n\tgui.SelectionView.prototype.show = function() {}\n\t;\n\tgui.SelectionView.prototype.hide = function() {}\n\t;\n\tgui.SelectionView.prototype.destroy = function(g) {}\n\t;\n\tgui.SelectionViewManager = function(g) {\n\t    function k() {\n\t        return Object.keys(d).map(function(b) {\n\t            return d[b]\n\t        })\n\t    }\n\t    var d = {};\n\t    this.getSelectionView = function(b) {\n\t        return d.hasOwnProperty(b) ? d[b] : null\n\t    }\n\t    ;\n\t    this.getSelectionViews = k;\n\t    this.removeSelectionView = function(b) {\n\t        d.hasOwnProperty(b) && (d[b].destroy(function() {}),\n\t        delete d[b])\n\t    }\n\t    ;\n\t    this.hideSelectionView = function(b) {\n\t        d.hasOwnProperty(b) && d[b].hide()\n\t    }\n\t    ;\n\t    this.showSelectionView = function(b) {\n\t        d.hasOwnProperty(b) && d[b].show()\n\t    }\n\t    ;\n\t    this.rerenderSelectionViews = function() {\n\t        Object.keys(d).forEach(function(b) {\n\t            d[b].rerender()\n\t        })\n\t    }\n\t    ;\n\t    this.registerCursor = function(b, f) {\n\t        var k = b.getMemberId()\n\t          , p = new g(b);\n\t        f ? p.show() : p.hide();\n\t        return d[k] = p\n\t    }\n\t    ;\n\t    this.destroy = function(b) {\n\t        function d(k, r) {\n\t            r ? b(r) : k < g.length ? g[k].destroy(function(b) {\n\t                d(k + 1, b)\n\t            }) : b()\n\t        }\n\t        var g = k();\n\t        d(0, void 0)\n\t    }\n\t}\n\t;\n\tgui.SessionViewOptions = function() {\n\t    this.caretBlinksOnRangeSelect = this.caretAvatarsInitiallyVisible = this.editInfoMarkersInitiallyVisible = !0\n\t}\n\t;\n\t(function() {\n\t    function g(g, d) {\n\t        return void 0 !== g ? Boolean(g) : d\n\t    }\n\t    gui.SessionView = function(k, d, b, f, n, p) {\n\t        function r(a) {\n\t            a.memberId === d && I.getViewport().scrollIntoView(a.annotation.getBoundingClientRect())\n\t        }\n\t        function q() {\n\t            var a = document.getElementsByTagName(\"head\").item(0)\n\t              , c = document.createElement(\"style\");\n\t            c.type = \"text/css\";\n\t            c.media = \"screen, print, handheld, projection\";\n\t            a.appendChild(c);\n\t            return c\n\t        }\n\t        function e(a, c, b) {\n\t            function e(c, b, d) {\n\t                b = c + '[editinfo|memberid=\"' + a + '\"]' + d + b;\n\t                a: {\n\t                    var f = v.firstChild;\n\t                    for (c = c + '[editinfo|memberid=\"' + a + '\"]' + d + \"{\"; f; ) {\n\t                        if (f.nodeType === Node.TEXT_NODE && 0 === f.data.indexOf(c)) {\n\t                            c = f;\n\t                            break a\n\t                        }\n\t                        f = f.nextSibling\n\t                    }\n\t                    c = null\n\t                }\n\t                c ? c.data = b : v.appendChild(document.createTextNode(b))\n\t            }\n\t            e(\"div.editInfoMarker\", \"{ background-color: \" + b + \"; }\", \"\");\n\t            e(\"span.editInfoColor\", \"{ background-color: \" + b + \"; }\", \"\");\n\t            e(\"span.editInfoAuthor\", '{ content: \"' + c + '\"; }', \":before\");\n\t            e(\"dc|creator\", \"{ background-color: \" + b + \"; }\", \"\");\n\t            e(\".webodf-selectionOverlay\", \"{ fill: \" + b + \"; stroke: \" + b + \";}\", \"\");\n\t            a === d && (e(\".webodf-touchEnabled .webodf-selectionOverlay\", \"{ display: block; }\", \" > .webodf-draggable\"),\n\t            a = gui.ShadowCursor.ShadowCursorMemberId,\n\t            e(\".webodf-selectionOverlay\", \"{ fill: \" + b + \"; stroke: \" + b + \";}\", \"\"),\n\t            e(\".webodf-touchEnabled .webodf-selectionOverlay\", \"{ display: block; }\", \" > .webodf-draggable\"))\n\t        }\n\t        function l(a) {\n\t            var c, b;\n\t            for (b in t)\n\t                t.hasOwnProperty(b) && (c = t[b],\n\t                a ? c.show() : c.hide())\n\t        }\n\t        function a(a) {\n\t            n.getCarets().forEach(function(c) {\n\t                a ? c.showHandle() : c.hideHandle()\n\t            })\n\t        }\n\t        function c(a) {\n\t            var c = a.getMemberId();\n\t            a = a.getProperties();\n\t            e(c, a.fullName, a.color)\n\t        }\n\t        function m(a) {\n\t            var c = a.getMemberId()\n\t              , d = b.getOdtDocument().getMember(c).getProperties();\n\t            n.registerCursor(a, E, N);\n\t            p.registerCursor(a, !0);\n\t            if (a = n.getCaret(c))\n\t                a.setAvatarImageUrl(d.imageUrl),\n\t                a.setColor(d.color);\n\t            runtime.log(\"+++ View here +++ eagerly created an Caret for '\" + c + \"'! +++\")\n\t        }\n\t        function h(a) {\n\t            a = a.getMemberId();\n\t            var c = p.getSelectionView(d)\n\t              , b = p.getSelectionView(gui.ShadowCursor.ShadowCursorMemberId)\n\t              , e = n.getCaret(d);\n\t            a === d ? (b.hide(),\n\t            c && c.show(),\n\t            e && e.show()) : a === gui.ShadowCursor.ShadowCursorMemberId && (b.show(),\n\t            c && c.hide(),\n\t            e && e.hide())\n\t        }\n\t        function y(a) {\n\t            p.removeSelectionView(a)\n\t        }\n\t        function x(a) {\n\t            var c = a.paragraphElement\n\t              , d = a.memberId;\n\t            a = a.timeStamp;\n\t            var e, f = \"\", h = c.getElementsByTagNameNS(\"urn:webodf:names:editinfo\", \"editinfo\").item(0);\n\t            h ? (f = h.getAttributeNS(\"urn:webodf:names:editinfo\", \"id\"),\n\t            e = t[f]) : (f = Math.random().toString(),\n\t            e = new ops.EditInfo(c,b.getOdtDocument()),\n\t            e = new gui.EditInfoMarker(e,L),\n\t            h = c.getElementsByTagNameNS(\"urn:webodf:names:editinfo\", \"editinfo\").item(0),\n\t            h.setAttributeNS(\"urn:webodf:names:editinfo\", \"id\", f),\n\t            t[f] = e);\n\t            e.addEdit(d, new Date(a));\n\t            K.trigger()\n\t        }\n\t        function z() {\n\t            var a;\n\t            u.hasChildNodes() && core.DomUtils.removeAllChildNodes(u);\n\t            !0 === f.getState(gui.CommonConstraints.EDIT.ANNOTATIONS.ONLY_DELETE_OWN) && (a = b.getOdtDocument().getMember(d)) && (a = a.getProperties().fullName,\n\t            u.appendChild(document.createTextNode(\".annotationWrapper:not([creator = '\" + a + \"']) .annotationRemoveButton { display: none; }\")))\n\t        }\n\t        function w(a) {\n\t            var b = Object.keys(t).map(function(a) {\n\t                return t[a]\n\t            });\n\t            A.unsubscribe(ops.Document.signalMemberAdded, c);\n\t            A.unsubscribe(ops.Document.signalMemberUpdated, c);\n\t            A.unsubscribe(ops.Document.signalCursorAdded, m);\n\t            A.unsubscribe(ops.Document.signalCursorRemoved, y);\n\t            A.unsubscribe(ops.OdtDocument.signalParagraphChanged, x);\n\t            A.unsubscribe(ops.Document.signalCursorMoved, h);\n\t            A.unsubscribe(ops.OdtDocument.signalParagraphChanged, p.rerenderSelectionViews);\n\t            A.unsubscribe(ops.OdtDocument.signalTableAdded, p.rerenderSelectionViews);\n\t            A.unsubscribe(ops.OdtDocument.signalParagraphStyleModified, p.rerenderSelectionViews);\n\t            f.unsubscribe(gui.CommonConstraints.EDIT.ANNOTATIONS.ONLY_DELETE_OWN, z);\n\t            A.unsubscribe(ops.Document.signalMemberAdded, z);\n\t            A.unsubscribe(ops.Document.signalMemberUpdated, z);\n\t            v.parentNode.removeChild(v);\n\t            u.parentNode.removeChild(u);\n\t            (function W(c, d) {\n\t                d ? a(d) : c < b.length ? b[c].destroy(function(a) {\n\t                    W(c + 1, a)\n\t                }) : a()\n\t            }\n\t            )(0, void 0)\n\t        }\n\t        var v, u, t = {}, A, I, K, L = g(k.editInfoMarkersInitiallyVisible, !0), E = g(k.caretAvatarsInitiallyVisible, !0), N = g(k.caretBlinksOnRangeSelect, !0);\n\t        this.showEditInfoMarkers = function() {\n\t            L || (L = !0,\n\t            l(L))\n\t        }\n\t        ;\n\t        this.hideEditInfoMarkers = function() {\n\t            L && (L = !1,\n\t            l(L))\n\t        }\n\t        ;\n\t        this.showCaretAvatars = function() {\n\t            E || (E = !0,\n\t            a(E))\n\t        }\n\t        ;\n\t        this.hideCaretAvatars = function() {\n\t            E && (E = !1,\n\t            a(E))\n\t        }\n\t        ;\n\t        this.getSession = function() {\n\t            return b\n\t        }\n\t        ;\n\t        this.getCaret = function(a) {\n\t            return n.getCaret(a)\n\t        }\n\t        ;\n\t        this.destroy = function(a) {\n\t            var c = [K.destroy, w];\n\t            A.unsubscribe(ops.OdtDocument.signalAnnotationAdded, r);\n\t            core.Async.destroyAll(c, a)\n\t        }\n\t        ;\n\t        A = b.getOdtDocument();\n\t        I = A.getOdfCanvas();\n\t        A.subscribe(ops.OdtDocument.signalAnnotationAdded, r);\n\t        A.subscribe(ops.Document.signalMemberAdded, c);\n\t        A.subscribe(ops.Document.signalMemberUpdated, c);\n\t        A.subscribe(ops.Document.signalCursorAdded, m);\n\t        A.subscribe(ops.Document.signalCursorRemoved, y);\n\t        A.subscribe(ops.OdtDocument.signalParagraphChanged, x);\n\t        A.subscribe(ops.Document.signalCursorMoved, h);\n\t        A.subscribe(ops.OdtDocument.signalParagraphChanged, p.rerenderSelectionViews);\n\t        A.subscribe(ops.OdtDocument.signalTableAdded, p.rerenderSelectionViews);\n\t        A.subscribe(ops.OdtDocument.signalParagraphStyleModified, p.rerenderSelectionViews);\n\t        f.subscribe(gui.CommonConstraints.EDIT.ANNOTATIONS.ONLY_DELETE_OWN, z);\n\t        A.subscribe(ops.Document.signalMemberAdded, z);\n\t        A.subscribe(ops.Document.signalMemberUpdated, z);\n\t        v = q();\n\t        v.appendChild(document.createTextNode(\"@namespace editinfo url(urn:webodf:names:editinfo);\"));\n\t        v.appendChild(document.createTextNode(\"@namespace dc url(http://purl.org/dc/elements/1.1/);\"));\n\t        u = q();\n\t        z();\n\t        K = core.Task.createRedrawTask(function() {\n\t            var a = I.getAnnotationViewManager();\n\t            a && (a.rehighlightAnnotations(),\n\t            A.fixCursorPositions())\n\t        })\n\t    }\n\t}\n\t)();\n\tgui.SvgSelectionView = function(g) {\n\t    function k() {\n\t        var a = c.getRootNode();\n\t        m !== a && (m = a,\n\t        h = c.getCanvas().getSizer(),\n\t        h.appendChild(x),\n\t        x.setAttribute(\"class\", \"webodf-selectionOverlay\"),\n\t        w.setAttribute(\"class\", \"webodf-draggable\"),\n\t        v.setAttribute(\"class\", \"webodf-draggable\"),\n\t        w.setAttribute(\"end\", \"left\"),\n\t        v.setAttribute(\"end\", \"right\"),\n\t        w.setAttribute(\"r\", 8),\n\t        v.setAttribute(\"r\", 8),\n\t        x.appendChild(z),\n\t        x.appendChild(w),\n\t        x.appendChild(v))\n\t    }\n\t    function d(a) {\n\t        a = a.getBoundingClientRect();\n\t        return Boolean(a && 0 !== a.height)\n\t    }\n\t    function b(a) {\n\t        var c = u.getTextElements(a, !0, !1)\n\t          , b = a.cloneRange()\n\t          , e = a.cloneRange();\n\t        a = a.cloneRange();\n\t        if (!c.length)\n\t            return null;\n\t        var f;\n\t        a: {\n\t            f = 0;\n\t            var h = c[f]\n\t              , g = b.startContainer === h ? b.startOffset : 0\n\t              , m = g;\n\t            b.setStart(h, g);\n\t            for (b.setEnd(h, m); !d(b); ) {\n\t                if (h.nodeType === Node.ELEMENT_NODE && m < h.childNodes.length)\n\t                    m = h.childNodes.length;\n\t                else if (h.nodeType === Node.TEXT_NODE && m < h.length)\n\t                    m += 1;\n\t                else if (c[f])\n\t                    h = c[f],\n\t                    f += 1,\n\t                    g = m = 0;\n\t                else {\n\t                    f = !1;\n\t                    break a\n\t                }\n\t                b.setStart(h, g);\n\t                b.setEnd(h, m)\n\t            }\n\t            f = !0\n\t        }\n\t        if (!f)\n\t            return null;\n\t        a: {\n\t            f = c.length - 1;\n\t            h = c[f];\n\t            m = g = e.endContainer === h ? e.endOffset : h.nodeType === Node.TEXT_NODE ? h.length : h.childNodes.length;\n\t            e.setStart(h, g);\n\t            for (e.setEnd(h, m); !d(e); ) {\n\t                if (h.nodeType === Node.ELEMENT_NODE && 0 < g)\n\t                    g = 0;\n\t                else if (h.nodeType === Node.TEXT_NODE && 0 < g)\n\t                    --g;\n\t                else if (c[f])\n\t                    h = c[f],\n\t                    --f,\n\t                    g = m = h.length || h.childNodes.length;\n\t                else {\n\t                    c = !1;\n\t                    break a\n\t                }\n\t                e.setStart(h, g);\n\t                e.setEnd(h, m)\n\t            }\n\t            c = !0\n\t        }\n\t        if (!c)\n\t            return null;\n\t        a.setStart(b.startContainer, b.startOffset);\n\t        a.setEnd(e.endContainer, e.endOffset);\n\t        return {\n\t            firstRange: b,\n\t            lastRange: e,\n\t            fillerRange: a\n\t        }\n\t    }\n\t    function f(a, c) {\n\t        var b = {};\n\t        b.top = Math.min(a.top, c.top);\n\t        b.left = Math.min(a.left, c.left);\n\t        b.right = Math.max(a.right, c.right);\n\t        b.bottom = Math.max(a.bottom, c.bottom);\n\t        b.width = b.right - b.left;\n\t        b.height = b.bottom - b.top;\n\t        return b\n\t    }\n\t    function n(a, c) {\n\t        c && 0 < c.width && 0 < c.height && (a = a ? f(a, c) : c);\n\t        return a\n\t    }\n\t    function p(a) {\n\t        function b(a) {\n\t            K.setUnfilteredPosition(a, 0);\n\t            return v.acceptNode(a) === L && x.acceptPosition(K) === L ? L : E\n\t        }\n\t        function d(a) {\n\t            var c = null;\n\t            b(a) === L && (c = t.getBoundingClientRect(a));\n\t            return c\n\t        }\n\t        var e = a.commonAncestorContainer, f = a.startContainer, h = a.endContainer, g = a.startOffset, m = a.endOffset, k, l, p = null, r, q = y.createRange(), x, v = new odf.OdfNodeFilter, w;\n\t        if (f === e || h === e)\n\t            return q = a.cloneRange(),\n\t            p = q.getBoundingClientRect(),\n\t            q.detach(),\n\t            p;\n\t        for (a = f; a.parentNode !== e; )\n\t            a = a.parentNode;\n\t        for (l = h; l.parentNode !== e; )\n\t            l = l.parentNode;\n\t        x = c.createRootFilter(f);\n\t        for (e = a.nextSibling; e && e !== l; )\n\t            r = d(e),\n\t            p = n(p, r),\n\t            e = e.nextSibling;\n\t        if (u.isParagraph(a))\n\t            p = n(p, t.getBoundingClientRect(a));\n\t        else if (a.nodeType === Node.TEXT_NODE)\n\t            e = a,\n\t            q.setStart(e, g),\n\t            q.setEnd(e, e === l ? m : e.length),\n\t            r = q.getBoundingClientRect(),\n\t            p = n(p, r);\n\t        else\n\t            for (w = y.createTreeWalker(a, NodeFilter.SHOW_TEXT, b, !1),\n\t            e = w.currentNode = f; e && e !== h; )\n\t                q.setStart(e, g),\n\t                q.setEnd(e, e.length),\n\t                r = q.getBoundingClientRect(),\n\t                p = n(p, r),\n\t                k = e,\n\t                g = 0,\n\t                e = w.nextNode();\n\t        k || (k = f);\n\t        if (u.isParagraph(l))\n\t            p = n(p, t.getBoundingClientRect(l));\n\t        else if (l.nodeType === Node.TEXT_NODE)\n\t            e = l,\n\t            q.setStart(e, e === a ? g : 0),\n\t            q.setEnd(e, m),\n\t            r = q.getBoundingClientRect(),\n\t            p = n(p, r);\n\t        else\n\t            for (w = y.createTreeWalker(l, NodeFilter.SHOW_TEXT, b, !1),\n\t            e = w.currentNode = h; e && e !== k; )\n\t                if (q.setStart(e, 0),\n\t                q.setEnd(e, m),\n\t                r = q.getBoundingClientRect(),\n\t                p = n(p, r),\n\t                e = w.previousNode())\n\t                    m = e.length;\n\t        return p\n\t    }\n\t    function r(a, c) {\n\t        var b = a.getBoundingClientRect()\n\t          , d = {\n\t            width: 0\n\t        };\n\t        d.top = b.top;\n\t        d.bottom = b.bottom;\n\t        d.height = b.height;\n\t        d.left = d.right = c ? b.right : b.left;\n\t        return d\n\t    }\n\t    function q() {\n\t        var a = g.getSelectedRange(), c;\n\t        if (c = I && g.getSelectionType() === ops.OdtCursor.RangeSelection && !a.collapsed) {\n\t            k();\n\t            var d = t.getBoundingClientRect(h), e = A.getZoomLevel(), a = b(a), m, l, n, q, y, u;\n\t            if (a) {\n\t                c = a.firstRange;\n\t                m = a.lastRange;\n\t                l = a.fillerRange;\n\t                n = t.translateRect(r(c, !1), d, e);\n\t                y = t.translateRect(r(m, !0), d, e);\n\t                q = (q = p(l)) ? t.translateRect(q, d, e) : f(n, y);\n\t                u = q.left;\n\t                q = n.left + Math.max(0, q.width - (n.left - q.left));\n\t                d = Math.min(n.top, y.top);\n\t                e = y.top + y.height;\n\t                u = [{\n\t                    x: n.left,\n\t                    y: d + n.height\n\t                }, {\n\t                    x: n.left,\n\t                    y: d\n\t                }, {\n\t                    x: q,\n\t                    y: d\n\t                }, {\n\t                    x: q,\n\t                    y: e - y.height\n\t                }, {\n\t                    x: y.right,\n\t                    y: e - y.height\n\t                }, {\n\t                    x: y.right,\n\t                    y: e\n\t                }, {\n\t                    x: u,\n\t                    y: e\n\t                }, {\n\t                    x: u,\n\t                    y: d + n.height\n\t                }, {\n\t                    x: n.left,\n\t                    y: d + n.height\n\t                }];\n\t                q = \"\";\n\t                var E;\n\t                for (E = 0; E < u.length; E += 1)\n\t                    q += u[E].x + \",\" + u[E].y + \" \";\n\t                z.setAttribute(\"points\", q);\n\t                w.setAttribute(\"cx\", n.left);\n\t                w.setAttribute(\"cy\", d + n.height / 2);\n\t                v.setAttribute(\"cx\", y.right);\n\t                v.setAttribute(\"cy\", e - y.height / 2);\n\t                c.detach();\n\t                m.detach();\n\t                l.detach()\n\t            }\n\t            c = Boolean(a)\n\t        }\n\t        x.style.display = c ? \"block\" : \"none\"\n\t    }\n\t    function e(a) {\n\t        I && a === g && N.trigger()\n\t    }\n\t    function l(a) {\n\t        a = 8 / a;\n\t        w.setAttribute(\"r\", a);\n\t        v.setAttribute(\"r\", a)\n\t    }\n\t    function a(a) {\n\t        h.removeChild(x);\n\t        h.classList.remove(\"webodf-virtualSelections\");\n\t        g.getDocument().unsubscribe(ops.Document.signalCursorMoved, e);\n\t        A.unsubscribe(gui.ZoomHelper.signalZoomChanged, l);\n\t        a()\n\t    }\n\t    var c = g.getDocument(), m, h, y = c.getDOMDocument(), x = y.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\"), z = y.createElementNS(\"http://www.w3.org/2000/svg\", \"polygon\"), w = y.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\"), v = y.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\"), u = odf.OdfUtils, t = core.DomUtils, A = c.getCanvas().getZoomHelper(), I = !0, K = g.getDocument().createPositionIterator(c.getRootNode()), L = NodeFilter.FILTER_ACCEPT, E = NodeFilter.FILTER_REJECT, N;\n\t    this.rerender = function() {\n\t        I && N.trigger()\n\t    }\n\t    ;\n\t    this.show = function() {\n\t        I = !0;\n\t        N.trigger()\n\t    }\n\t    ;\n\t    this.hide = function() {\n\t        I = !1;\n\t        N.trigger()\n\t    }\n\t    ;\n\t    this.destroy = function(c) {\n\t        core.Async.destroyAll([N.destroy, a], c)\n\t    }\n\t    ;\n\t    (function() {\n\t        var a = g.getMemberId();\n\t        N = core.Task.createRedrawTask(q);\n\t        k();\n\t        x.setAttributeNS(\"urn:webodf:names:editinfo\", \"editinfo:memberid\", a);\n\t        h.classList.add(\"webodf-virtualSelections\");\n\t        g.getDocument().subscribe(ops.Document.signalCursorMoved, e);\n\t        A.subscribe(gui.ZoomHelper.signalZoomChanged, l);\n\t        l(A.getZoomLevel())\n\t    }\n\t    )()\n\t}\n\t;\n\tgui.UndoStateRules = function() {\n\t    function g(b, d) {\n\t        var g = b.length;\n\t        this.previous = function() {\n\t            for (--g; 0 <= g; --g)\n\t                if (d(b[g]))\n\t                    return b[g];\n\t            return null\n\t        }\n\t    }\n\t    function k(b) {\n\t        b = b.spec();\n\t        var d;\n\t        b.hasOwnProperty(\"position\") && (d = b.position);\n\t        return d\n\t    }\n\t    function d(b) {\n\t        return b.isEdit\n\t    }\n\t    function b(b, d, g) {\n\t        if (!g)\n\t            return g = k(b) - k(d),\n\t            0 === g || 1 === Math.abs(g);\n\t        b = k(b);\n\t        d = k(d);\n\t        g = k(g);\n\t        return b - d === d - g\n\t    }\n\t    this.isEditOperation = d;\n\t    this.isPartOfOperationSet = function(f, k) {\n\t        var p = void 0 !== f.group, r;\n\t        if (!f.isEdit || 0 === k.length)\n\t            return !0;\n\t        r = k[k.length - 1];\n\t        if (p && f.group === r.group)\n\t            return !0;\n\t        a: switch (f.spec().optype) {\n\t        case \"RemoveText\":\n\t        case \"InsertText\":\n\t            r = !0;\n\t            break a;\n\t        default:\n\t            r = !1\n\t        }\n\t        if (r && k.some(d)) {\n\t            if (p) {\n\t                var q;\n\t                p = f.spec().optype;\n\t                r = new g(k,d);\n\t                var e = r.previous(), l = null, a, c;\n\t                runtime.assert(Boolean(e), \"No edit operations found in state\");\n\t                c = e.group;\n\t                runtime.assert(void 0 !== c, \"Operation has no group\");\n\t                for (a = 1; e && e.group === c; ) {\n\t                    if (p === e.spec().optype) {\n\t                        q = e;\n\t                        break\n\t                    }\n\t                    e = r.previous()\n\t                }\n\t                if (q) {\n\t                    for (e = r.previous(); e; ) {\n\t                        if (e.group !== c) {\n\t                            if (2 === a)\n\t                                break;\n\t                            c = e.group;\n\t                            a += 1\n\t                        }\n\t                        if (p === e.spec().optype) {\n\t                            l = e;\n\t                            break\n\t                        }\n\t                        e = r.previous()\n\t                    }\n\t                    q = b(f, q, l)\n\t                } else\n\t                    q = !1;\n\t                return q\n\t            }\n\t            q = f.spec().optype;\n\t            p = new g(k,d);\n\t            r = p.previous();\n\t            runtime.assert(Boolean(r), \"No edit operations found in state\");\n\t            q = q === r.spec().optype ? b(f, r, p.previous()) : !1;\n\t            return q\n\t        }\n\t        return !1\n\t    }\n\t}\n\t;\n\t(function() {\n\t    function g(b, d) {\n\t        this.mainId = void 0 !== b ? b : -1;\n\t        this.subId = void 0 !== d ? d : -1\n\t    }\n\t    function k(b, f, k) {\n\t        function p(d, a) {\n\t            return d + (b.isEditOperation(a) ? 1 : 0)\n\t        }\n\t        var r, q, e;\n\t        this.addOperation = function(d) {\n\t            b.isEditOperation(d) && (e += 1);\n\t            q.push(d)\n\t        }\n\t        ;\n\t        this.isNextStateId = function(b) {\n\t            return b.mainId === r && b.subId === e\n\t        }\n\t        ;\n\t        this.getNextStateId = function() {\n\t            return new g(r,e)\n\t        }\n\t        ;\n\t        this.getOperations = function() {\n\t            return q\n\t        }\n\t        ;\n\t        r = d += 1;\n\t        q = f || [];\n\t        e = f && k ? f.reduce(p, 0) : 0\n\t    }\n\t    var d = 0;\n\t    gui.TrivialUndoManager = function(b) {\n\t        function d() {\n\t            return !0 !== u.isNextStateId(v)\n\t        }\n\t        function n(a) {\n\t            a = a.getOperations();\n\t            0 < a.length && (L = !0,\n\t            z(a),\n\t            L = !1)\n\t        }\n\t        function p() {\n\t            I.emit(gui.UndoManager.signalUndoStackChanged, {\n\t                undoAvailable: m.hasUndoStates(),\n\t                redoAvailable: m.hasRedoStates()\n\t            })\n\t        }\n\t        function r(a) {\n\t            var c = d();\n\t            a !== c && I.emit(gui.UndoManager.signalDocumentModifiedChanged, c)\n\t        }\n\t        function q() {\n\t            u !== x && u !== t[t.length - 1] && t.push(u)\n\t        }\n\t        function e(a) {\n\t            var c = a.previousSibling || a.nextSibling;\n\t            a.parentNode.removeChild(a);\n\t            h.normalizeTextNodes(c)\n\t        }\n\t        function l(a) {\n\t            return Object.keys(a).map(function(c) {\n\t                return a[c]\n\t            })\n\t        }\n\t        function a(a) {\n\t            function c(a) {\n\t                var h = a.spec();\n\t                if (e[h.memberid])\n\t                    switch (h.optype) {\n\t                    case \"AddCursor\":\n\t                        b[h.memberid] || (b[h.memberid] = a,\n\t                        delete e[h.memberid],\n\t                        --f);\n\t                        break;\n\t                    case \"MoveCursor\":\n\t                        d[h.memberid] || (d[h.memberid] = a)\n\t                    }\n\t            }\n\t            var b = {}, d = {}, e = {}, f, h;\n\t            h = a.pop();\n\t            w.getMemberIds().forEach(function(a) {\n\t                e[a] = !0\n\t            });\n\t            for (f = Object.keys(e).length; h && 0 < f; )\n\t                h = h.getOperations(),\n\t                h.reverse(),\n\t                h.forEach(c),\n\t                h = a.pop();\n\t            return new k(K,l(b).concat(l(d)))\n\t        }\n\t        function c() {\n\t            var c = d()\n\t              , b = y = w.cloneDocumentElement();\n\t            h.getElementsByTagNameNS(b, \"urn:webodf:names:cursor\", \"cursor\").forEach(e);\n\t            h.getElementsByTagNameNS(b, \"urn:webodf:names:cursor\", \"anchor\").forEach(e);\n\t            q();\n\t            u = x = a([x].concat(t));\n\t            t.length = 0;\n\t            A.length = 0;\n\t            c || (v = u.getNextStateId());\n\t            p();\n\t            r(c)\n\t        }\n\t        var m = this, h = core.DomUtils, y, x, z, w, v, u, t = [], A = [], I = new core.EventNotifier([gui.UndoManager.signalUndoStackChanged, gui.UndoManager.signalUndoStateCreated, gui.UndoManager.signalUndoStateModified, gui.UndoManager.signalDocumentModifiedChanged, gui.TrivialUndoManager.signalDocumentRootReplaced]), K = b || new gui.UndoStateRules, L = !1;\n\t        this.subscribe = function(a, c) {\n\t            I.subscribe(a, c)\n\t        }\n\t        ;\n\t        this.unsubscribe = function(a, c) {\n\t            I.unsubscribe(a, c)\n\t        }\n\t        ;\n\t        this.isDocumentModified = d;\n\t        this.setDocumentModified = function(a) {\n\t            d() !== a && (v = a ? new g : u.getNextStateId(),\n\t            I.emit(gui.UndoManager.signalDocumentModifiedChanged, a))\n\t        }\n\t        ;\n\t        this.hasUndoStates = function() {\n\t            return 0 < t.length\n\t        }\n\t        ;\n\t        this.hasRedoStates = function() {\n\t            return 0 < A.length\n\t        }\n\t        ;\n\t        this.setDocument = function(a) {\n\t            w = a\n\t        }\n\t        ;\n\t        this.purgeInitialState = function() {\n\t            var a = d();\n\t            t.length = 0;\n\t            A.length = 0;\n\t            u = x = new k(K);\n\t            v = u.getNextStateId();\n\t            y = null;\n\t            p();\n\t            r(a)\n\t        }\n\t        ;\n\t        this.setInitialState = c;\n\t        this.initialize = function() {\n\t            y || c()\n\t        }\n\t        ;\n\t        this.setPlaybackFunction = function(a) {\n\t            z = a\n\t        }\n\t        ;\n\t        this.onOperationExecuted = function(a) {\n\t            if (!L) {\n\t                var c = d();\n\t                K.isEditOperation(a) && (u === x || 0 < A.length) || !K.isPartOfOperationSet(a, u.getOperations()) ? (A.length = 0,\n\t                q(),\n\t                u = new k(K,[a],!0),\n\t                t.push(u),\n\t                I.emit(gui.UndoManager.signalUndoStateCreated, {\n\t                    operations: u.getOperations()\n\t                }),\n\t                p()) : (u.addOperation(a),\n\t                I.emit(gui.UndoManager.signalUndoStateModified, {\n\t                    operations: u.getOperations()\n\t                }));\n\t                r(c)\n\t            }\n\t        }\n\t        ;\n\t        this.moveForward = function(a) {\n\t            for (var c = 0, b = d(), e; a && A.length; )\n\t                e = A.pop(),\n\t                t.push(e),\n\t                n(e),\n\t                --a,\n\t                c += 1;\n\t            c && (u = t[t.length - 1],\n\t            p(),\n\t            r(b));\n\t            return c\n\t        }\n\t        ;\n\t        this.moveBackward = function(a) {\n\t            for (var c = 0, b = d(); a && t.length; )\n\t                A.push(t.pop()),\n\t                --a,\n\t                c += 1;\n\t            c && (w.getMemberIds().forEach(function(a) {\n\t                w.hasCursor(a) && w.removeCursor(a)\n\t            }),\n\t            w.setDocumentElement(y.cloneNode(!0)),\n\t            I.emit(gui.TrivialUndoManager.signalDocumentRootReplaced, {}),\n\t            n(x),\n\t            t.forEach(n),\n\t            u = t[t.length - 1] || x,\n\t            p(),\n\t            r(b));\n\t            return c\n\t        }\n\t        ;\n\t        u = x = new k(K);\n\t        v = u.getNextStateId()\n\t    }\n\t    ;\n\t    gui.TrivialUndoManager.signalDocumentRootReplaced = \"documentRootReplaced\"\n\t}\n\t)();\n\todf.GraphicProperties = function(g, k, d) {\n\t    var b = this\n\t      , f = odf.Namespaces.stylens\n\t      , n = odf.Namespaces.svgns;\n\t    this.verticalPos = function() {\n\t        return b.data.value(\"verticalPos\")\n\t    }\n\t    ;\n\t    this.verticalRel = function() {\n\t        return b.data.value(\"verticalRel\")\n\t    }\n\t    ;\n\t    this.horizontalPos = function() {\n\t        return b.data.value(\"horizontalPos\")\n\t    }\n\t    ;\n\t    this.horizontalRel = function() {\n\t        return b.data.value(\"horizontalRel\")\n\t    }\n\t    ;\n\t    this.strokeWidth = function() {\n\t        return b.data.value(\"strokeWidth\")\n\t    }\n\t    ;\n\t    b.data = new odf.LazyStyleProperties(void 0 === d ? void 0 : d.data,{\n\t        verticalPos: function() {\n\t            var b = g.getAttributeNS(f, \"vertical-pos\");\n\t            return \"\" === b ? void 0 : b\n\t        },\n\t        verticalRel: function() {\n\t            var b = g.getAttributeNS(f, \"vertical-rel\");\n\t            return \"\" === b ? void 0 : b\n\t        },\n\t        horizontalPos: function() {\n\t            var b = g.getAttributeNS(f, \"horizontal-pos\");\n\t            return \"\" === b ? void 0 : b\n\t        },\n\t        horizontalRel: function() {\n\t            var b = g.getAttributeNS(f, \"horizontal-rel\");\n\t            return \"\" === b ? void 0 : b\n\t        },\n\t        strokeWidth: function() {\n\t            var b = g.getAttributeNS(n, \"stroke-width\");\n\t            return k.parseLength(b)\n\t        }\n\t    })\n\t}\n\t;\n\todf.ComputedGraphicProperties = function() {\n\t    var g;\n\t    this.setGraphicProperties = function(k) {\n\t        g = k\n\t    }\n\t    ;\n\t    this.verticalPos = function() {\n\t        return g && g.verticalPos() || \"from-top\"\n\t    }\n\t    ;\n\t    this.verticalRel = function() {\n\t        return g && g.verticalRel() || \"page\"\n\t    }\n\t    ;\n\t    this.horizontalPos = function() {\n\t        return g && g.horizontalPos() || \"from-left\"\n\t    }\n\t    ;\n\t    this.horizontalRel = function() {\n\t        return g && g.horizontalRel() || \"page\"\n\t    }\n\t}\n\t;\n\todf.PageLayoutProperties = function(g, k, d) {\n\t    var b = this\n\t      , f = odf.Namespaces.fons;\n\t    this.pageHeight = function() {\n\t        return b.data.value(\"pageHeight\") || 1123\n\t    }\n\t    ;\n\t    this.pageWidth = function() {\n\t        return b.data.value(\"pageWidth\") || 794\n\t    }\n\t    ;\n\t    b.data = new odf.LazyStyleProperties(void 0 === d ? void 0 : d.data,{\n\t        pageHeight: function() {\n\t            var b;\n\t            g && (b = g.getAttributeNS(f, \"page-height\"),\n\t            b = k.parseLength(b));\n\t            return b\n\t        },\n\t        pageWidth: function() {\n\t            var b;\n\t            g && (b = g.getAttributeNS(f, \"page-width\"),\n\t            b = k.parseLength(b));\n\t            return b\n\t        }\n\t    })\n\t}\n\t;\n\todf.PageLayout = function(g, k, d) {\n\t    var b = null;\n\t    g && (b = k.getPropertiesElement(\"page-layout-properties\", g));\n\t    this.pageLayout = new odf.PageLayoutProperties(b,k,d && d.pageLayout)\n\t}\n\t;\n\todf.PageLayoutCache = function() {}\n\t;\n\todf.PageLayoutCache.prototype.getPageLayout = function(g) {}\n\t;\n\todf.PageLayoutCache.prototype.getDefaultPageLayout = function() {}\n\t;\n\todf.ParagraphProperties = function(g, k, d) {\n\t    var b = this\n\t      , f = odf.Namespaces.fons;\n\t    this.marginTop = function() {\n\t        return b.data.value(\"marginTop\")\n\t    }\n\t    ;\n\t    b.data = new odf.LazyStyleProperties(void 0 === d ? void 0 : d.data,{\n\t        marginTop: function() {\n\t            var b = g.getAttributeNS(f, \"margin-top\");\n\t            return k.parsePositiveLengthOrPercent(b, \"marginTop\", d && d.data)\n\t        }\n\t    })\n\t}\n\t;\n\todf.ComputedParagraphProperties = function() {\n\t    var g = {}\n\t      , k = [];\n\t    this.setStyleChain = function(d) {\n\t        k = d;\n\t        g = {}\n\t    }\n\t    ;\n\t    this.marginTop = function() {\n\t        var d, b;\n\t        if (g.hasOwnProperty(\"marginTop\"))\n\t            d = g.marginTop;\n\t        else {\n\t            for (b = 0; void 0 === d && b < k.length; b += 1)\n\t                d = k[b].marginTop();\n\t            g.marginTop = d\n\t        }\n\t        return d || 0\n\t    }\n\t}\n\t;\n\todf.TextProperties = function(g, k, d) {\n\t    var b = this\n\t      , f = odf.Namespaces.fons;\n\t    this.fontSize = function() {\n\t        return b.data.value(\"fontSize\")\n\t    }\n\t    ;\n\t    b.data = new odf.LazyStyleProperties(void 0 === d ? void 0 : d.data,{\n\t        fontSize: function() {\n\t            var b = g.getAttributeNS(f, \"font-size\");\n\t            return k.parsePositiveLengthOrPercent(b, \"fontSize\", d && d.data)\n\t        }\n\t    })\n\t}\n\t;\n\todf.ComputedTextProperties = function() {\n\t    var g = {}\n\t      , k = [];\n\t    this.setStyleChain = function(d) {\n\t        k = d;\n\t        g = {}\n\t    }\n\t    ;\n\t    this.fontSize = function() {\n\t        var d, b;\n\t        if (g.hasOwnProperty(\"fontSize\"))\n\t            d = g.fontSize;\n\t        else {\n\t            for (b = 0; void 0 === d && b < k.length; b += 1)\n\t                d = k[b].fontSize();\n\t            g.fontSize = d\n\t        }\n\t        return d || 12\n\t    }\n\t}\n\t;\n\todf.MasterPage = function(g, k) {\n\t    var d;\n\t    g ? (d = g.getAttributeNS(odf.Namespaces.stylens, \"page-layout-name\"),\n\t    this.pageLayout = k.getPageLayout(d)) : this.pageLayout = k.getDefaultPageLayout()\n\t}\n\t;\n\todf.MasterPageCache = function() {}\n\t;\n\todf.MasterPageCache.prototype.getMasterPage = function(g) {}\n\t;\n\todf.StylePileEntry = function(g, k, d, b) {\n\t    this.masterPage = function() {\n\t        var b = g.getAttributeNS(odf.Namespaces.stylens, \"master-page-name\")\n\t          , k = null;\n\t        b && (k = d.getMasterPage(b));\n\t        return k\n\t    }\n\t    ;\n\t    (function(d) {\n\t        var n = g.getAttributeNS(odf.Namespaces.stylens, \"family\")\n\t          , p = null;\n\t        if (\"graphic\" === n || \"chart\" === n)\n\t            d.graphic = void 0 === b ? void 0 : b.graphic,\n\t            p = k.getPropertiesElement(\"graphic-properties\", g, p),\n\t            null !== p && (d.graphic = new odf.GraphicProperties(p,k,d.graphic));\n\t        if (\"paragraph\" === n || \"table-cell\" === n || \"graphic\" === n || \"presentation\" === n || \"chart\" === n)\n\t            d.paragraph = void 0 === b ? void 0 : b.paragraph,\n\t            p = k.getPropertiesElement(\"paragraph-properties\", g, p),\n\t            null !== p && (d.paragraph = new odf.ParagraphProperties(p,k,d.paragraph));\n\t        if (\"text\" === n || \"paragraph\" === n || \"table-cell\" === n || \"graphic\" === n || \"presentation\" === n || \"chart\" === n)\n\t            d.text = void 0 === b ? void 0 : b.text,\n\t            p = k.getPropertiesElement(\"text-properties\", g, p),\n\t            null !== p && (d.text = new odf.TextProperties(p,k,d.text))\n\t    }\n\t    )(this)\n\t}\n\t;\n\todf.StylePile = function(g, k) {\n\t    function d(d, a) {\n\t        var c, f;\n\t        d.hasAttributeNS(b, \"parent-style-name\") && (f = d.getAttributeNS(b, \"parent-style-name\"),\n\t        -1 === a.indexOf(f) && (c = e(f, a)));\n\t        return new odf.StylePileEntry(d,g,k,c)\n\t    }\n\t    var b = odf.Namespaces.stylens, f = {}, n = {}, p, r = {}, q = {}, e;\n\t    e = function(b, a) {\n\t        var c = r[b], e;\n\t        !c && (e = f[b]) && (a.push(b),\n\t        c = d(e, a),\n\t        r[b] = c);\n\t        return c\n\t    }\n\t    ;\n\t    this.getStyle = function(b) {\n\t        var a = q[b] || r[b], c, e = [];\n\t        a || (c = n[b],\n\t        c || (c = f[b]) && e.push(b),\n\t        c && (a = d(c, e)));\n\t        return a\n\t    }\n\t    ;\n\t    this.addCommonStyle = function(d) {\n\t        var a;\n\t        d.hasAttributeNS(b, \"name\") && (a = d.getAttributeNS(b, \"name\"),\n\t        f.hasOwnProperty(a) || (f[a] = d))\n\t    }\n\t    ;\n\t    this.addAutomaticStyle = function(d) {\n\t        var a;\n\t        d.hasAttributeNS(b, \"name\") && (a = d.getAttributeNS(b, \"name\"),\n\t        n.hasOwnProperty(a) || (n[a] = d))\n\t    }\n\t    ;\n\t    this.setDefaultStyle = function(b) {\n\t        void 0 === p && (p = d(b, []))\n\t    }\n\t    ;\n\t    this.getDefaultStyle = function() {\n\t        return p\n\t    }\n\t}\n\t;\n\todf.ComputedGraphicStyle = function() {\n\t    this.text = new odf.ComputedTextProperties;\n\t    this.paragraph = new odf.ComputedParagraphProperties;\n\t    this.graphic = new odf.ComputedGraphicProperties\n\t}\n\t;\n\todf.ComputedParagraphStyle = function() {\n\t    this.text = new odf.ComputedTextProperties;\n\t    this.paragraph = new odf.ComputedParagraphProperties\n\t}\n\t;\n\todf.ComputedTextStyle = function() {\n\t    this.text = new odf.ComputedTextProperties\n\t}\n\t;\n\todf.StyleCache = function(g) {\n\t    function k(a, c, b, d) {\n\t        c = b.getAttributeNS(c, \"class-names\");\n\t        var e;\n\t        if (c)\n\t            for (c = c.split(\" \"),\n\t            e = 0; e < c.length; e += 1)\n\t                if (b = c[e])\n\t                    d.push(a),\n\t                    d.push(b)\n\t    }\n\t    function d(a, c) {\n\t        var b = x.getStyleName(\"paragraph\", a);\n\t        void 0 !== b && (c.push(\"paragraph\"),\n\t        c.push(b));\n\t        a.namespaceURI !== h || \"h\" !== a.localName && \"p\" !== a.localName || k(\"paragraph\", h, a, c);\n\t        return c\n\t    }\n\t    function b(a, c, b) {\n\t        var d = [], e, h, f, g;\n\t        for (e = 0; e < a.length; e += 2)\n\t            f = a[e],\n\t            g = a[e + 1],\n\t            f = r[f],\n\t            g = f.getStyle(g),\n\t            void 0 !== g && (g = g[c],\n\t            void 0 !== g && g !== h && (d.push(g),\n\t            h = g));\n\t        f = r[b];\n\t        if (g = f.getDefaultStyle())\n\t            g = g[c],\n\t            void 0 !== g && g !== h && d.push(g);\n\t        return d\n\t    }\n\t    function f(a, c) {\n\t        var b = x.getStyleName(\"text\", a)\n\t          , e = a.parentNode;\n\t        void 0 !== b && (c.push(\"text\"),\n\t        c.push(b));\n\t        \"span\" === a.localName && a.namespaceURI === h && k(\"text\", h, a, c);\n\t        if (!e || e === g)\n\t            return c;\n\t        e.namespaceURI !== h || \"p\" !== e.localName && \"h\" !== e.localName ? f(e, c) : d(e, c);\n\t        return c\n\t    }\n\t    function n(a) {\n\t        a = a.getAttributeNS(y, \"family\");\n\t        return r[a]\n\t    }\n\t    var p = this, r, q, e, l, a, c, m, h = odf.Namespaces.textns, y = odf.Namespaces.stylens, x = new odf.StyleInfo, z = new odf.StyleParseUtils, w, v, u, t, A, I;\n\t    this.getComputedGraphicStyle = function(a) {\n\t        var c = [];\n\t        a = x.getStyleName(\"graphic\", a);\n\t        void 0 !== a && (c.push(\"graphic\"),\n\t        c.push(a));\n\t        a = c.join(\"/\");\n\t        var d = l[a];\n\t        runtime.assert(0 === c.length % 2, \"Invalid style chain.\");\n\t        void 0 === d && (d = new odf.ComputedGraphicStyle,\n\t        d.graphic.setGraphicProperties(b(c, \"graphic\", \"graphic\")[0]),\n\t        d.text.setStyleChain(b(c, \"text\", \"graphic\")),\n\t        d.paragraph.setStyleChain(b(c, \"paragraph\", \"graphic\")),\n\t        l[a] = d);\n\t        return d\n\t    }\n\t    ;\n\t    this.getComputedParagraphStyle = function(a) {\n\t        a = d(a, []);\n\t        var c = a.join(\"/\")\n\t          , f = e[c];\n\t        runtime.assert(0 === a.length % 2, \"Invalid style chain.\");\n\t        void 0 === f && (f = new odf.ComputedParagraphStyle,\n\t        f.text.setStyleChain(b(a, \"text\", \"paragraph\")),\n\t        f.paragraph.setStyleChain(b(a, \"paragraph\", \"paragraph\")),\n\t        e[c] = f);\n\t        return f\n\t    }\n\t    ;\n\t    this.getComputedTextStyle = function(a) {\n\t        a = f(a, []);\n\t        var c = a.join(\"/\")\n\t          , d = q[c];\n\t        runtime.assert(0 === a.length % 2, \"Invalid style chain.\");\n\t        void 0 === d && (d = new odf.ComputedTextStyle,\n\t        d.text.setStyleChain(b(a, \"text\", \"text\")),\n\t        q[c] = d);\n\t        return d\n\t    }\n\t    ;\n\t    this.getPageLayout = function(a) {\n\t        var c = I[a];\n\t        c || ((c = A[a]) ? (c = new odf.PageLayout(c,z,t),\n\t        I[a] = c) : c = t);\n\t        return c\n\t    }\n\t    ;\n\t    this.getDefaultPageLayout = function() {\n\t        return t\n\t    }\n\t    ;\n\t    this.getMasterPage = function(a) {\n\t        var c = v[a];\n\t        void 0 === c && ((c = w[a]) ? (c = new odf.MasterPage(c,p),\n\t        v[a] = c) : c = null);\n\t        return c\n\t    }\n\t    ;\n\t    this.getDefaultMasterPage = function() {\n\t        return u\n\t    }\n\t    ;\n\t    this.update = function() {\n\t        var b, d, f = null, h = null;\n\t        q = {};\n\t        e = {};\n\t        l = {};\n\t        w = {};\n\t        v = {};\n\t        I = {};\n\t        A = {};\n\t        a = new odf.StylePile(z,p);\n\t        c = new odf.StylePile(z,p);\n\t        m = new odf.StylePile(z,p);\n\t        r = {\n\t            text: a,\n\t            paragraph: c,\n\t            graphic: m\n\t        };\n\t        for (b = g.styles.firstElementChild; b; )\n\t            b.namespaceURI === y && ((d = n(b)) ? \"style\" === b.localName ? d.addCommonStyle(b) : \"default-style\" === b.localName && d.setDefaultStyle(b) : \"default-page-layout\" === b.localName && (f = b)),\n\t            b = b.nextElementSibling;\n\t        t = new odf.PageLayout(f,z);\n\t        for (b = g.automaticStyles.firstElementChild; b; )\n\t            b.namespaceURI === y && ((d = n(b)) && \"style\" === b.localName ? d.addAutomaticStyle(b) : \"page-layout\" === b.localName && (A[b.getAttributeNS(y, \"name\")] = b)),\n\t            b = b.nextElementSibling;\n\t        for (b = g.masterStyles.firstElementChild; b; )\n\t            b.namespaceURI === y && \"master-page\" === b.localName && (h = h || b,\n\t            d = b,\n\t            f = d.getAttributeNS(y, \"name\"),\n\t            0 < f.length && !w.hasOwnProperty(f) && (w[f] = d)),\n\t            b = b.nextElementSibling;\n\t        u = new odf.MasterPage(h,p)\n\t    }\n\t}\n\t;\n\tops.OperationTransformMatrix = function() {\n\t    function g(a) {\n\t        a.position += a.length;\n\t        a.length *= -1\n\t    }\n\t    function k(a) {\n\t        var c = 0 > a.length;\n\t        c && g(a);\n\t        return c\n\t    }\n\t    function d(a, c) {\n\t        function b(e) {\n\t            a[e] === c && d.push(e)\n\t        }\n\t        var d = [];\n\t        a && [\"style:parent-style-name\", \"style:next-style-name\"].forEach(b);\n\t        return d\n\t    }\n\t    function b(a, c) {\n\t        function b(d) {\n\t            a[d] === c && delete a[d]\n\t        }\n\t        a && [\"style:parent-style-name\", \"style:next-style-name\"].forEach(b)\n\t    }\n\t    function f(a) {\n\t        var c = {};\n\t        Object.keys(a).forEach(function(b) {\n\t            c[b] = \"object\" === typeof a[b] ? f(a[b]) : a[b]\n\t        });\n\t        return c\n\t    }\n\t    function n(a, c, b, d) {\n\t        var e, f = !1, g = !1, k, l = [];\n\t        d && d.attributes && (l = d.attributes.split(\",\"));\n\t        a && (b || 0 < l.length) && Object.keys(a).forEach(function(c) {\n\t            var d = a[c], e;\n\t            \"object\" !== typeof d && (b && (e = b[c]),\n\t            void 0 !== e ? (delete a[c],\n\t            g = !0,\n\t            e === d && (delete b[c],\n\t            f = !0)) : -1 !== l.indexOf(c) && (delete a[c],\n\t            g = !0))\n\t        });\n\t        if (c && c.attributes && (b || 0 < l.length)) {\n\t            k = c.attributes.split(\",\");\n\t            for (d = 0; d < k.length; d += 1)\n\t                if (e = k[d],\n\t                b && void 0 !== b[e] || l && -1 !== l.indexOf(e))\n\t                    k.splice(d, 1),\n\t                    --d,\n\t                    g = !0;\n\t            0 < k.length ? c.attributes = k.join(\",\") : delete c.attributes\n\t        }\n\t        return {\n\t            majorChanged: f,\n\t            minorChanged: g\n\t        }\n\t    }\n\t    function p(a) {\n\t        for (var c in a)\n\t            if (a.hasOwnProperty(c))\n\t                return !0;\n\t        return !1\n\t    }\n\t    function r(a) {\n\t        for (var c in a)\n\t            if (a.hasOwnProperty(c) && (\"attributes\" !== c || 0 < a.attributes.length))\n\t                return !0;\n\t        return !1\n\t    }\n\t    function q(a, c, b, d, e) {\n\t        var f = a ? a[e] : null, g = c ? c[e] : null, k = b ? b[e] : null, l = d ? d[e] : null, q;\n\t        q = n(f, g, k, l);\n\t        f && !p(f) && delete a[e];\n\t        g && !r(g) && delete c[e];\n\t        k && !p(k) && delete b[e];\n\t        l && !r(l) && delete d[e];\n\t        return q\n\t    }\n\t    function e(a, c) {\n\t        return {\n\t            opSpecsA: [a],\n\t            opSpecsB: [c]\n\t        }\n\t    }\n\t    var l;\n\t    l = {\n\t        AddAnnotation: {\n\t            AddAnnotation: function(a, c, b) {\n\t                var d;\n\t                a.position < c.position ? (d = a,\n\t                b = c) : c.position < a.position ? (d = c,\n\t                b = a) : (d = b ? a : c,\n\t                b = b ? c : a);\n\t                b.position < d.position + d.length && (d.length += 2);\n\t                b.position += 2;\n\t                return {\n\t                    opSpecsA: [a],\n\t                    opSpecsB: [c]\n\t                }\n\t            },\n\t            AddCursor: e,\n\t            AddMember: e,\n\t            AddStyle: e,\n\t            ApplyDirectStyling: function(a, c) {\n\t                a.position <= c.position ? c.position += 2 : a.position <= c.position + c.length && (c.length += 2);\n\t                return {\n\t                    opSpecsA: [a],\n\t                    opSpecsB: [c]\n\t                }\n\t            },\n\t            InsertText: function(a, c) {\n\t                c.position <= a.position ? a.position += c.text.length : (void 0 !== a.length && c.position <= a.position + a.length && (a.length += c.text.length),\n\t                c.position += 2);\n\t                return {\n\t                    opSpecsA: [a],\n\t                    opSpecsB: [c]\n\t                }\n\t            },\n\t            MergeParagraph: function(a, c) {\n\t                c.sourceStartPosition <= a.position ? --a.position : (void 0 !== a.length && c.sourceStartPosition <= a.position + a.length && --a.length,\n\t                c.sourceStartPosition += 2,\n\t                a.position < c.destinationStartPosition && (c.destinationStartPosition += 2));\n\t                return {\n\t                    opSpecsA: [a],\n\t                    opSpecsB: [c]\n\t                }\n\t            },\n\t            MoveCursor: function(a, c) {\n\t                var b = k(c);\n\t                a.position < c.position ? c.position += 2 : a.position < c.position + c.length && (c.length += 2);\n\t                b && g(c);\n\t                return {\n\t                    opSpecsA: [a],\n\t                    opSpecsB: [c]\n\t                }\n\t            },\n\t            RemoveAnnotation: function(a, c) {\n\t                a.position < c.position ? (c.position < a.position + a.length && (a.length -= c.length + 2),\n\t                c.position += 2) : a.position -= c.length + 2;\n\t                return {\n\t                    opSpecsA: [a],\n\t                    opSpecsB: [c]\n\t                }\n\t            },\n\t            RemoveCursor: e,\n\t            RemoveMember: e,\n\t            RemoveStyle: e,\n\t            RemoveText: function(a, c) {\n\t                var b = c.position, d = c.position + c.length, e, f = [a], g = [c];\n\t                a.position <= c.position ? c.position += 2 : a.position < d && (c.length = a.position - c.position,\n\t                e = {\n\t                    optype: \"RemoveText\",\n\t                    memberid: c.memberid,\n\t                    timestamp: c.timestamp,\n\t                    position: a.position + 2,\n\t                    length: d - a.position\n\t                },\n\t                g.unshift(e));\n\t                c.position + c.length <= a.position ? (a.position -= c.length,\n\t                void 0 !== a.length && e && (a.length = e.length >= a.length ? 0 : a.length - e.length)) : void 0 !== a.length && (e = a.position + a.length,\n\t                d <= e ? a.length -= c.length : b < e && (a.length = b - a.position));\n\t                return {\n\t                    opSpecsA: f,\n\t                    opSpecsB: g\n\t                }\n\t            },\n\t            SetParagraphStyle: function(a, c) {\n\t                a.position < c.position && (c.position += 2);\n\t                return {\n\t                    opSpecsA: [a],\n\t                    opSpecsB: [c]\n\t                }\n\t            },\n\t            SplitParagraph: function(a, c) {\n\t                a.position < c.sourceParagraphPosition && (c.sourceParagraphPosition += 2);\n\t                c.position <= a.position ? a.position += 1 : (void 0 !== a.length && c.position <= a.position + a.length && (a.length += 1),\n\t                c.position += 2);\n\t                return {\n\t                    opSpecsA: [a],\n\t                    opSpecsB: [c]\n\t                }\n\t            },\n\t            UpdateMember: e,\n\t            UpdateMetadata: e,\n\t            UpdateParagraphStyle: e\n\t        },\n\t        AddCursor: {\n\t            AddCursor: e,\n\t            AddMember: e,\n\t            AddStyle: e,\n\t            ApplyDirectStyling: e,\n\t            InsertText: e,\n\t            MergeParagraph: e,\n\t            MoveCursor: e,\n\t            RemoveAnnotation: e,\n\t            RemoveCursor: e,\n\t            RemoveMember: e,\n\t            RemoveStyle: e,\n\t            RemoveText: e,\n\t            SetParagraphStyle: e,\n\t            SplitParagraph: e,\n\t            UpdateMember: e,\n\t            UpdateMetadata: e,\n\t            UpdateParagraphStyle: e\n\t        },\n\t        AddMember: {\n\t            AddStyle: e,\n\t            ApplyDirectStyling: e,\n\t            InsertText: e,\n\t            MergeParagraph: e,\n\t            MoveCursor: e,\n\t            RemoveAnnotation: e,\n\t            RemoveCursor: e,\n\t            RemoveStyle: e,\n\t            RemoveText: e,\n\t            SetParagraphStyle: e,\n\t            SplitParagraph: e,\n\t            UpdateMetadata: e,\n\t            UpdateParagraphStyle: e\n\t        },\n\t        AddStyle: {\n\t            AddStyle: e,\n\t            ApplyDirectStyling: e,\n\t            InsertText: e,\n\t            MergeParagraph: e,\n\t            MoveCursor: e,\n\t            RemoveAnnotation: e,\n\t            RemoveCursor: e,\n\t            RemoveMember: e,\n\t            RemoveStyle: function(a, c) {\n\t                var e, f = [a], g = [c];\n\t                a.styleFamily === c.styleFamily && (e = d(a.setProperties, c.styleName),\n\t                0 < e.length && (e = {\n\t                    optype: \"UpdateParagraphStyle\",\n\t                    memberid: c.memberid,\n\t                    timestamp: c.timestamp,\n\t                    styleName: a.styleName,\n\t                    removedProperties: {\n\t                        attributes: e.join(\",\")\n\t                    }\n\t                },\n\t                g.unshift(e)),\n\t                b(a.setProperties, c.styleName));\n\t                return {\n\t                    opSpecsA: f,\n\t                    opSpecsB: g\n\t                }\n\t            },\n\t            RemoveText: e,\n\t            SetParagraphStyle: e,\n\t            SplitParagraph: e,\n\t            UpdateMember: e,\n\t            UpdateMetadata: e,\n\t            UpdateParagraphStyle: e\n\t        },\n\t        ApplyDirectStyling: {\n\t            ApplyDirectStyling: function(a, c, b) {\n\t                var d, e, g, k, l, n, r, t;\n\t                k = [a];\n\t                g = [c];\n\t                if (!(a.position + a.length <= c.position || a.position >= c.position + c.length)) {\n\t                    d = b ? a : c;\n\t                    e = b ? c : a;\n\t                    if (a.position !== c.position || a.length !== c.length)\n\t                        n = f(d),\n\t                        r = f(e);\n\t                    c = q(e.setProperties, null, d.setProperties, null, \"style:text-properties\");\n\t                    if (c.majorChanged || c.minorChanged)\n\t                        g = [],\n\t                        a = [],\n\t                        k = d.position + d.length,\n\t                        l = e.position + e.length,\n\t                        e.position < d.position ? c.minorChanged && (t = f(r),\n\t                        t.length = d.position - e.position,\n\t                        a.push(t),\n\t                        e.position = d.position,\n\t                        e.length = l - e.position) : d.position < e.position && c.majorChanged && (t = f(n),\n\t                        t.length = e.position - d.position,\n\t                        g.push(t),\n\t                        d.position = e.position,\n\t                        d.length = k - d.position),\n\t                        l > k ? c.minorChanged && (n = r,\n\t                        n.position = k,\n\t                        n.length = l - k,\n\t                        a.push(n),\n\t                        e.length = k - e.position) : k > l && c.majorChanged && (n.position = l,\n\t                        n.length = k - l,\n\t                        g.push(n),\n\t                        d.length = l - d.position),\n\t                        d.setProperties && p(d.setProperties) && g.push(d),\n\t                        e.setProperties && p(e.setProperties) && a.push(e),\n\t                        b ? (k = g,\n\t                        g = a) : k = a\n\t                }\n\t                return {\n\t                    opSpecsA: k,\n\t                    opSpecsB: g\n\t                }\n\t            },\n\t            InsertText: function(a, c) {\n\t                c.position <= a.position ? a.position += c.text.length : c.position <= a.position + a.length && (a.length += c.text.length);\n\t                return {\n\t                    opSpecsA: [a],\n\t                    opSpecsB: [c]\n\t                }\n\t            },\n\t            MergeParagraph: function(a, c) {\n\t                var b = a.position\n\t                  , d = a.position + a.length;\n\t                b >= c.sourceStartPosition && --b;\n\t                d >= c.sourceStartPosition && --d;\n\t                a.position = b;\n\t                a.length = d - b;\n\t                return {\n\t                    opSpecsA: [a],\n\t                    opSpecsB: [c]\n\t                }\n\t            },\n\t            MoveCursor: e,\n\t            RemoveAnnotation: function(a, b) {\n\t                var d = a.position\n\t                  , e = a.position + a.length\n\t                  , f = b.position + b.length\n\t                  , g = [a]\n\t                  , k = [b];\n\t                b.position <= d && e <= f ? g = [] : (f < d && (d -= b.length + 2),\n\t                f < e && (e -= b.length + 2),\n\t                a.position = d,\n\t                a.length = e - d);\n\t                return {\n\t                    opSpecsA: g,\n\t                    opSpecsB: k\n\t                }\n\t            },\n\t            RemoveCursor: e,\n\t            RemoveMember: e,\n\t            RemoveStyle: e,\n\t            RemoveText: function(a, b) {\n\t                var d = a.position + a.length\n\t                  , e = b.position + b.length\n\t                  , f = [a]\n\t                  , g = [b];\n\t                e <= a.position ? a.position -= b.length : b.position < d && (a.position < b.position ? a.length = e < d ? a.length - b.length : b.position - a.position : (a.position = b.position,\n\t                e < d ? a.length = d - e : f = []));\n\t                return {\n\t                    opSpecsA: f,\n\t                    opSpecsB: g\n\t                }\n\t            },\n\t            SetParagraphStyle: e,\n\t            SplitParagraph: function(a, b) {\n\t                b.position < a.position ? a.position += 1 : b.position < a.position + a.length && (a.length += 1);\n\t                return {\n\t                    opSpecsA: [a],\n\t                    opSpecsB: [b]\n\t                }\n\t            },\n\t            UpdateMember: e,\n\t            UpdateMetadata: e,\n\t            UpdateParagraphStyle: e\n\t        },\n\t        InsertText: {\n\t            InsertText: function(a, b, d) {\n\t                a.position < b.position ? b.position += a.text.length : a.position > b.position ? a.position += b.text.length : d ? b.position += a.text.length : a.position += b.text.length;\n\t                return {\n\t                    opSpecsA: [a],\n\t                    opSpecsB: [b]\n\t                }\n\t            },\n\t            MergeParagraph: function(a, b) {\n\t                a.position >= b.sourceStartPosition ? --a.position : (a.position < b.sourceStartPosition && (b.sourceStartPosition += a.text.length),\n\t                a.position < b.destinationStartPosition && (b.destinationStartPosition += a.text.length));\n\t                return {\n\t                    opSpecsA: [a],\n\t                    opSpecsB: [b]\n\t                }\n\t            },\n\t            MoveCursor: function(a, b) {\n\t                var d = k(b);\n\t                a.position < b.position ? b.position += a.text.length : a.position < b.position + b.length && (b.length += a.text.length);\n\t                d && g(b);\n\t                return {\n\t                    opSpecsA: [a],\n\t                    opSpecsB: [b]\n\t                }\n\t            },\n\t            RemoveAnnotation: function(a, b) {\n\t                var d = a.position\n\t                  , e = b.position + b.length\n\t                  , f = [a]\n\t                  , g = [b];\n\t                b.position <= d && d <= e ? (f = [],\n\t                b.length += a.text.length) : e < a.position ? a.position -= b.length + 2 : b.position += a.text.length;\n\t                return {\n\t                    opSpecsA: f,\n\t                    opSpecsB: g\n\t                }\n\t            },\n\t            RemoveCursor: e,\n\t            RemoveMember: e,\n\t            RemoveStyle: e,\n\t            RemoveText: function(a, b) {\n\t                var d;\n\t                d = b.position + b.length;\n\t                var e = [a]\n\t                  , f = [b];\n\t                d <= a.position ? a.position -= b.length : a.position <= b.position ? b.position += a.text.length : (b.length = a.position - b.position,\n\t                d = {\n\t                    optype: \"RemoveText\",\n\t                    memberid: b.memberid,\n\t                    timestamp: b.timestamp,\n\t                    position: a.position + a.text.length,\n\t                    length: d - a.position\n\t                },\n\t                f.unshift(d),\n\t                a.position = b.position);\n\t                return {\n\t                    opSpecsA: e,\n\t                    opSpecsB: f\n\t                }\n\t            },\n\t            SetParagraphStyle: function(a, b) {\n\t                b.position > a.position && (b.position += a.text.length);\n\t                return {\n\t                    opSpecsA: [a],\n\t                    opSpecsB: [b]\n\t                }\n\t            },\n\t            SplitParagraph: function(a, b) {\n\t                a.position < b.sourceParagraphPosition && (b.sourceParagraphPosition += a.text.length);\n\t                a.position <= b.position ? b.position += a.text.length : a.position += 1;\n\t                return {\n\t                    opSpecsA: [a],\n\t                    opSpecsB: [b]\n\t                }\n\t            },\n\t            UpdateMember: e,\n\t            UpdateMetadata: e,\n\t            UpdateParagraphStyle: e\n\t        },\n\t        MergeParagraph: {\n\t            MergeParagraph: function(a, b, d) {\n\t                var e = [a], f = [b], g;\n\t                a.destinationStartPosition === b.destinationStartPosition ? (e = [],\n\t                f = [],\n\t                a.moveCursor && (g = {\n\t                    optype: \"MoveCursor\",\n\t                    memberid: a.memberid,\n\t                    timestamp: a.timestamp,\n\t                    position: a.sourceStartPosition - 1\n\t                },\n\t                e.push(g)),\n\t                b.moveCursor && (g = {\n\t                    optype: \"MoveCursor\",\n\t                    memberid: b.memberid,\n\t                    timestamp: b.timestamp,\n\t                    position: b.sourceStartPosition - 1\n\t                },\n\t                f.push(g)),\n\t                a = d ? a : b,\n\t                a = {\n\t                    optype: \"SetParagraphStyle\",\n\t                    memberid: a.memberid,\n\t                    timestamp: a.timestamp,\n\t                    position: a.destinationStartPosition,\n\t                    styleName: a.paragraphStyleName\n\t                },\n\t                d ? e.push(a) : f.push(a)) : b.sourceStartPosition === a.destinationStartPosition ? (a.destinationStartPosition = b.destinationStartPosition,\n\t                --a.sourceStartPosition,\n\t                a.paragraphStyleName = b.paragraphStyleName) : a.sourceStartPosition === b.destinationStartPosition ? (b.destinationStartPosition = a.destinationStartPosition,\n\t                --b.sourceStartPosition,\n\t                b.paragraphStyleName = a.paragraphStyleName) : a.destinationStartPosition < b.destinationStartPosition ? (--b.destinationStartPosition,\n\t                --b.sourceStartPosition) : (--a.destinationStartPosition,\n\t                --a.sourceStartPosition);\n\t                return {\n\t                    opSpecsA: e,\n\t                    opSpecsB: f\n\t                }\n\t            },\n\t            MoveCursor: function(a, b) {\n\t                var d = b.position\n\t                  , e = b.position + b.length\n\t                  , f = Math.min(d, e)\n\t                  , d = Math.max(d, e);\n\t                f >= a.sourceStartPosition && --f;\n\t                d >= a.sourceStartPosition && --d;\n\t                0 <= b.length ? (b.position = f,\n\t                b.length = d - f) : (b.position = d,\n\t                b.length = f - d);\n\t                return {\n\t                    opSpecsA: [a],\n\t                    opSpecsB: [b]\n\t                }\n\t            },\n\t            RemoveAnnotation: function(a, b) {\n\t                var d = b.position + b.length\n\t                  , e = [a]\n\t                  , f = [b];\n\t                b.position <= a.destinationStartPosition && a.sourceStartPosition <= d ? (e = [],\n\t                --b.length) : a.sourceStartPosition < b.position ? --b.position : (d < a.destinationStartPosition && (a.destinationStartPosition -= b.length + 2),\n\t                d < a.sourceStartPosition && (a.sourceStartPosition -= b.length + 2));\n\t                return {\n\t                    opSpecsA: e,\n\t                    opSpecsB: f\n\t                }\n\t            },\n\t            RemoveCursor: e,\n\t            RemoveMember: e,\n\t            RemoveStyle: e,\n\t            RemoveText: function(a, b) {\n\t                b.position >= a.sourceStartPosition ? --b.position : (b.position < a.destinationStartPosition && (a.destinationStartPosition -= b.length),\n\t                b.position < a.sourceStartPosition && (a.sourceStartPosition -= b.length));\n\t                return {\n\t                    opSpecsA: [a],\n\t                    opSpecsB: [b]\n\t                }\n\t            },\n\t            SetParagraphStyle: function(a, b) {\n\t                var d = [a]\n\t                  , e = [b];\n\t                if (b.position > a.sourceStartPosition)\n\t                    --b.position;\n\t                else if (b.position === a.destinationStartPosition || b.position === a.sourceStartPosition)\n\t                    b.position = a.destinationStartPosition,\n\t                    a.paragraphStyleName = b.styleName;\n\t                return {\n\t                    opSpecsA: d,\n\t                    opSpecsB: e\n\t                }\n\t            },\n\t            SplitParagraph: function(a, b) {\n\t                var d, e = [a], f = [b];\n\t                b.position < a.destinationStartPosition ? (a.destinationStartPosition += 1,\n\t                a.sourceStartPosition += 1) : b.position >= a.destinationStartPosition && b.position < a.sourceStartPosition ? (b.paragraphStyleName = a.paragraphStyleName,\n\t                d = {\n\t                    optype: \"SetParagraphStyle\",\n\t                    memberid: a.memberid,\n\t                    timestamp: a.timestamp,\n\t                    position: a.destinationStartPosition,\n\t                    styleName: a.paragraphStyleName\n\t                },\n\t                e.push(d),\n\t                b.position === a.sourceStartPosition - 1 && a.moveCursor && (d = {\n\t                    optype: \"MoveCursor\",\n\t                    memberid: a.memberid,\n\t                    timestamp: a.timestamp,\n\t                    position: b.position,\n\t                    length: 0\n\t                },\n\t                e.push(d)),\n\t                a.destinationStartPosition = b.position + 1,\n\t                a.sourceStartPosition += 1) : b.position >= a.sourceStartPosition && (--b.position,\n\t                --b.sourceParagraphPosition);\n\t                return {\n\t                    opSpecsA: e,\n\t                    opSpecsB: f\n\t                }\n\t            },\n\t            UpdateMember: e,\n\t            UpdateMetadata: e,\n\t            UpdateParagraphStyle: e\n\t        },\n\t        MoveCursor: {\n\t            MoveCursor: e,\n\t            RemoveAnnotation: function(a, b) {\n\t                var d = k(a)\n\t                  , e = a.position + a.length\n\t                  , f = b.position + b.length;\n\t                b.position <= a.position && e <= f ? (a.position = b.position - 1,\n\t                a.length = 0) : (f < a.position ? a.position -= b.length + 2 : f < e && (a.length -= b.length + 2),\n\t                d && g(a));\n\t                return {\n\t                    opSpecsA: [a],\n\t                    opSpecsB: [b]\n\t                }\n\t            },\n\t            RemoveCursor: function(a, b) {\n\t                return {\n\t                    opSpecsA: a.memberid === b.memberid ? [] : [a],\n\t                    opSpecsB: [b]\n\t                }\n\t            },\n\t            RemoveMember: e,\n\t            RemoveStyle: e,\n\t            RemoveText: function(a, b) {\n\t                var d = k(a)\n\t                  , e = a.position + a.length\n\t                  , f = b.position + b.length;\n\t                f <= a.position ? a.position -= b.length : b.position < e && (a.position < b.position ? a.length = f < e ? a.length - b.length : b.position - a.position : (a.position = b.position,\n\t                a.length = f < e ? e - f : 0));\n\t                d && g(a);\n\t                return {\n\t                    opSpecsA: [a],\n\t                    opSpecsB: [b]\n\t                }\n\t            },\n\t            SetParagraphStyle: e,\n\t            SplitParagraph: function(a, b) {\n\t                var d = k(a);\n\t                b.position < a.position ? a.position += 1 : b.position < a.position + a.length && (a.length += 1);\n\t                d && g(a);\n\t                return {\n\t                    opSpecsA: [a],\n\t                    opSpecsB: [b]\n\t                }\n\t            },\n\t            UpdateMember: e,\n\t            UpdateMetadata: e,\n\t            UpdateParagraphStyle: e\n\t        },\n\t        RemoveAnnotation: {\n\t            RemoveAnnotation: function(a, b) {\n\t                var d = [a]\n\t                  , e = [b];\n\t                a.position === b.position && a.length === b.length ? (d = [],\n\t                e = []) : a.position < b.position ? b.position -= a.length + 2 : a.position -= b.length + 2;\n\t                return {\n\t                    opSpecsA: d,\n\t                    opSpecsB: e\n\t                }\n\t            },\n\t            RemoveCursor: e,\n\t            RemoveMember: e,\n\t            RemoveStyle: e,\n\t            RemoveText: function(a, b) {\n\t                var d = a.position + a.length\n\t                  , e = b.position + b.length\n\t                  , f = [a]\n\t                  , g = [b];\n\t                a.position <= b.position && e <= d ? (g = [],\n\t                a.length -= b.length) : e < a.position ? a.position -= b.length : b.position < a.position ? (a.position = b.position + 1,\n\t                b.length -= a.length + 2) : b.position -= a.length + 2;\n\t                return {\n\t                    opSpecsA: f,\n\t                    opSpecsB: g\n\t                }\n\t            },\n\t            SetParagraphStyle: function(a, b) {\n\t                var d = b.position\n\t                  , e = a.position + a.length\n\t                  , f = [a]\n\t                  , g = [b];\n\t                a.position <= d && d <= e ? g = [] : e < d && (b.position -= a.length + 2);\n\t                return {\n\t                    opSpecsA: f,\n\t                    opSpecsB: g\n\t                }\n\t            },\n\t            SplitParagraph: function(a, b) {\n\t                var d = b.position\n\t                  , e = a.position + a.length\n\t                  , f = [a]\n\t                  , g = [b];\n\t                a.position <= d && d <= e ? (g = [],\n\t                a.length += 1) : (e < b.sourceParagraphPosition && (b.sourceParagraphPosition -= a.length + 2),\n\t                e < d ? b.position -= a.length + 2 : a.position += 1);\n\t                return {\n\t                    opSpecsA: f,\n\t                    opSpecsB: g\n\t                }\n\t            },\n\t            UpdateMember: e,\n\t            UpdateMetadata: e,\n\t            UpdateParagraphStyle: e\n\t        },\n\t        RemoveCursor: {\n\t            RemoveCursor: function(a, b) {\n\t                var d = a.memberid === b.memberid;\n\t                return {\n\t                    opSpecsA: d ? [] : [a],\n\t                    opSpecsB: d ? [] : [b]\n\t                }\n\t            },\n\t            RemoveMember: e,\n\t            RemoveStyle: e,\n\t            RemoveText: e,\n\t            SetParagraphStyle: e,\n\t            SplitParagraph: e,\n\t            UpdateMember: e,\n\t            UpdateMetadata: e,\n\t            UpdateParagraphStyle: e\n\t        },\n\t        RemoveMember: {\n\t            RemoveStyle: e,\n\t            RemoveText: e,\n\t            SetParagraphStyle: e,\n\t            SplitParagraph: e,\n\t            UpdateMetadata: e,\n\t            UpdateParagraphStyle: e\n\t        },\n\t        RemoveStyle: {\n\t            RemoveStyle: function(a, b) {\n\t                var d = a.styleName === b.styleName && a.styleFamily === b.styleFamily;\n\t                return {\n\t                    opSpecsA: d ? [] : [a],\n\t                    opSpecsB: d ? [] : [b]\n\t                }\n\t            },\n\t            RemoveText: e,\n\t            SetParagraphStyle: function(a, b) {\n\t                var d, e = [a], f = [b];\n\t                \"paragraph\" === a.styleFamily && a.styleName === b.styleName && (d = {\n\t                    optype: \"SetParagraphStyle\",\n\t                    memberid: a.memberid,\n\t                    timestamp: a.timestamp,\n\t                    position: b.position,\n\t                    styleName: \"\"\n\t                },\n\t                e.unshift(d),\n\t                b.styleName = \"\");\n\t                return {\n\t                    opSpecsA: e,\n\t                    opSpecsB: f\n\t                }\n\t            },\n\t            SplitParagraph: e,\n\t            UpdateMember: e,\n\t            UpdateMetadata: e,\n\t            UpdateParagraphStyle: function(a, c) {\n\t                var e, f = [a], g = [c];\n\t                \"paragraph\" === a.styleFamily && (e = d(c.setProperties, a.styleName),\n\t                0 < e.length && (e = {\n\t                    optype: \"UpdateParagraphStyle\",\n\t                    memberid: a.memberid,\n\t                    timestamp: a.timestamp,\n\t                    styleName: c.styleName,\n\t                    removedProperties: {\n\t                        attributes: e.join(\",\")\n\t                    }\n\t                },\n\t                f.unshift(e)),\n\t                a.styleName === c.styleName ? g = [] : b(c.setProperties, a.styleName));\n\t                return {\n\t                    opSpecsA: f,\n\t                    opSpecsB: g\n\t                }\n\t            }\n\t        },\n\t        RemoveText: {\n\t            RemoveText: function(a, b) {\n\t                var d = a.position + a.length\n\t                  , e = b.position + b.length\n\t                  , f = [a]\n\t                  , g = [b];\n\t                e <= a.position ? a.position -= b.length : d <= b.position ? b.position -= a.length : b.position < d && (a.position < b.position ? (a.length = e < d ? a.length - b.length : b.position - a.position,\n\t                d < e ? (b.position = a.position,\n\t                b.length = e - d) : g = []) : (d < e ? b.length -= a.length : b.position < a.position ? b.length = a.position - b.position : g = [],\n\t                e < d ? (a.position = b.position,\n\t                a.length = d - e) : f = []));\n\t                return {\n\t                    opSpecsA: f,\n\t                    opSpecsB: g\n\t                }\n\t            },\n\t            SetParagraphStyle: function(a, b) {\n\t                a.position < b.position && (b.position -= a.length);\n\t                return {\n\t                    opSpecsA: [a],\n\t                    opSpecsB: [b]\n\t                }\n\t            },\n\t            SplitParagraph: function(a, b) {\n\t                var d = a.position + a.length\n\t                  , e = [a]\n\t                  , f = [b];\n\t                b.position <= a.position ? a.position += 1 : b.position < d && (a.length = b.position - a.position,\n\t                d = {\n\t                    optype: \"RemoveText\",\n\t                    memberid: a.memberid,\n\t                    timestamp: a.timestamp,\n\t                    position: b.position + 1,\n\t                    length: d - b.position\n\t                },\n\t                e.unshift(d));\n\t                a.position + a.length <= b.position ? b.position -= a.length : a.position < b.position && (b.position = a.position);\n\t                a.position + a.length < b.sourceParagraphPosition && (b.sourceParagraphPosition -= a.length);\n\t                return {\n\t                    opSpecsA: e,\n\t                    opSpecsB: f\n\t                }\n\t            },\n\t            UpdateMember: e,\n\t            UpdateMetadata: e,\n\t            UpdateParagraphStyle: e\n\t        },\n\t        SetParagraphStyle: {\n\t            SetParagraphStyle: function(a, b, d) {\n\t                a.position === b.position && (d ? b.styleName = a.styleName : a.styleName = b.styleName);\n\t                return {\n\t                    opSpecsA: [a],\n\t                    opSpecsB: [b]\n\t                }\n\t            },\n\t            SplitParagraph: function(a, b) {\n\t                var d = [a], e = [b], g;\n\t                a.position > b.position ? a.position += 1 : a.position === b.sourceParagraphPosition && (b.paragraphStyleName = a.styleName,\n\t                g = f(a),\n\t                g.position = b.position + 1,\n\t                d.push(g));\n\t                return {\n\t                    opSpecsA: d,\n\t                    opSpecsB: e\n\t                }\n\t            },\n\t            UpdateMember: e,\n\t            UpdateMetadata: e,\n\t            UpdateParagraphStyle: e\n\t        },\n\t        SplitParagraph: {\n\t            SplitParagraph: function(a, b, d) {\n\t                var e, f;\n\t                a.position < b.position ? e = !0 : b.position < a.position ? f = !0 : a.position === b.position && (d ? e = !0 : f = !0);\n\t                e ? (b.position += 1,\n\t                b.sourceParagraphPosition = a.position < b.sourceParagraphPosition ? b.sourceParagraphPosition + 1 : a.position + 1) : f && (a.position += 1,\n\t                a.sourceParagraphPosition = b.position < b.sourceParagraphPosition ? a.sourceParagraphPosition + 1 : b.position + 1);\n\t                return {\n\t                    opSpecsA: [a],\n\t                    opSpecsB: [b]\n\t                }\n\t            },\n\t            UpdateMember: e,\n\t            UpdateMetadata: e,\n\t            UpdateParagraphStyle: e\n\t        },\n\t        UpdateMember: {\n\t            UpdateMetadata: e,\n\t            UpdateParagraphStyle: e\n\t        },\n\t        UpdateMetadata: {\n\t            UpdateMetadata: function(a, b, d) {\n\t                var e, f = [a], g = [b];\n\t                e = d ? a : b;\n\t                a = d ? b : a;\n\t                n(a.setProperties || null, a.removedProperties || null, e.setProperties || null, e.removedProperties || null);\n\t                e.setProperties && p(e.setProperties) || e.removedProperties && r(e.removedProperties) || (d ? f = [] : g = []);\n\t                a.setProperties && p(a.setProperties) || a.removedProperties && r(a.removedProperties) || (d ? g = [] : f = []);\n\t                return {\n\t                    opSpecsA: f,\n\t                    opSpecsB: g\n\t                }\n\t            },\n\t            UpdateParagraphStyle: e\n\t        },\n\t        UpdateParagraphStyle: {\n\t            UpdateParagraphStyle: function(a, b, d) {\n\t                var e, f = [a], g = [b];\n\t                a.styleName === b.styleName && (e = d ? a : b,\n\t                a = d ? b : a,\n\t                q(a.setProperties, a.removedProperties, e.setProperties, e.removedProperties, \"style:paragraph-properties\"),\n\t                q(a.setProperties, a.removedProperties, e.setProperties, e.removedProperties, \"style:text-properties\"),\n\t                n(a.setProperties || null, a.removedProperties || null, e.setProperties || null, e.removedProperties || null),\n\t                e.setProperties && p(e.setProperties) || e.removedProperties && r(e.removedProperties) || (d ? f = [] : g = []),\n\t                a.setProperties && p(a.setProperties) || a.removedProperties && r(a.removedProperties) || (d ? g = [] : f = []));\n\t                return {\n\t                    opSpecsA: f,\n\t                    opSpecsB: g\n\t                }\n\t            }\n\t        }\n\t    };\n\t    this.passUnchanged = e;\n\t    this.extendTransformations = function(a) {\n\t        Object.keys(a).forEach(function(b) {\n\t            var d = a[b], e, f = l.hasOwnProperty(b);\n\t            runtime.log((f ? \"Extending\" : \"Adding\") + \" map for optypeA: \" + b);\n\t            f || (l[b] = {});\n\t            e = l[b];\n\t            Object.keys(d).forEach(function(a) {\n\t                var f = e.hasOwnProperty(a);\n\t                runtime.assert(b <= a, \"Wrong order:\" + b + \", \" + a);\n\t                runtime.log(\"  \" + (f ? \"Overwriting\" : \"Adding\") + \" entry for optypeB: \" + a);\n\t                e[a] = d[a]\n\t            })\n\t        })\n\t    }\n\t    ;\n\t    this.transformOpspecVsOpspec = function(a, b) {\n\t        var d = a.optype <= b.optype, e;\n\t        runtime.log(\"Crosstransforming:\");\n\t        runtime.log(runtime.toJson(a));\n\t        runtime.log(runtime.toJson(b));\n\t        d || (e = a,\n\t        a = b,\n\t        b = e);\n\t        (e = (e = l[a.optype]) && e[b.optype]) ? (e = e(a, b, !d),\n\t        d || null === e || (e = {\n\t            opSpecsA: e.opSpecsB,\n\t            opSpecsB: e.opSpecsA\n\t        })) : e = null;\n\t        runtime.log(\"result:\");\n\t        e ? (runtime.log(runtime.toJson(e.opSpecsA)),\n\t        runtime.log(runtime.toJson(e.opSpecsB))) : runtime.log(\"null\");\n\t        return e\n\t    }\n\t}\n\t;\n\tops.OperationTransformer = function() {\n\t    function g(d, b) {\n\t        for (var f, n, p = [], r = []; 0 < d.length && b; ) {\n\t            f = d.shift();\n\t            f = k.transformOpspecVsOpspec(f, b);\n\t            if (!f)\n\t                return null;\n\t            p = p.concat(f.opSpecsA);\n\t            if (0 === f.opSpecsB.length) {\n\t                p = p.concat(d);\n\t                b = null;\n\t                break\n\t            }\n\t            for (; 1 < f.opSpecsB.length; ) {\n\t                n = g(d, f.opSpecsB.shift());\n\t                if (!n)\n\t                    return null;\n\t                r = r.concat(n.opSpecsB);\n\t                d = n.opSpecsA\n\t            }\n\t            b = f.opSpecsB.pop()\n\t        }\n\t        b && r.push(b);\n\t        return {\n\t            opSpecsA: p,\n\t            opSpecsB: r\n\t        }\n\t    }\n\t    var k = new ops.OperationTransformMatrix;\n\t    this.getOperationTransformMatrix = function() {\n\t        return k\n\t    }\n\t    ;\n\t    this.transform = function(d, b) {\n\t        for (var f, k = []; 0 < b.length; ) {\n\t            f = g(d, b.shift());\n\t            if (!f)\n\t                return null;\n\t            d = f.opSpecsA;\n\t            k = k.concat(f.opSpecsB)\n\t        }\n\t        return {\n\t            opSpecsA: d,\n\t            opSpecsB: k\n\t        }\n\t    }\n\t}\n\t;\n\tvar webodf_css = '@namespace draw url(urn:oasis:names:tc:opendocument:xmlns:drawing:1.0);@namespace fo url(urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0);@namespace office url(urn:oasis:names:tc:opendocument:xmlns:office:1.0);@namespace presentation url(urn:oasis:names:tc:opendocument:xmlns:presentation:1.0);@namespace style url(urn:oasis:names:tc:opendocument:xmlns:style:1.0);@namespace svg url(urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0);@namespace table url(urn:oasis:names:tc:opendocument:xmlns:table:1.0);@namespace text url(urn:oasis:names:tc:opendocument:xmlns:text:1.0);@namespace webodfhelper url(urn:webodf:names:helper);@namespace cursor url(urn:webodf:names:cursor);@namespace editinfo url(urn:webodf:names:editinfo);@namespace annotation url(urn:webodf:names:annotation);@namespace dc url(http://purl.org/dc/elements/1.1/);@namespace svgns url(http://www.w3.org/2000/svg);office|document > *, office|document-content > * {display: none;}office|body, office|document {display: inline-block;position: relative;}text|p, text|h {display: block;padding: 0;margin: 0;line-height: normal;position: relative;}text|p::after, text|h::after {content: \"\\\\200B\";white-space: pre;}*[webodfhelper|containsparagraphanchor] {position: relative;}text|s {white-space: pre;}text|tab {display: inline;white-space: pre;}text|tracked-changes {display: none;}office|binary-data {display: none;}office|text {display: block;text-align: left;overflow: visible;word-wrap: break-word;}office|text::selection {background: transparent;}.webodf-virtualSelections *::selection {background: transparent;}.webodf-virtualSelections *::-moz-selection {background: transparent;}office|text * draw|text-box {display: block;border: 1px solid #d3d3d3;}office|text draw|frame {z-index: 1;}office|spreadsheet {display: block;border-collapse: collapse;empty-cells: show;font-family: sans-serif;font-size: 10pt;text-align: left;page-break-inside: avoid;overflow: hidden;}office|presentation {display: inline-block;text-align: left;}#shadowContent {display: inline-block;text-align: left;}draw|page {display: block;position: relative;overflow: hidden;}presentation|notes, presentation|footer-decl, presentation|date-time-decl {display: none;}@media print {draw|page {border: 1pt solid black;page-break-inside: avoid;}presentation|notes {}}office|spreadsheet text|p {border: 0px;padding: 1px;margin: 0px;}office|spreadsheet table|table {margin: 3px;}office|spreadsheet table|table:after {}office|spreadsheet table|table-row {counter-increment: row;}office|spreadsheet table|table-row:before {width: 3em;background: #cccccc;border: 1px solid black;text-align: center;content: counter(row);display: table-cell;}office|spreadsheet table|table-cell {border: 1px solid #cccccc;}table|table {display: table;}draw|frame table|table {width: 100%;height: 100%;background: white;}table|table-header-rows {display: table-header-group;}table|table-row {display: table-row;}table|table-column {display: table-column;}table|table-cell {width: 0.889in;display: table-cell;word-break: break-all;}draw|frame {display: block;}draw|image {display: block;width: 100%;height: 100%;top: 0px;left: 0px;background-repeat: no-repeat;background-size: 100% 100%;-moz-background-size: 100% 100%;}draw|frame > draw|image:nth-of-type(n+2) {display: none;}text|list:before {display: none;content:\"\";}text|list {display: block;}text|list-item {display: block;}text|number {display:none;}text|a {color: blue;text-decoration: underline;cursor: pointer;}.webodf-inactiveLinks text|a {cursor: text;}text|note-citation {vertical-align: super;font-size: smaller;}text|note-body {display: none;}text|note:hover text|note-citation {background: #dddddd;}text|note:hover text|note-body {display: block;left:1em;max-width: 80%;position: absolute;background: #ffffaa;}text|bibliography-source {display: none;}svg|title, svg|desc {display: none;}video {width: 100%;height: 100%}cursor|anchor {display: none;}cursor|cursor {display: none;}.webodf-caretOverlay {position: absolute;top: 5%;height: 1em;z-index: 10;padding-left: 1px;pointer-events: none;}.webodf-caretOverlay .caret {position: absolute;border-left: 2px solid black;top: 0;bottom: 0;right: 0;}.webodf-caretOverlay .handle {position: absolute;margin-top: 5px;padding-top: 3px;margin-left: auto;margin-right: auto;width: 64px;height: 68px;border-radius: 5px;opacity: 0.3;text-align: center;background-color: black;box-shadow: 0px 0px 5px rgb(90, 90, 90);border: 1px solid black;top: -85px;right: -32px;}.webodf-caretOverlay .handle > img {box-shadow: 0px 0px 5px rgb(90, 90, 90) inset;background-color: rgb(200, 200, 200);border-radius: 5px;border: 2px solid;height: 60px;width: 60px;display: block;margin: auto;}.webodf-caretOverlay .handle.active {opacity: 0.8;}.webodf-caretOverlay .handle:after {content: \" \";position: absolute;width: 0px;height: 0px;border-style: solid;border-width: 8.7px 5px 0 5px;border-color: black transparent transparent transparent;top: 100%;left: 43%;}.webodf-caretSizer {display: inline-block;width: 0;visibility: hidden;}#eventTrap {display: block;position: absolute;bottom: 0;left: 0;outline: none;opacity: 0;color: rgba(255, 255, 255, 0);pointer-events: none;white-space: pre;overflow: hidden;}cursor|cursor > #composer {text-decoration: underline;}cursor|cursor[cursor|caret-sizer-active=\"true\"],cursor|cursor[cursor|composing=\"true\"] {display: inline;}editinfo|editinfo {display: inline-block;}.editInfoMarker {position: absolute;width: 10px;height: 100%;left: -20px;opacity: 0.8;top: 0;border-radius: 5px;background-color: transparent;box-shadow: 0px 0px 5px rgba(50, 50, 50, 0.75);}.editInfoMarker:hover {box-shadow: 0px 0px 8px rgba(0, 0, 0, 1);}.editInfoHandle {position: absolute;background-color: black;padding: 5px;border-radius: 5px;opacity: 0.8;box-shadow: 0px 0px 5px rgba(50, 50, 50, 0.75);bottom: 100%;margin-bottom: 10px;z-index: 3;left: -25px;}.editInfoHandle:after {content: \" \";position: absolute;width: 0px;height: 0px;border-style: solid;border-width: 8.7px 5px 0 5px;border-color: black transparent transparent transparent;top: 100%;left: 5px;}.editInfo {font-family: sans-serif;font-weight: normal;font-style: normal;text-decoration: none;color: white;width: 100%;height: 12pt;}.editInfoColor {float: left;width: 10pt;height: 10pt;border: 1px solid white;}.editInfoAuthor {float: left;margin-left: 5pt;font-size: 10pt;text-align: left;height: 12pt;line-height: 12pt;}.editInfoTime {float: right;margin-left: 30pt;font-size: 8pt;font-style: italic;color: yellow;height: 12pt;line-height: 12pt;}.annotationWrapper {display: inline;position: relative;}.annotationRemoveButton:before {content: \"\\u00d7\";color: white;padding: 5px;line-height: 1em;}.annotationRemoveButton {width: 20px;height: 20px;border-radius: 10px;background-color: black;box-shadow: 0px 0px 5px rgba(50, 50, 50, 0.75);position: absolute;top: -10px;left: -10px;z-index: 3;text-align: center;font-family: sans-serif;font-style: normal;font-weight: normal;text-decoration: none;font-size: 15px;}.annotationRemoveButton:hover {cursor: pointer;box-shadow: 0px 0px 5px rgba(0, 0, 0, 1);}.annotationNote {width: 4cm;position: absolute;display: inline;z-index: 10;top: 0;}.annotationNote > office|annotation {display: block;text-align: left;}.annotationConnector {position: absolute;display: inline;top: 0;z-index: 2;border-top: 1px dashed brown;}.annotationConnector.angular {-moz-transform-origin: left top;-webkit-transform-origin: left top;-ms-transform-origin: left top;transform-origin: left top;}.annotationConnector.horizontal {left: 0;}.annotationConnector.horizontal:before {content: \"\";display: inline;position: absolute;width: 0px;height: 0px;border-style: solid;border-width: 8.7px 5px 0 5px;border-color: brown transparent transparent transparent;top: -1px;left: -5px;}office|annotation {width: 100%;height: 100%;display: none;background: rgb(198, 238, 184);background: -moz-linear-gradient(90deg, rgb(198, 238, 184) 30%, rgb(180, 196, 159) 100%);background: -webkit-linear-gradient(90deg, rgb(198, 238, 184) 30%, rgb(180, 196, 159) 100%);background: -o-linear-gradient(90deg, rgb(198, 238, 184) 30%, rgb(180, 196, 159) 100%);background: -ms-linear-gradient(90deg, rgb(198, 238, 184) 30%, rgb(180, 196, 159) 100%);background: linear-gradient(180deg, rgb(198, 238, 184) 30%, rgb(180, 196, 159) 100%);box-shadow: 0 3px 4px -3px #ccc;}office|annotation > dc|creator {display: block;font-size: 10pt;font-weight: normal;font-style: normal;font-family: sans-serif;color: white;background-color: brown;padding: 4px;}office|annotation > dc|date {display: block;font-size: 10pt;font-weight: normal;font-style: normal;font-family: sans-serif;border: 4px solid transparent;color: black;}office|annotation > text|list {display: block;padding: 5px;}office|annotation text|p {font-size: 10pt;color: black;font-weight: normal;font-style: normal;text-decoration: none;font-family: sans-serif;}#annotationsPane {background-color: #EAEAEA;width: 4cm;height: 100%;display: none;position: absolute;outline: 1px solid #ccc;}.webodf-annotationHighlight {background-color: yellow;position: relative;}.webodf-selectionOverlay {position: absolute;pointer-events: none;top: 0;left: 0;top: 0;left: 0;width: 100%;height: 100%;z-index: 15;}.webodf-selectionOverlay > polygon {fill-opacity: 0.3;stroke-opacity: 0.8;stroke-width: 1;fill-rule: evenodd;}.webodf-selectionOverlay > .webodf-draggable {fill-opacity: 0.8;stroke-opacity: 0;stroke-width: 8;pointer-events: all;display: none;-moz-transform-origin: center center;-webkit-transform-origin: center center;-ms-transform-origin: center center;transform-origin: center center;}#imageSelector {display: none;position: absolute;border-style: solid;border-color: black;}#imageSelector > div {width: 5px;height: 5px;display: block;position: absolute;border: 1px solid black;background-color: #ffffff;}#imageSelector > .topLeft {top: -4px;left: -4px;}#imageSelector > .topRight {top: -4px;right: -4px;}#imageSelector > .bottomRight {right: -4px;bottom: -4px;}#imageSelector > .bottomLeft {bottom: -4px;left: -4px;}#imageSelector > .topMiddle {top: -4px;left: 50%;margin-left: -2.5px;}#imageSelector > .rightMiddle {top: 50%;right: -4px;margin-top: -2.5px;}#imageSelector > .bottomMiddle {bottom: -4px;left: 50%;margin-left: -2.5px;}#imageSelector > .leftMiddle {top: 50%;left: -4px;margin-top: -2.5px;}div.webodf-customScrollbars::-webkit-scrollbar{width: 8px;height: 8px;background-color: transparent;}div.webodf-customScrollbars::-webkit-scrollbar-track{background-color: transparent;}div.webodf-customScrollbars::-webkit-scrollbar-thumb{background-color: #444;border-radius: 4px;}.webodf-hyperlinkTooltip {display: none;color: white;background-color: black;border-radius: 5px;box-shadow: 2px 2px 5px gray;padding: 3px;position: absolute;max-width: 210px;text-align: left;word-break: break-all;z-index: 16;}.webodf-hyperlinkTooltipText {display: block;font-weight: bold;}';\n\t/*\n\n\t @licstart\n\tJSZip - A Javascript class for generating and reading zip files\n\t<http://stuartk.com/jszip>\n\n\t(c) 2009-2014 Stuart Knightley <stuart [at] stuartk.com>\n\tDual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.\n\n\tJSZip uses the library pako released under the MIT license :\n\thttps://github.com/nodeca/pako/blob/master/LICENSE\n\t @licend\n\t*/\n\t!function(e) {\n\t    var globalScope = typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {}\n\t      , externs = globalScope.externs || (globalScope.externs = {});\n\t    externs.JSZip = e()\n\t}(function() {\n\t    var define, module, exports;\n\t    return function e(t, n, r) {\n\t        function s(o, u) {\n\t            if (!n[o]) {\n\t                if (!t[o]) {\n\t                    var a = typeof require == \"function\" && require;\n\t                    if (!u && a)\n\t                        return a(o, !0);\n\t                    if (i)\n\t                        return i(o, !0);\n\t                    throw new Error(\"Cannot find module '\" + o + \"'\");\n\t                }\n\t                var f = n[o] = {\n\t                    exports: {}\n\t                };\n\t                t[o][0].call(f.exports, function(e) {\n\t                    var n = t[o][1][e];\n\t                    return s(n ? n : e)\n\t                }, f, f.exports, e, t, n, r)\n\t            }\n\t            return n[o].exports\n\t        }\n\t        var i = typeof require == \"function\" && require;\n\t        for (var o = 0; o < r.length; o++)\n\t            s(r[o]);\n\t        return s\n\t    }({\n\t        1: [function(_dereq_, module, exports) {\n\t            var _keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n\t            exports.encode = function(input, utf8) {\n\t                var output = \"\";\n\t                var chr1, chr2, chr3, enc1, enc2, enc3, enc4;\n\t                var i = 0;\n\t                while (i < input.length) {\n\t                    chr1 = input.charCodeAt(i++);\n\t                    chr2 = input.charCodeAt(i++);\n\t                    chr3 = input.charCodeAt(i++);\n\t                    enc1 = chr1 >> 2;\n\t                    enc2 = (chr1 & 3) << 4 | chr2 >> 4;\n\t                    enc3 = (chr2 & 15) << 2 | chr3 >> 6;\n\t                    enc4 = chr3 & 63;\n\t                    if (isNaN(chr2))\n\t                        enc3 = enc4 = 64;\n\t                    else if (isNaN(chr3))\n\t                        enc4 = 64;\n\t                    output = output + _keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4)\n\t                }\n\t                return output\n\t            }\n\t            ;\n\t            exports.decode = function(input, utf8) {\n\t                var output = \"\";\n\t                var chr1, chr2, chr3;\n\t                var enc1, enc2, enc3, enc4;\n\t                var i = 0;\n\t                input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n\t                while (i < input.length) {\n\t                    enc1 = _keyStr.indexOf(input.charAt(i++));\n\t                    enc2 = _keyStr.indexOf(input.charAt(i++));\n\t                    enc3 = _keyStr.indexOf(input.charAt(i++));\n\t                    enc4 = _keyStr.indexOf(input.charAt(i++));\n\t                    chr1 = enc1 << 2 | enc2 >> 4;\n\t                    chr2 = (enc2 & 15) << 4 | enc3 >> 2;\n\t                    chr3 = (enc3 & 3) << 6 | enc4;\n\t                    output = output + String.fromCharCode(chr1);\n\t                    if (enc3 != 64)\n\t                        output = output + String.fromCharCode(chr2);\n\t                    if (enc4 != 64)\n\t                        output = output + String.fromCharCode(chr3)\n\t                }\n\t                return output\n\t            }\n\t        }\n\t        , {}],\n\t        2: [function(_dereq_, module, exports) {\n\t            function CompressedObject() {\n\t                this.compressedSize = 0;\n\t                this.uncompressedSize = 0;\n\t                this.crc32 = 0;\n\t                this.compressionMethod = null;\n\t                this.compressedContent = null\n\t            }\n\t            CompressedObject.prototype = {\n\t                getContent: function() {\n\t                    return null\n\t                },\n\t                getCompressedContent: function() {\n\t                    return null\n\t                }\n\t            };\n\t            module.exports = CompressedObject\n\t        }\n\t        , {}],\n\t        3: [function(_dereq_, module, exports) {\n\t            exports.STORE = {\n\t                magic: \"\\x00\\x00\",\n\t                compress: function(content) {\n\t                    return content\n\t                },\n\t                uncompress: function(content) {\n\t                    return content\n\t                },\n\t                compressInputType: null,\n\t                uncompressInputType: null\n\t            };\n\t            exports.DEFLATE = _dereq_(\"./flate\")\n\t        }\n\t        , {\n\t            \"./flate\": 8\n\t        }],\n\t        4: [function(_dereq_, module, exports) {\n\t            var utils = _dereq_(\"./utils\");\n\t            var table = [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918E3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117];\n\t            module.exports = function crc32(input, crc) {\n\t                if (typeof input === \"undefined\" || !input.length)\n\t                    return 0;\n\t                var isArray = utils.getTypeOf(input) !== \"string\";\n\t                if (typeof crc == \"undefined\")\n\t                    crc = 0;\n\t                var x = 0;\n\t                var y = 0;\n\t                var b = 0;\n\t                crc = crc ^ -1;\n\t                for (var i = 0, iTop = input.length; i < iTop; i++) {\n\t                    b = isArray ? input[i] : input.charCodeAt(i);\n\t                    y = (crc ^ b) & 255;\n\t                    x = table[y];\n\t                    crc = crc >>> 8 ^ x\n\t                }\n\t                return crc ^ -1\n\t            }\n\t        }\n\t        , {\n\t            \"./utils\": 21\n\t        }],\n\t        5: [function(_dereq_, module, exports) {\n\t            var utils = _dereq_(\"./utils\");\n\t            function DataReader(data) {\n\t                this.data = null;\n\t                this.length = 0;\n\t                this.index = 0\n\t            }\n\t            DataReader.prototype = {\n\t                checkOffset: function(offset) {\n\t                    this.checkIndex(this.index + offset)\n\t                },\n\t                checkIndex: function(newIndex) {\n\t                    if (this.length < newIndex || newIndex < 0)\n\t                        throw new Error(\"End of data reached (data length = \" + this.length + \", asked index = \" + newIndex + \"). Corrupted zip ?\");\n\t                },\n\t                setIndex: function(newIndex) {\n\t                    this.checkIndex(newIndex);\n\t                    this.index = newIndex\n\t                },\n\t                skip: function(n) {\n\t                    this.setIndex(this.index + n)\n\t                },\n\t                byteAt: function(i) {},\n\t                readInt: function(size) {\n\t                    var result = 0, i;\n\t                    this.checkOffset(size);\n\t                    for (i = this.index + size - 1; i >= this.index; i--)\n\t                        result = (result << 8) + this.byteAt(i);\n\t                    this.index += size;\n\t                    return result\n\t                },\n\t                readString: function(size) {\n\t                    return utils.transformTo(\"string\", this.readData(size))\n\t                },\n\t                readData: function(size) {},\n\t                lastIndexOfSignature: function(sig) {},\n\t                readDate: function() {\n\t                    var dostime = this.readInt(4);\n\t                    return new Date((dostime >> 25 & 127) + 1980,(dostime >> 21 & 15) - 1,dostime >> 16 & 31,dostime >> 11 & 31,dostime >> 5 & 63,(dostime & 31) << 1)\n\t                }\n\t            };\n\t            module.exports = DataReader\n\t        }\n\t        , {\n\t            \"./utils\": 21\n\t        }],\n\t        6: [function(_dereq_, module, exports) {\n\t            exports.base64 = false;\n\t            exports.binary = false;\n\t            exports.dir = false;\n\t            exports.createFolders = false;\n\t            exports.date = null;\n\t            exports.compression = null;\n\t            exports.comment = null\n\t        }\n\t        , {}],\n\t        7: [function(_dereq_, module, exports) {\n\t            var utils = _dereq_(\"./utils\");\n\t            exports.string2binary = function(str) {\n\t                return utils.string2binary(str)\n\t            }\n\t            ;\n\t            exports.string2Uint8Array = function(str) {\n\t                return utils.transformTo(\"uint8array\", str)\n\t            }\n\t            ;\n\t            exports.uint8Array2String = function(array) {\n\t                return utils.transformTo(\"string\", array)\n\t            }\n\t            ;\n\t            exports.string2Blob = function(str) {\n\t                var buffer = utils.transformTo(\"arraybuffer\", str);\n\t                return utils.arrayBuffer2Blob(buffer)\n\t            }\n\t            ;\n\t            exports.arrayBuffer2Blob = function(buffer) {\n\t                return utils.arrayBuffer2Blob(buffer)\n\t            }\n\t            ;\n\t            exports.transformTo = function(outputType, input) {\n\t                return utils.transformTo(outputType, input)\n\t            }\n\t            ;\n\t            exports.getTypeOf = function(input) {\n\t                return utils.getTypeOf(input)\n\t            }\n\t            ;\n\t            exports.checkSupport = function(type) {\n\t                return utils.checkSupport(type)\n\t            }\n\t            ;\n\t            exports.MAX_VALUE_16BITS = utils.MAX_VALUE_16BITS;\n\t            exports.MAX_VALUE_32BITS = utils.MAX_VALUE_32BITS;\n\t            exports.pretty = function(str) {\n\t                return utils.pretty(str)\n\t            }\n\t            ;\n\t            exports.findCompression = function(compressionMethod) {\n\t                return utils.findCompression(compressionMethod)\n\t            }\n\t            ;\n\t            exports.isRegExp = function(object) {\n\t                return utils.isRegExp(object)\n\t            }\n\t        }\n\t        , {\n\t            \"./utils\": 21\n\t        }],\n\t        8: [function(_dereq_, module, exports) {\n\t            var USE_TYPEDARRAY = typeof Uint8Array !== \"undefined\" && typeof Uint16Array !== \"undefined\" && typeof Uint32Array !== \"undefined\";\n\t            var pako = _dereq_(\"pako\");\n\t            exports.uncompressInputType = USE_TYPEDARRAY ? \"uint8array\" : \"array\";\n\t            exports.compressInputType = USE_TYPEDARRAY ? \"uint8array\" : \"array\";\n\t            exports.magic = \"\\b\\x00\";\n\t            exports.compress = function(input) {\n\t                return pako.deflateRaw(input)\n\t            }\n\t            ;\n\t            exports.uncompress = function(input) {\n\t                return pako.inflateRaw(input)\n\t            }\n\t        }\n\t        , {\n\t            \"pako\": 24\n\t        }],\n\t        9: [function(_dereq_, module, exports) {\n\t            var base64 = _dereq_(\"./base64\");\n\t            function JSZip(data, options) {\n\t                if (!(this instanceof JSZip))\n\t                    return new JSZip(data,options);\n\t                this.files = {};\n\t                this.comment = null;\n\t                this.root = \"\";\n\t                if (data)\n\t                    this.load(data, options);\n\t                this.clone = function() {\n\t                    var newObj = new JSZip;\n\t                    for (var i in this)\n\t                        if (typeof this[i] !== \"function\")\n\t                            newObj[i] = this[i];\n\t                    return newObj\n\t                }\n\t            }\n\t            JSZip.prototype = _dereq_(\"./object\");\n\t            JSZip.prototype.load = _dereq_(\"./load\");\n\t            JSZip.support = _dereq_(\"./support\");\n\t            JSZip.defaults = _dereq_(\"./defaults\");\n\t            JSZip.utils = _dereq_(\"./deprecatedPublicUtils\");\n\t            JSZip.base64 = {\n\t                encode: function(input) {\n\t                    return base64.encode(input)\n\t                },\n\t                decode: function(input) {\n\t                    return base64.decode(input)\n\t                }\n\t            };\n\t            JSZip.compressions = _dereq_(\"./compressions\");\n\t            module.exports = JSZip\n\t        }\n\t        , {\n\t            \"./base64\": 1,\n\t            \"./compressions\": 3,\n\t            \"./defaults\": 6,\n\t            \"./deprecatedPublicUtils\": 7,\n\t            \"./load\": 10,\n\t            \"./object\": 13,\n\t            \"./support\": 17\n\t        }],\n\t        10: [function(_dereq_, module, exports) {\n\t            var base64 = _dereq_(\"./base64\");\n\t            var ZipEntries = _dereq_(\"./zipEntries\");\n\t            module.exports = function(data, options) {\n\t                var files, zipEntries, i, input;\n\t                options = options || {};\n\t                if (options.base64)\n\t                    data = base64.decode(data);\n\t                zipEntries = new ZipEntries(data,options);\n\t                files = zipEntries.files;\n\t                for (i = 0; i < files.length; i++) {\n\t                    input = files[i];\n\t                    this.file(input.fileName, input.decompressed, {\n\t                        binary: true,\n\t                        optimizedBinaryString: true,\n\t                        date: input.date,\n\t                        dir: input.dir,\n\t                        comment: input.fileComment.length ? input.fileComment : null,\n\t                        createFolders: options.createFolders\n\t                    })\n\t                }\n\t                if (zipEntries.zipComment.length)\n\t                    this.comment = zipEntries.zipComment;\n\t                return this\n\t            }\n\t        }\n\t        , {\n\t            \"./base64\": 1,\n\t            \"./zipEntries\": 22\n\t        }],\n\t        11: [function(_dereq_, module, exports) {\n\t            (function(Buffer) {\n\t                module.exports = function(data, encoding) {\n\t                    return new Buffer(data,encoding)\n\t                }\n\t                ;\n\t                module.exports.test = function(b) {\n\t                    return Buffer.isBuffer(b)\n\t                }\n\t            }\n\t            ).call(this, typeof Buffer !== \"undefined\" ? Buffer : undefined)\n\t        }\n\t        , {}],\n\t        12: [function(_dereq_, module, exports) {\n\t            var Uint8ArrayReader = _dereq_(\"./uint8ArrayReader\");\n\t            function NodeBufferReader(data) {\n\t                this.data = data;\n\t                this.length = this.data.length;\n\t                this.index = 0\n\t            }\n\t            NodeBufferReader.prototype = new Uint8ArrayReader;\n\t            NodeBufferReader.prototype.readData = function(size) {\n\t                this.checkOffset(size);\n\t                var result = this.data.slice(this.index, this.index + size);\n\t                this.index += size;\n\t                return result\n\t            }\n\t            ;\n\t            module.exports = NodeBufferReader\n\t        }\n\t        , {\n\t            \"./uint8ArrayReader\": 18\n\t        }],\n\t        13: [function(_dereq_, module, exports) {\n\t            var support = _dereq_(\"./support\");\n\t            var utils = _dereq_(\"./utils\");\n\t            var crc32 = _dereq_(\"./crc32\");\n\t            var signature = _dereq_(\"./signature\");\n\t            var defaults = _dereq_(\"./defaults\");\n\t            var base64 = _dereq_(\"./base64\");\n\t            var compressions = _dereq_(\"./compressions\");\n\t            var CompressedObject = _dereq_(\"./compressedObject\");\n\t            var nodeBuffer = _dereq_(\"./nodeBuffer\");\n\t            var utf8 = _dereq_(\"./utf8\");\n\t            var StringWriter = _dereq_(\"./stringWriter\");\n\t            var Uint8ArrayWriter = _dereq_(\"./uint8ArrayWriter\");\n\t            var getRawData = function(file) {\n\t                if (file._data instanceof CompressedObject) {\n\t                    file._data = file._data.getContent();\n\t                    file.options.binary = true;\n\t                    file.options.base64 = false;\n\t                    if (utils.getTypeOf(file._data) === \"uint8array\") {\n\t                        var copy = file._data;\n\t                        file._data = new Uint8Array(copy.length);\n\t                        if (copy.length !== 0)\n\t                            file._data.set(copy, 0)\n\t                    }\n\t                }\n\t                return file._data\n\t            };\n\t            var getBinaryData = function(file) {\n\t                var result = getRawData(file)\n\t                  , type = utils.getTypeOf(result);\n\t                if (type === \"string\") {\n\t                    if (!file.options.binary)\n\t                        if (support.nodebuffer)\n\t                            return nodeBuffer(result, \"utf-8\");\n\t                    return file.asBinary()\n\t                }\n\t                return result\n\t            };\n\t            var dataToString = function(asUTF8) {\n\t                var result = getRawData(this);\n\t                if (result === null || typeof result === \"undefined\")\n\t                    return \"\";\n\t                if (this.options.base64)\n\t                    result = base64.decode(result);\n\t                if (asUTF8 && this.options.binary)\n\t                    result = out.utf8decode(result);\n\t                else\n\t                    result = utils.transformTo(\"string\", result);\n\t                if (!asUTF8 && !this.options.binary)\n\t                    result = utils.transformTo(\"string\", out.utf8encode(result));\n\t                return result\n\t            };\n\t            var ZipObject = function(name, data, options) {\n\t                this.name = name;\n\t                this.dir = options.dir;\n\t                this.date = options.date;\n\t                this.comment = options.comment;\n\t                this._data = data;\n\t                this.options = options;\n\t                this._initialMetadata = {\n\t                    dir: options.dir,\n\t                    date: options.date\n\t                }\n\t            };\n\t            ZipObject.prototype = {\n\t                asText: function() {\n\t                    return dataToString.call(this, true)\n\t                },\n\t                asBinary: function() {\n\t                    return dataToString.call(this, false)\n\t                },\n\t                asNodeBuffer: function() {\n\t                    var result = getBinaryData(this);\n\t                    return utils.transformTo(\"nodebuffer\", result)\n\t                },\n\t                asUint8Array: function() {\n\t                    var result = getBinaryData(this);\n\t                    return utils.transformTo(\"uint8array\", result)\n\t                },\n\t                asArrayBuffer: function() {\n\t                    return this.asUint8Array().buffer\n\t                }\n\t            };\n\t            var decToHex = function(dec, bytes) {\n\t                var hex = \"\", i;\n\t                for (i = 0; i < bytes; i++) {\n\t                    hex += String.fromCharCode(dec & 255);\n\t                    dec = dec >>> 8\n\t                }\n\t                return hex\n\t            };\n\t            var extend = function() {\n\t                var result = {}, i, attr;\n\t                for (i = 0; i < arguments.length; i++)\n\t                    for (attr in arguments[i])\n\t                        if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === \"undefined\")\n\t                            result[attr] = arguments[i][attr];\n\t                return result\n\t            };\n\t            var prepareFileAttrs = function(o) {\n\t                o = o || {};\n\t                if (o.base64 === true && (o.binary === null || o.binary === undefined))\n\t                    o.binary = true;\n\t                o = extend(o, defaults);\n\t                o.date = o.date || new Date;\n\t                if (o.compression !== null)\n\t                    o.compression = o.compression.toUpperCase();\n\t                return o\n\t            };\n\t            var fileAdd = function(name, data, o) {\n\t                var dataType = utils.getTypeOf(data), parent;\n\t                o = prepareFileAttrs(o);\n\t                if (o.createFolders && (parent = parentFolder(name)))\n\t                    folderAdd.call(this, parent, true);\n\t                if (o.dir || data === null || typeof data === \"undefined\") {\n\t                    o.base64 = false;\n\t                    o.binary = false;\n\t                    data = null\n\t                } else if (dataType === \"string\") {\n\t                    if (o.binary && !o.base64)\n\t                        if (o.optimizedBinaryString !== true)\n\t                            data = utils.string2binary(data)\n\t                } else {\n\t                    o.base64 = false;\n\t                    o.binary = true;\n\t                    if (!dataType && !(data instanceof CompressedObject))\n\t                        throw new Error(\"The data of '\" + name + \"' is in an unsupported format !\");\n\t                    if (dataType === \"arraybuffer\")\n\t                        data = utils.transformTo(\"uint8array\", data)\n\t                }\n\t                var object = new ZipObject(name,data,o);\n\t                this.files[name] = object;\n\t                return object\n\t            };\n\t            var parentFolder = function(path) {\n\t                if (path.slice(-1) == \"/\")\n\t                    path = path.substring(0, path.length - 1);\n\t                var lastSlash = path.lastIndexOf(\"/\");\n\t                return lastSlash > 0 ? path.substring(0, lastSlash) : \"\"\n\t            };\n\t            var folderAdd = function(name, createFolders) {\n\t                if (name.slice(-1) != \"/\")\n\t                    name += \"/\";\n\t                createFolders = typeof createFolders !== \"undefined\" ? createFolders : false;\n\t                if (!this.files[name])\n\t                    fileAdd.call(this, name, null, {\n\t                        dir: true,\n\t                        createFolders: createFolders\n\t                    });\n\t                return this.files[name]\n\t            };\n\t            var generateCompressedObjectFrom = function(file, compression) {\n\t                var result = new CompressedObject, content;\n\t                if (file._data instanceof CompressedObject) {\n\t                    result.uncompressedSize = file._data.uncompressedSize;\n\t                    result.crc32 = file._data.crc32;\n\t                    if (result.uncompressedSize === 0 || file.dir) {\n\t                        compression = compressions[\"STORE\"];\n\t                        result.compressedContent = \"\";\n\t                        result.crc32 = 0\n\t                    } else if (file._data.compressionMethod === compression.magic)\n\t                        result.compressedContent = file._data.getCompressedContent();\n\t                    else {\n\t                        content = file._data.getContent();\n\t                        result.compressedContent = compression.compress(utils.transformTo(compression.compressInputType, content))\n\t                    }\n\t                } else {\n\t                    content = getBinaryData(file);\n\t                    if (!content || content.length === 0 || file.dir) {\n\t                        compression = compressions[\"STORE\"];\n\t                        content = \"\"\n\t                    }\n\t                    result.uncompressedSize = content.length;\n\t                    result.crc32 = crc32(content);\n\t                    result.compressedContent = compression.compress(utils.transformTo(compression.compressInputType, content))\n\t                }\n\t                result.compressedSize = result.compressedContent.length;\n\t                result.compressionMethod = compression.magic;\n\t                return result\n\t            };\n\t            var generateZipParts = function(name, file, compressedObject, offset) {\n\t                var data = compressedObject.compressedContent, utfEncodedFileName = utils.transformTo(\"string\", utf8.utf8encode(file.name)), comment = file.comment || \"\", utfEncodedComment = utils.transformTo(\"string\", utf8.utf8encode(comment)), useUTF8ForFileName = utfEncodedFileName.length !== file.name.length, useUTF8ForComment = utfEncodedComment.length !== comment.length, o = file.options, dosTime, dosDate, extraFields = \"\", unicodePathExtraField = \"\", unicodeCommentExtraField = \"\", dir, date;\n\t                if (file._initialMetadata.dir !== file.dir)\n\t                    dir = file.dir;\n\t                else\n\t                    dir = o.dir;\n\t                if (file._initialMetadata.date !== file.date)\n\t                    date = file.date;\n\t                else\n\t                    date = o.date;\n\t                dosTime = date.getHours();\n\t                dosTime = dosTime << 6;\n\t                dosTime = dosTime | date.getMinutes();\n\t                dosTime = dosTime << 5;\n\t                dosTime = dosTime | date.getSeconds() / 2;\n\t                dosDate = date.getFullYear() - 1980;\n\t                dosDate = dosDate << 4;\n\t                dosDate = dosDate | date.getMonth() + 1;\n\t                dosDate = dosDate << 5;\n\t                dosDate = dosDate | date.getDate();\n\t                if (useUTF8ForFileName) {\n\t                    unicodePathExtraField = decToHex(1, 1) + decToHex(crc32(utfEncodedFileName), 4) + utfEncodedFileName;\n\t                    extraFields += \"up\" + decToHex(unicodePathExtraField.length, 2) + unicodePathExtraField\n\t                }\n\t                if (useUTF8ForComment) {\n\t                    unicodeCommentExtraField = decToHex(1, 1) + decToHex(this.crc32(utfEncodedComment), 4) + utfEncodedComment;\n\t                    extraFields += \"uc\" + decToHex(unicodeCommentExtraField.length, 2) + unicodeCommentExtraField\n\t                }\n\t                var header = \"\";\n\t                header += \"\\n\\x00\";\n\t                header += useUTF8ForFileName || useUTF8ForComment ? \"\\x00\\b\" : \"\\x00\\x00\";\n\t                header += compressedObject.compressionMethod;\n\t                header += decToHex(dosTime, 2);\n\t                header += decToHex(dosDate, 2);\n\t                header += decToHex(compressedObject.crc32, 4);\n\t                header += decToHex(compressedObject.compressedSize, 4);\n\t                header += decToHex(compressedObject.uncompressedSize, 4);\n\t                header += decToHex(utfEncodedFileName.length, 2);\n\t                header += decToHex(extraFields.length, 2);\n\t                var fileRecord = signature.LOCAL_FILE_HEADER + header + utfEncodedFileName + extraFields;\n\t                var dirRecord = signature.CENTRAL_FILE_HEADER + \"\\u0014\\x00\" + header + decToHex(utfEncodedComment.length, 2) + \"\\x00\\x00\" + \"\\x00\\x00\" + (dir === true ? \"\\u0010\\x00\\x00\\x00\" : \"\\x00\\x00\\x00\\x00\") + decToHex(offset, 4) + utfEncodedFileName + extraFields + utfEncodedComment;\n\t                return {\n\t                    fileRecord: fileRecord,\n\t                    dirRecord: dirRecord,\n\t                    compressedObject: compressedObject\n\t                }\n\t            };\n\t            var out = {\n\t                load: function(stream, options) {\n\t                    throw new Error(\"Load method is not defined. Is the file jszip-load.js included ?\");\n\t                },\n\t                filter: function(search) {\n\t                    var result = [], filename, relativePath, file, fileClone;\n\t                    for (filename in this.files) {\n\t                        if (!this.files.hasOwnProperty(filename))\n\t                            continue;\n\t                        file = this.files[filename];\n\t                        fileClone = new ZipObject(file.name,file._data,extend(file.options));\n\t                        relativePath = filename.slice(this.root.length, filename.length);\n\t                        if (filename.slice(0, this.root.length) === this.root && search(relativePath, fileClone))\n\t                            result.push(fileClone)\n\t                    }\n\t                    return result\n\t                },\n\t                file: function(name, data, o) {\n\t                    if (arguments.length === 1)\n\t                        if (utils.isRegExp(name)) {\n\t                            var regexp = name;\n\t                            return this.filter(function(relativePath, file) {\n\t                                return !file.dir && regexp.test(relativePath)\n\t                            })\n\t                        } else\n\t                            return this.filter(function(relativePath, file) {\n\t                                return !file.dir && relativePath === name\n\t                            })[0] || null;\n\t                    else {\n\t                        name = this.root + name;\n\t                        fileAdd.call(this, name, data, o)\n\t                    }\n\t                    return this\n\t                },\n\t                folder: function(arg) {\n\t                    if (!arg)\n\t                        return this;\n\t                    if (utils.isRegExp(arg))\n\t                        return this.filter(function(relativePath, file) {\n\t                            return file.dir && arg.test(relativePath)\n\t                        });\n\t                    var name = this.root + arg;\n\t                    var newFolder = folderAdd.call(this, name);\n\t                    var ret = this.clone();\n\t                    ret.root = newFolder.name;\n\t                    return ret\n\t                },\n\t                remove: function(name) {\n\t                    name = this.root + name;\n\t                    var file = this.files[name];\n\t                    if (!file) {\n\t                        if (name.slice(-1) != \"/\")\n\t                            name += \"/\";\n\t                        file = this.files[name]\n\t                    }\n\t                    if (file && !file.dir)\n\t                        delete this.files[name];\n\t                    else {\n\t                        var kids = this.filter(function(relativePath, file) {\n\t                            return file.name.slice(0, name.length) === name\n\t                        });\n\t                        for (var i = 0; i < kids.length; i++)\n\t                            delete this.files[kids[i].name]\n\t                    }\n\t                    return this\n\t                },\n\t                generate: function(options) {\n\t                    options = extend(options || {}, {\n\t                        base64: true,\n\t                        compression: \"STORE\",\n\t                        type: \"base64\",\n\t                        comment: null\n\t                    });\n\t                    utils.checkSupport(options.type);\n\t                    var zipData = [], localDirLength = 0, centralDirLength = 0, writer, i, utfEncodedComment = utils.transformTo(\"string\", this.utf8encode(options.comment || this.comment || \"\"));\n\t                    for (var name in this.files) {\n\t                        if (!this.files.hasOwnProperty(name))\n\t                            continue;\n\t                        var file = this.files[name];\n\t                        var compressionName = file.options.compression || options.compression.toUpperCase();\n\t                        var compression = compressions[compressionName];\n\t                        if (!compression)\n\t                            throw new Error(compressionName + \" is not a valid compression method !\");\n\t                        var compressedObject = generateCompressedObjectFrom.call(this, file, compression);\n\t                        var zipPart = generateZipParts.call(this, name, file, compressedObject, localDirLength);\n\t                        localDirLength += zipPart.fileRecord.length + compressedObject.compressedSize;\n\t                        centralDirLength += zipPart.dirRecord.length;\n\t                        zipData.push(zipPart)\n\t                    }\n\t                    var dirEnd = \"\";\n\t                    dirEnd = signature.CENTRAL_DIRECTORY_END + \"\\x00\\x00\" + \"\\x00\\x00\" + decToHex(zipData.length, 2) + decToHex(zipData.length, 2) + decToHex(centralDirLength, 4) + decToHex(localDirLength, 4) + decToHex(utfEncodedComment.length, 2) + utfEncodedComment;\n\t                    var typeName = options.type.toLowerCase();\n\t                    if (typeName === \"uint8array\" || typeName === \"arraybuffer\" || typeName === \"blob\" || typeName === \"nodebuffer\")\n\t                        writer = new Uint8ArrayWriter(localDirLength + centralDirLength + dirEnd.length);\n\t                    else\n\t                        writer = new StringWriter(localDirLength + centralDirLength + dirEnd.length);\n\t                    for (i = 0; i < zipData.length; i++) {\n\t                        writer.append(zipData[i].fileRecord);\n\t                        writer.append(zipData[i].compressedObject.compressedContent)\n\t                    }\n\t                    for (i = 0; i < zipData.length; i++)\n\t                        writer.append(zipData[i].dirRecord);\n\t                    writer.append(dirEnd);\n\t                    var zip = writer.finalize();\n\t                    switch (options.type.toLowerCase()) {\n\t                    case \"uint8array\":\n\t                    case \"arraybuffer\":\n\t                    case \"nodebuffer\":\n\t                        return utils.transformTo(options.type.toLowerCase(), zip);\n\t                    case \"blob\":\n\t                        return utils.arrayBuffer2Blob(utils.transformTo(\"arraybuffer\", zip));\n\t                    case \"base64\":\n\t                        return options.base64 ? base64.encode(zip) : zip;\n\t                    default:\n\t                        return zip\n\t                    }\n\t                },\n\t                crc32: function(input, crc) {\n\t                    return crc32(input, crc)\n\t                },\n\t                utf8encode: function(string) {\n\t                    return utils.transformTo(\"string\", utf8.utf8encode(string))\n\t                },\n\t                utf8decode: function(input) {\n\t                    return utf8.utf8decode(input)\n\t                }\n\t            };\n\t            module.exports = out\n\t        }\n\t        , {\n\t            \"./base64\": 1,\n\t            \"./compressedObject\": 2,\n\t            \"./compressions\": 3,\n\t            \"./crc32\": 4,\n\t            \"./defaults\": 6,\n\t            \"./nodeBuffer\": 11,\n\t            \"./signature\": 14,\n\t            \"./stringWriter\": 16,\n\t            \"./support\": 17,\n\t            \"./uint8ArrayWriter\": 19,\n\t            \"./utf8\": 20,\n\t            \"./utils\": 21\n\t        }],\n\t        14: [function(_dereq_, module, exports) {\n\t            exports.LOCAL_FILE_HEADER = \"PK\\u0003\\u0004\";\n\t            exports.CENTRAL_FILE_HEADER = \"PK\\u0001\\u0002\";\n\t            exports.CENTRAL_DIRECTORY_END = \"PK\\u0005\\u0006\";\n\t            exports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = \"PK\\u0006\\u0007\";\n\t            exports.ZIP64_CENTRAL_DIRECTORY_END = \"PK\\u0006\\u0006\";\n\t            exports.DATA_DESCRIPTOR = \"PK\\u0007\\b\"\n\t        }\n\t        , {}],\n\t        15: [function(_dereq_, module, exports) {\n\t            var DataReader = _dereq_(\"./dataReader\");\n\t            var utils = _dereq_(\"./utils\");\n\t            function StringReader(data, optimizedBinaryString) {\n\t                this.data = data;\n\t                if (!optimizedBinaryString)\n\t                    this.data = utils.string2binary(this.data);\n\t                this.length = this.data.length;\n\t                this.index = 0\n\t            }\n\t            StringReader.prototype = new DataReader;\n\t            StringReader.prototype.byteAt = function(i) {\n\t                return this.data.charCodeAt(i)\n\t            }\n\t            ;\n\t            StringReader.prototype.lastIndexOfSignature = function(sig) {\n\t                return this.data.lastIndexOf(sig)\n\t            }\n\t            ;\n\t            StringReader.prototype.readData = function(size) {\n\t                this.checkOffset(size);\n\t                var result = this.data.slice(this.index, this.index + size);\n\t                this.index += size;\n\t                return result\n\t            }\n\t            ;\n\t            module.exports = StringReader\n\t        }\n\t        , {\n\t            \"./dataReader\": 5,\n\t            \"./utils\": 21\n\t        }],\n\t        16: [function(_dereq_, module, exports) {\n\t            var utils = _dereq_(\"./utils\");\n\t            var StringWriter = function() {\n\t                this.data = []\n\t            };\n\t            StringWriter.prototype = {\n\t                append: function(input) {\n\t                    input = utils.transformTo(\"string\", input);\n\t                    this.data.push(input)\n\t                },\n\t                finalize: function() {\n\t                    return this.data.join(\"\")\n\t                }\n\t            };\n\t            module.exports = StringWriter\n\t        }\n\t        , {\n\t            \"./utils\": 21\n\t        }],\n\t        17: [function(_dereq_, module, exports) {\n\t            (function(Buffer) {\n\t                exports.base64 = true;\n\t                exports.array = true;\n\t                exports.string = true;\n\t                exports.arraybuffer = typeof ArrayBuffer !== \"undefined\" && typeof Uint8Array !== \"undefined\";\n\t                exports.nodebuffer = typeof Buffer !== \"undefined\";\n\t                exports.uint8array = typeof Uint8Array !== \"undefined\";\n\t                if (typeof ArrayBuffer === \"undefined\")\n\t                    exports.blob = false;\n\t                else {\n\t                    var buffer = new ArrayBuffer(0);\n\t                    try {\n\t                        exports.blob = (new Blob([buffer],{\n\t                            type: \"application/zip\"\n\t                        })).size === 0\n\t                    } catch (e) {\n\t                        try {\n\t                            var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n\t                            var builder = new Builder;\n\t                            builder.append(buffer);\n\t                            exports.blob = builder.getBlob(\"application/zip\").size === 0\n\t                        } catch (e) {\n\t                            exports.blob = false\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t            ).call(this, typeof Buffer !== \"undefined\" ? Buffer : undefined)\n\t        }\n\t        , {}],\n\t        18: [function(_dereq_, module, exports) {\n\t            var DataReader = _dereq_(\"./dataReader\");\n\t            function Uint8ArrayReader(data) {\n\t                if (data) {\n\t                    this.data = data;\n\t                    this.length = this.data.length;\n\t                    this.index = 0\n\t                }\n\t            }\n\t            Uint8ArrayReader.prototype = new DataReader;\n\t            Uint8ArrayReader.prototype.byteAt = function(i) {\n\t                return this.data[i]\n\t            }\n\t            ;\n\t            Uint8ArrayReader.prototype.lastIndexOfSignature = function(sig) {\n\t                var sig0 = sig.charCodeAt(0)\n\t                  , sig1 = sig.charCodeAt(1)\n\t                  , sig2 = sig.charCodeAt(2)\n\t                  , sig3 = sig.charCodeAt(3);\n\t                for (var i = this.length - 4; i >= 0; --i)\n\t                    if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3)\n\t                        return i;\n\t                return -1\n\t            }\n\t            ;\n\t            Uint8ArrayReader.prototype.readData = function(size) {\n\t                this.checkOffset(size);\n\t                if (size === 0)\n\t                    return new Uint8Array(0);\n\t                var result = this.data.subarray(this.index, this.index + size);\n\t                this.index += size;\n\t                return result\n\t            }\n\t            ;\n\t            module.exports = Uint8ArrayReader\n\t        }\n\t        , {\n\t            \"./dataReader\": 5\n\t        }],\n\t        19: [function(_dereq_, module, exports) {\n\t            var utils = _dereq_(\"./utils\");\n\t            var Uint8ArrayWriter = function(length) {\n\t                this.data = new Uint8Array(length);\n\t                this.index = 0\n\t            };\n\t            Uint8ArrayWriter.prototype = {\n\t                append: function(input) {\n\t                    if (input.length !== 0) {\n\t                        input = utils.transformTo(\"uint8array\", input);\n\t                        this.data.set(input, this.index);\n\t                        this.index += input.length\n\t                    }\n\t                },\n\t                finalize: function() {\n\t                    return this.data\n\t                }\n\t            };\n\t            module.exports = Uint8ArrayWriter\n\t        }\n\t        , {\n\t            \"./utils\": 21\n\t        }],\n\t        20: [function(_dereq_, module, exports) {\n\t            var utils = _dereq_(\"./utils\");\n\t            var support = _dereq_(\"./support\");\n\t            var nodeBuffer = _dereq_(\"./nodeBuffer\");\n\t            var _utf8len = new Array(256);\n\t            for (var i = 0; i < 256; i++)\n\t                _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;\n\t            _utf8len[254] = _utf8len[254] = 1;\n\t            var string2buf = function(str) {\n\t                var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\t                for (m_pos = 0; m_pos < str_len; m_pos++) {\n\t                    c = str.charCodeAt(m_pos);\n\t                    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {\n\t                        c2 = str.charCodeAt(m_pos + 1);\n\t                        if ((c2 & 64512) === 56320) {\n\t                            c = 65536 + (c - 55296 << 10) + (c2 - 56320);\n\t                            m_pos++\n\t                        }\n\t                    }\n\t                    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4\n\t                }\n\t                if (support.uint8array)\n\t                    buf = new Uint8Array(buf_len);\n\t                else\n\t                    buf = new Array(buf_len);\n\t                for (i = 0,\n\t                m_pos = 0; i < buf_len; m_pos++) {\n\t                    c = str.charCodeAt(m_pos);\n\t                    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {\n\t                        c2 = str.charCodeAt(m_pos + 1);\n\t                        if ((c2 & 64512) === 56320) {\n\t                            c = 65536 + (c - 55296 << 10) + (c2 - 56320);\n\t                            m_pos++\n\t                        }\n\t                    }\n\t                    if (c < 128)\n\t                        buf[i++] = c;\n\t                    else if (c < 2048) {\n\t                        buf[i++] = 192 | c >>> 6;\n\t                        buf[i++] = 128 | c & 63\n\t                    } else if (c < 65536) {\n\t                        buf[i++] = 224 | c >>> 12;\n\t                        buf[i++] = 128 | c >>> 6 & 63;\n\t                        buf[i++] = 128 | c & 63\n\t                    } else {\n\t                        buf[i++] = 240 | c >>> 18;\n\t                        buf[i++] = 128 | c >>> 12 & 63;\n\t                        buf[i++] = 128 | c >>> 6 & 63;\n\t                        buf[i++] = 128 | c & 63\n\t                    }\n\t                }\n\t                return buf\n\t            };\n\t            var utf8border = function(buf, max) {\n\t                var pos;\n\t                max = max || buf.length;\n\t                if (max > buf.length)\n\t                    max = buf.length;\n\t                pos = max - 1;\n\t                while (pos >= 0 && (buf[pos] & 192) === 128)\n\t                    pos--;\n\t                if (pos < 0)\n\t                    return max;\n\t                if (pos === 0)\n\t                    return max;\n\t                return pos + _utf8len[buf[pos]] > max ? pos : max\n\t            };\n\t            var buf2string = function(buf) {\n\t                var str, i, out, c, c_len;\n\t                var len = buf.length;\n\t                var utf16buf = new Array(len * 2);\n\t                for (out = 0,\n\t                i = 0; i < len; ) {\n\t                    c = buf[i++];\n\t                    if (c < 128) {\n\t                        utf16buf[out++] = c;\n\t                        continue\n\t                    }\n\t                    c_len = _utf8len[c];\n\t                    if (c_len > 4) {\n\t                        utf16buf[out++] = 65533;\n\t                        i += c_len - 1;\n\t                        continue\n\t                    }\n\t                    c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;\n\t                    while (c_len > 1 && i < len) {\n\t                        c = c << 6 | buf[i++] & 63;\n\t                        c_len--\n\t                    }\n\t                    if (c_len > 1) {\n\t                        utf16buf[out++] = 65533;\n\t                        continue\n\t                    }\n\t                    if (c < 65536)\n\t                        utf16buf[out++] = c;\n\t                    else {\n\t                        c -= 65536;\n\t                        utf16buf[out++] = 55296 | c >> 10 & 1023;\n\t                        utf16buf[out++] = 56320 | c & 1023\n\t                    }\n\t                }\n\t                if (utf16buf.length !== out)\n\t                    if (utf16buf.subarray)\n\t                        utf16buf = utf16buf.subarray(0, out);\n\t                    else\n\t                        utf16buf.length = out;\n\t                return utils.applyFromCharCode(utf16buf)\n\t            };\n\t            exports.utf8encode = function utf8encode(str) {\n\t                if (support.nodebuffer)\n\t                    return nodeBuffer(str, \"utf-8\");\n\t                return string2buf(str)\n\t            }\n\t            ;\n\t            exports.utf8decode = function utf8decode(buf) {\n\t                if (support.nodebuffer)\n\t                    return utils.transformTo(\"nodebuffer\", buf).toString(\"utf-8\");\n\t                buf = utils.transformTo(support.uint8array ? \"uint8array\" : \"array\", buf);\n\t                var result = []\n\t                  , k = 0\n\t                  , len = buf.length\n\t                  , chunk = 65536;\n\t                while (k < len) {\n\t                    var nextBoundary = utf8border(buf, Math.min(k + chunk, len));\n\t                    if (support.uint8array)\n\t                        result.push(buf2string(buf.subarray(k, nextBoundary)));\n\t                    else\n\t                        result.push(buf2string(buf.slice(k, nextBoundary)));\n\t                    k = nextBoundary\n\t                }\n\t                return result.join(\"\")\n\t            }\n\t        }\n\t        , {\n\t            \"./nodeBuffer\": 11,\n\t            \"./support\": 17,\n\t            \"./utils\": 21\n\t        }],\n\t        21: [function(_dereq_, module, exports) {\n\t            var support = _dereq_(\"./support\");\n\t            var compressions = _dereq_(\"./compressions\");\n\t            var nodeBuffer = _dereq_(\"./nodeBuffer\");\n\t            exports.string2binary = function(str) {\n\t                var result = \"\";\n\t                for (var i = 0; i < str.length; i++)\n\t                    result += String.fromCharCode(str.charCodeAt(i) & 255);\n\t                return result\n\t            }\n\t            ;\n\t            exports.arrayBuffer2Blob = function(buffer) {\n\t                exports.checkSupport(\"blob\");\n\t                try {\n\t                    return new Blob([buffer],{\n\t                        type: \"application/zip\"\n\t                    })\n\t                } catch (e) {\n\t                    try {\n\t                        var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n\t                        var builder = new Builder;\n\t                        builder.append(buffer);\n\t                        return builder.getBlob(\"application/zip\")\n\t                    } catch (e) {\n\t                        throw new Error(\"Bug : can't construct the Blob.\");\n\t                    }\n\t                }\n\t            }\n\t            ;\n\t            function identity(input) {\n\t                return input\n\t            }\n\t            function stringToArrayLike(str, array) {\n\t                for (var i = 0; i < str.length; ++i)\n\t                    array[i] = str.charCodeAt(i) & 255;\n\t                return array\n\t            }\n\t            function arrayLikeToString(array) {\n\t                var chunk = 65536;\n\t                var result = []\n\t                  , len = array.length\n\t                  , type = exports.getTypeOf(array)\n\t                  , k = 0\n\t                  , canUseApply = true;\n\t                try {\n\t                    switch (type) {\n\t                    case \"uint8array\":\n\t                        String.fromCharCode.apply(null, new Uint8Array(0));\n\t                        break;\n\t                    case \"nodebuffer\":\n\t                        String.fromCharCode.apply(null, nodeBuffer(0));\n\t                        break\n\t                    }\n\t                } catch (e) {\n\t                    canUseApply = false\n\t                }\n\t                if (!canUseApply) {\n\t                    var resultStr = \"\";\n\t                    for (var i = 0; i < array.length; i++)\n\t                        resultStr += String.fromCharCode(array[i]);\n\t                    return resultStr\n\t                }\n\t                while (k < len && chunk > 1)\n\t                    try {\n\t                        if (type === \"array\" || type === \"nodebuffer\")\n\t                            result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));\n\t                        else\n\t                            result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));\n\t                        k += chunk\n\t                    } catch (e) {\n\t                        chunk = Math.floor(chunk / 2)\n\t                    }\n\t                return result.join(\"\")\n\t            }\n\t            exports.applyFromCharCode = arrayLikeToString;\n\t            function arrayLikeToArrayLike(arrayFrom, arrayTo) {\n\t                for (var i = 0; i < arrayFrom.length; i++)\n\t                    arrayTo[i] = arrayFrom[i];\n\t                return arrayTo\n\t            }\n\t            var transform = {};\n\t            transform[\"string\"] = {\n\t                \"string\": identity,\n\t                \"array\": function(input) {\n\t                    return stringToArrayLike(input, new Array(input.length))\n\t                },\n\t                \"arraybuffer\": function(input) {\n\t                    return transform[\"string\"][\"uint8array\"](input).buffer\n\t                },\n\t                \"uint8array\": function(input) {\n\t                    return stringToArrayLike(input, new Uint8Array(input.length))\n\t                },\n\t                \"nodebuffer\": function(input) {\n\t                    return stringToArrayLike(input, nodeBuffer(input.length))\n\t                }\n\t            };\n\t            transform[\"array\"] = {\n\t                \"string\": arrayLikeToString,\n\t                \"array\": identity,\n\t                \"arraybuffer\": function(input) {\n\t                    return (new Uint8Array(input)).buffer\n\t                },\n\t                \"uint8array\": function(input) {\n\t                    return new Uint8Array(input)\n\t                },\n\t                \"nodebuffer\": function(input) {\n\t                    return nodeBuffer(input)\n\t                }\n\t            };\n\t            transform[\"arraybuffer\"] = {\n\t                \"string\": function(input) {\n\t                    return arrayLikeToString(new Uint8Array(input))\n\t                },\n\t                \"array\": function(input) {\n\t                    return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength))\n\t                },\n\t                \"arraybuffer\": identity,\n\t                \"uint8array\": function(input) {\n\t                    return new Uint8Array(input)\n\t                },\n\t                \"nodebuffer\": function(input) {\n\t                    return nodeBuffer(new Uint8Array(input))\n\t                }\n\t            };\n\t            transform[\"uint8array\"] = {\n\t                \"string\": arrayLikeToString,\n\t                \"array\": function(input) {\n\t                    return arrayLikeToArrayLike(input, new Array(input.length))\n\t                },\n\t                \"arraybuffer\": function(input) {\n\t                    return input.buffer\n\t                },\n\t                \"uint8array\": identity,\n\t                \"nodebuffer\": function(input) {\n\t                    return nodeBuffer(input)\n\t                }\n\t            };\n\t            transform[\"nodebuffer\"] = {\n\t                \"string\": arrayLikeToString,\n\t                \"array\": function(input) {\n\t                    return arrayLikeToArrayLike(input, new Array(input.length))\n\t                },\n\t                \"arraybuffer\": function(input) {\n\t                    return transform[\"nodebuffer\"][\"uint8array\"](input).buffer\n\t                },\n\t                \"uint8array\": function(input) {\n\t                    return arrayLikeToArrayLike(input, new Uint8Array(input.length))\n\t                },\n\t                \"nodebuffer\": identity\n\t            };\n\t            exports.transformTo = function(outputType, input) {\n\t                if (!input)\n\t                    input = \"\";\n\t                if (!outputType)\n\t                    return input;\n\t                exports.checkSupport(outputType);\n\t                var inputType = exports.getTypeOf(input);\n\t                var result = transform[inputType][outputType](input);\n\t                return result\n\t            }\n\t            ;\n\t            exports.getTypeOf = function(input) {\n\t                if (typeof input === \"string\")\n\t                    return \"string\";\n\t                if (Object.prototype.toString.call(input) === \"[object Array]\")\n\t                    return \"array\";\n\t                if (support.nodebuffer && nodeBuffer.test(input))\n\t                    return \"nodebuffer\";\n\t                if (support.uint8array && input instanceof Uint8Array)\n\t                    return \"uint8array\";\n\t                if (support.arraybuffer && input instanceof ArrayBuffer)\n\t                    return \"arraybuffer\"\n\t            }\n\t            ;\n\t            exports.checkSupport = function(type) {\n\t                var supported = support[type.toLowerCase()];\n\t                if (!supported)\n\t                    throw new Error(type + \" is not supported by this browser\");\n\t            }\n\t            ;\n\t            exports.MAX_VALUE_16BITS = 65535;\n\t            exports.MAX_VALUE_32BITS = -1;\n\t            exports.pretty = function(str) {\n\t                var res = \"\", code, i;\n\t                for (i = 0; i < (str || \"\").length; i++) {\n\t                    code = str.charCodeAt(i);\n\t                    res += \"\\\\x\" + (code < 16 ? \"0\" : \"\") + code.toString(16).toUpperCase()\n\t                }\n\t                return res\n\t            }\n\t            ;\n\t            exports.findCompression = function(compressionMethod) {\n\t                for (var method in compressions) {\n\t                    if (!compressions.hasOwnProperty(method))\n\t                        continue;\n\t                    if (compressions[method].magic === compressionMethod)\n\t                        return compressions[method]\n\t                }\n\t                return null\n\t            }\n\t            ;\n\t            exports.isRegExp = function(object) {\n\t                return Object.prototype.toString.call(object) === \"[object RegExp]\"\n\t            }\n\t        }\n\t        , {\n\t            \"./compressions\": 3,\n\t            \"./nodeBuffer\": 11,\n\t            \"./support\": 17\n\t        }],\n\t        22: [function(_dereq_, module, exports) {\n\t            var StringReader = _dereq_(\"./stringReader\");\n\t            var NodeBufferReader = _dereq_(\"./nodeBufferReader\");\n\t            var Uint8ArrayReader = _dereq_(\"./uint8ArrayReader\");\n\t            var utils = _dereq_(\"./utils\");\n\t            var sig = _dereq_(\"./signature\");\n\t            var ZipEntry = _dereq_(\"./zipEntry\");\n\t            var support = _dereq_(\"./support\");\n\t            var jszipProto = _dereq_(\"./object\");\n\t            function ZipEntries(data, loadOptions) {\n\t                this.files = [];\n\t                this.loadOptions = loadOptions;\n\t                if (data)\n\t                    this.load(data)\n\t            }\n\t            ZipEntries.prototype = {\n\t                checkSignature: function(expectedSignature) {\n\t                    var signature = this.reader.readString(4);\n\t                    if (signature !== expectedSignature)\n\t                        throw new Error(\"Corrupted zip or bug : unexpected signature \" + \"(\" + utils.pretty(signature) + \", expected \" + utils.pretty(expectedSignature) + \")\");\n\t                },\n\t                readBlockEndOfCentral: function() {\n\t                    this.diskNumber = this.reader.readInt(2);\n\t                    this.diskWithCentralDirStart = this.reader.readInt(2);\n\t                    this.centralDirRecordsOnThisDisk = this.reader.readInt(2);\n\t                    this.centralDirRecords = this.reader.readInt(2);\n\t                    this.centralDirSize = this.reader.readInt(4);\n\t                    this.centralDirOffset = this.reader.readInt(4);\n\t                    this.zipCommentLength = this.reader.readInt(2);\n\t                    this.zipComment = this.reader.readString(this.zipCommentLength);\n\t                    this.zipComment = jszipProto.utf8decode(this.zipComment)\n\t                },\n\t                readBlockZip64EndOfCentral: function() {\n\t                    this.zip64EndOfCentralSize = this.reader.readInt(8);\n\t                    this.versionMadeBy = this.reader.readString(2);\n\t                    this.versionNeeded = this.reader.readInt(2);\n\t                    this.diskNumber = this.reader.readInt(4);\n\t                    this.diskWithCentralDirStart = this.reader.readInt(4);\n\t                    this.centralDirRecordsOnThisDisk = this.reader.readInt(8);\n\t                    this.centralDirRecords = this.reader.readInt(8);\n\t                    this.centralDirSize = this.reader.readInt(8);\n\t                    this.centralDirOffset = this.reader.readInt(8);\n\t                    this.zip64ExtensibleData = {};\n\t                    var extraDataSize = this.zip64EndOfCentralSize - 44, index = 0, extraFieldId, extraFieldLength, extraFieldValue;\n\t                    while (index < extraDataSize) {\n\t                        extraFieldId = this.reader.readInt(2);\n\t                        extraFieldLength = this.reader.readInt(4);\n\t                        extraFieldValue = this.reader.readString(extraFieldLength);\n\t                        this.zip64ExtensibleData[extraFieldId] = {\n\t                            id: extraFieldId,\n\t                            length: extraFieldLength,\n\t                            value: extraFieldValue\n\t                        }\n\t                    }\n\t                },\n\t                readBlockZip64EndOfCentralLocator: function() {\n\t                    this.diskWithZip64CentralDirStart = this.reader.readInt(4);\n\t                    this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);\n\t                    this.disksCount = this.reader.readInt(4);\n\t                    if (this.disksCount > 1)\n\t                        throw new Error(\"Multi-volumes zip are not supported\");\n\t                },\n\t                readLocalFiles: function() {\n\t                    var i, file;\n\t                    for (i = 0; i < this.files.length; i++) {\n\t                        file = this.files[i];\n\t                        this.reader.setIndex(file.localHeaderOffset);\n\t                        this.checkSignature(sig.LOCAL_FILE_HEADER);\n\t                        file.readLocalPart(this.reader);\n\t                        file.handleUTF8()\n\t                    }\n\t                },\n\t                readCentralDir: function() {\n\t                    var file;\n\t                    this.reader.setIndex(this.centralDirOffset);\n\t                    while (this.reader.readString(4) === sig.CENTRAL_FILE_HEADER) {\n\t                        file = new ZipEntry({\n\t                            zip64: this.zip64\n\t                        },this.loadOptions);\n\t                        file.readCentralPart(this.reader);\n\t                        this.files.push(file)\n\t                    }\n\t                },\n\t                readEndOfCentral: function() {\n\t                    var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);\n\t                    if (offset === -1)\n\t                        throw new Error(\"Corrupted zip : can't find end of central directory\");\n\t                    this.reader.setIndex(offset);\n\t                    this.checkSignature(sig.CENTRAL_DIRECTORY_END);\n\t                    this.readBlockEndOfCentral();\n\t                    if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {\n\t                        this.zip64 = true;\n\t                        offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);\n\t                        if (offset === -1)\n\t                            throw new Error(\"Corrupted zip : can't find the ZIP64 end of central directory locator\");\n\t                        this.reader.setIndex(offset);\n\t                        this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);\n\t                        this.readBlockZip64EndOfCentralLocator();\n\t                        this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);\n\t                        this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);\n\t                        this.readBlockZip64EndOfCentral()\n\t                    }\n\t                },\n\t                prepareReader: function(data) {\n\t                    var type = utils.getTypeOf(data);\n\t                    if (type === \"string\" && !support.uint8array)\n\t                        this.reader = new StringReader(data,this.loadOptions.optimizedBinaryString);\n\t                    else if (type === \"nodebuffer\")\n\t                        this.reader = new NodeBufferReader(data);\n\t                    else\n\t                        this.reader = new Uint8ArrayReader(utils.transformTo(\"uint8array\", data))\n\t                },\n\t                load: function(data) {\n\t                    this.prepareReader(data);\n\t                    this.readEndOfCentral();\n\t                    this.readCentralDir();\n\t                    this.readLocalFiles()\n\t                }\n\t            };\n\t            module.exports = ZipEntries\n\t        }\n\t        , {\n\t            \"./nodeBufferReader\": 12,\n\t            \"./object\": 13,\n\t            \"./signature\": 14,\n\t            \"./stringReader\": 15,\n\t            \"./support\": 17,\n\t            \"./uint8ArrayReader\": 18,\n\t            \"./utils\": 21,\n\t            \"./zipEntry\": 23\n\t        }],\n\t        23: [function(_dereq_, module, exports) {\n\t            var StringReader = _dereq_(\"./stringReader\");\n\t            var utils = _dereq_(\"./utils\");\n\t            var CompressedObject = _dereq_(\"./compressedObject\");\n\t            var jszipProto = _dereq_(\"./object\");\n\t            function ZipEntry(options, loadOptions) {\n\t                this.options = options;\n\t                this.loadOptions = loadOptions\n\t            }\n\t            ZipEntry.prototype = {\n\t                isEncrypted: function() {\n\t                    return (this.bitFlag & 1) === 1\n\t                },\n\t                useUTF8: function() {\n\t                    return (this.bitFlag & 2048) === 2048\n\t                },\n\t                prepareCompressedContent: function(reader, from, length) {\n\t                    return function() {\n\t                        var previousIndex = reader.index;\n\t                        reader.setIndex(from);\n\t                        var compressedFileData = reader.readData(length);\n\t                        reader.setIndex(previousIndex);\n\t                        return compressedFileData\n\t                    }\n\t                },\n\t                prepareContent: function(reader, from, length, compression, uncompressedSize) {\n\t                    return function() {\n\t                        var compressedFileData = utils.transformTo(compression.uncompressInputType, this.getCompressedContent());\n\t                        var uncompressedFileData = compression.uncompress(compressedFileData);\n\t                        if (uncompressedFileData.length !== uncompressedSize)\n\t                            throw new Error(\"Bug : uncompressed data size mismatch\");\n\t                        return uncompressedFileData\n\t                    }\n\t                },\n\t                readLocalPart: function(reader) {\n\t                    var compression, localExtraFieldsLength;\n\t                    reader.skip(22);\n\t                    this.fileNameLength = reader.readInt(2);\n\t                    localExtraFieldsLength = reader.readInt(2);\n\t                    this.fileName = reader.readString(this.fileNameLength);\n\t                    reader.skip(localExtraFieldsLength);\n\t                    if (this.compressedSize == -1 || this.uncompressedSize == -1)\n\t                        throw new Error(\"Bug or corrupted zip : didn't get enough informations from the central directory \" + \"(compressedSize == -1 || uncompressedSize == -1)\");\n\t                    compression = utils.findCompression(this.compressionMethod);\n\t                    if (compression === null)\n\t                        throw new Error(\"Corrupted zip : compression \" + utils.pretty(this.compressionMethod) + \" unknown (inner file : \" + this.fileName + \")\");\n\t                    this.decompressed = new CompressedObject;\n\t                    this.decompressed.compressedSize = this.compressedSize;\n\t                    this.decompressed.uncompressedSize = this.uncompressedSize;\n\t                    this.decompressed.crc32 = this.crc32;\n\t                    this.decompressed.compressionMethod = this.compressionMethod;\n\t                    this.decompressed.getCompressedContent = this.prepareCompressedContent(reader, reader.index, this.compressedSize, compression);\n\t                    this.decompressed.getContent = this.prepareContent(reader, reader.index, this.compressedSize, compression, this.uncompressedSize);\n\t                    if (this.loadOptions.checkCRC32) {\n\t                        this.decompressed = utils.transformTo(\"string\", this.decompressed.getContent());\n\t                        if (jszipProto.crc32(this.decompressed) !== this.crc32)\n\t                            throw new Error(\"Corrupted zip : CRC32 mismatch\");\n\t                    }\n\t                },\n\t                readCentralPart: function(reader) {\n\t                    this.versionMadeBy = reader.readString(2);\n\t                    this.versionNeeded = reader.readInt(2);\n\t                    this.bitFlag = reader.readInt(2);\n\t                    this.compressionMethod = reader.readString(2);\n\t                    this.date = reader.readDate();\n\t                    this.crc32 = reader.readInt(4);\n\t                    this.compressedSize = reader.readInt(4);\n\t                    this.uncompressedSize = reader.readInt(4);\n\t                    this.fileNameLength = reader.readInt(2);\n\t                    this.extraFieldsLength = reader.readInt(2);\n\t                    this.fileCommentLength = reader.readInt(2);\n\t                    this.diskNumberStart = reader.readInt(2);\n\t                    this.internalFileAttributes = reader.readInt(2);\n\t                    this.externalFileAttributes = reader.readInt(4);\n\t                    this.localHeaderOffset = reader.readInt(4);\n\t                    if (this.isEncrypted())\n\t                        throw new Error(\"Encrypted zip are not supported\");\n\t                    this.fileName = reader.readString(this.fileNameLength);\n\t                    this.readExtraFields(reader);\n\t                    this.parseZIP64ExtraField(reader);\n\t                    this.fileComment = reader.readString(this.fileCommentLength);\n\t                    this.dir = this.externalFileAttributes & 16 ? true : false\n\t                },\n\t                parseZIP64ExtraField: function(reader) {\n\t                    if (!this.extraFields[1])\n\t                        return;\n\t                    var extraReader = new StringReader(this.extraFields[1].value);\n\t                    if (this.uncompressedSize === utils.MAX_VALUE_32BITS)\n\t                        this.uncompressedSize = extraReader.readInt(8);\n\t                    if (this.compressedSize === utils.MAX_VALUE_32BITS)\n\t                        this.compressedSize = extraReader.readInt(8);\n\t                    if (this.localHeaderOffset === utils.MAX_VALUE_32BITS)\n\t                        this.localHeaderOffset = extraReader.readInt(8);\n\t                    if (this.diskNumberStart === utils.MAX_VALUE_32BITS)\n\t                        this.diskNumberStart = extraReader.readInt(4)\n\t                },\n\t                readExtraFields: function(reader) {\n\t                    var start = reader.index, extraFieldId, extraFieldLength, extraFieldValue;\n\t                    this.extraFields = this.extraFields || {};\n\t                    while (reader.index < start + this.extraFieldsLength) {\n\t                        extraFieldId = reader.readInt(2);\n\t                        extraFieldLength = reader.readInt(2);\n\t                        extraFieldValue = reader.readString(extraFieldLength);\n\t                        this.extraFields[extraFieldId] = {\n\t                            id: extraFieldId,\n\t                            length: extraFieldLength,\n\t                            value: extraFieldValue\n\t                        }\n\t                    }\n\t                },\n\t                handleUTF8: function() {\n\t                    if (this.useUTF8()) {\n\t                        this.fileName = jszipProto.utf8decode(this.fileName);\n\t                        this.fileComment = jszipProto.utf8decode(this.fileComment)\n\t                    } else {\n\t                        var upath = this.findExtraFieldUnicodePath();\n\t                        if (upath !== null)\n\t                            this.fileName = upath;\n\t                        var ucomment = this.findExtraFieldUnicodeComment();\n\t                        if (ucomment !== null)\n\t                            this.fileComment = ucomment\n\t                    }\n\t                },\n\t                findExtraFieldUnicodePath: function() {\n\t                    var upathField = this.extraFields[28789];\n\t                    if (upathField) {\n\t                        var extraReader = new StringReader(upathField.value);\n\t                        if (extraReader.readInt(1) !== 1)\n\t                            return null;\n\t                        if (jszipProto.crc32(this.fileName) !== extraReader.readInt(4))\n\t                            return null;\n\t                        return jszipProto.utf8decode(extraReader.readString(upathField.length - 5))\n\t                    }\n\t                    return null\n\t                },\n\t                findExtraFieldUnicodeComment: function() {\n\t                    var ucommentField = this.extraFields[25461];\n\t                    if (ucommentField) {\n\t                        var extraReader = new StringReader(ucommentField.value);\n\t                        if (extraReader.readInt(1) !== 1)\n\t                            return null;\n\t                        if (jszipProto.crc32(this.fileComment) !== extraReader.readInt(4))\n\t                            return null;\n\t                        return jszipProto.utf8decode(extraReader.readString(ucommentField.length - 5))\n\t                    }\n\t                    return null\n\t                }\n\t            };\n\t            module.exports = ZipEntry\n\t        }\n\t        , {\n\t            \"./compressedObject\": 2,\n\t            \"./object\": 13,\n\t            \"./stringReader\": 15,\n\t            \"./utils\": 21\n\t        }],\n\t        24: [function(_dereq_, module, exports) {\n\t            var assign = _dereq_(\"./lib/utils/common\").assign;\n\t            var deflate = _dereq_(\"./lib/deflate\");\n\t            var inflate = _dereq_(\"./lib/inflate\");\n\t            var constants = _dereq_(\"./lib/zlib/constants\");\n\t            var pako = {};\n\t            assign(pako, deflate, inflate, constants);\n\t            module.exports = pako\n\t        }\n\t        , {\n\t            \"./lib/deflate\": 25,\n\t            \"./lib/inflate\": 26,\n\t            \"./lib/utils/common\": 27,\n\t            \"./lib/zlib/constants\": 30\n\t        }],\n\t        25: [function(_dereq_, module, exports) {\n\t            var zlib_deflate = _dereq_(\"./zlib/deflate.js\");\n\t            var utils = _dereq_(\"./utils/common\");\n\t            var strings = _dereq_(\"./utils/strings\");\n\t            var msg = _dereq_(\"./zlib/messages\");\n\t            var zstream = _dereq_(\"./zlib/zstream\");\n\t            var Z_NO_FLUSH = 0;\n\t            var Z_FINISH = 4;\n\t            var Z_OK = 0;\n\t            var Z_STREAM_END = 1;\n\t            var Z_DEFAULT_COMPRESSION = -1;\n\t            var Z_DEFAULT_STRATEGY = 0;\n\t            var Z_DEFLATED = 8;\n\t            var Deflate = function(options) {\n\t                this.options = utils.assign({\n\t                    level: Z_DEFAULT_COMPRESSION,\n\t                    method: Z_DEFLATED,\n\t                    chunkSize: 16384,\n\t                    windowBits: 15,\n\t                    memLevel: 8,\n\t                    strategy: Z_DEFAULT_STRATEGY,\n\t                    to: \"\"\n\t                }, options || {});\n\t                var opt = this.options;\n\t                if (opt.raw && opt.windowBits > 0)\n\t                    opt.windowBits = -opt.windowBits;\n\t                else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16)\n\t                    opt.windowBits += 16;\n\t                this.err = 0;\n\t                this.msg = \"\";\n\t                this.ended = false;\n\t                this.chunks = [];\n\t                this.strm = new zstream;\n\t                this.strm.avail_out = 0;\n\t                var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);\n\t                if (status !== Z_OK)\n\t                    throw new Error(msg[status]);\n\t                if (opt.header)\n\t                    zlib_deflate.deflateSetHeader(this.strm, opt.header)\n\t            };\n\t            Deflate.prototype.push = function(data, mode) {\n\t                var strm = this.strm;\n\t                var chunkSize = this.options.chunkSize;\n\t                var status, _mode;\n\t                if (this.ended)\n\t                    return false;\n\t                _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;\n\t                if (typeof data === \"string\")\n\t                    strm.input = strings.string2buf(data);\n\t                else\n\t                    strm.input = data;\n\t                strm.next_in = 0;\n\t                strm.avail_in = strm.input.length;\n\t                do {\n\t                    if (strm.avail_out === 0) {\n\t                        strm.output = new utils.Buf8(chunkSize);\n\t                        strm.next_out = 0;\n\t                        strm.avail_out = chunkSize\n\t                    }\n\t                    status = zlib_deflate.deflate(strm, _mode);\n\t                    if (status !== Z_STREAM_END && status !== Z_OK) {\n\t                        this.onEnd(status);\n\t                        this.ended = true;\n\t                        return false\n\t                    }\n\t                    if (strm.avail_out === 0 || strm.avail_in === 0 && _mode === Z_FINISH)\n\t                        if (this.options.to === \"string\")\n\t                            this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));\n\t                        else\n\t                            this.onData(utils.shrinkBuf(strm.output, strm.next_out))\n\t                } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);\n\t                if (_mode === Z_FINISH) {\n\t                    status = zlib_deflate.deflateEnd(this.strm);\n\t                    this.onEnd(status);\n\t                    this.ended = true;\n\t                    return status === Z_OK\n\t                }\n\t                return true\n\t            }\n\t            ;\n\t            Deflate.prototype.onData = function(chunk) {\n\t                this.chunks.push(chunk)\n\t            }\n\t            ;\n\t            Deflate.prototype.onEnd = function(status) {\n\t                if (status === Z_OK)\n\t                    if (this.options.to === \"string\")\n\t                        this.result = this.chunks.join(\"\");\n\t                    else\n\t                        this.result = utils.flattenChunks(this.chunks);\n\t                this.chunks = [];\n\t                this.err = status;\n\t                this.msg = this.strm.msg\n\t            }\n\t            ;\n\t            function deflate(input, options) {\n\t                var deflator = new Deflate(options);\n\t                deflator.push(input, true);\n\t                if (deflator.err)\n\t                    throw deflator.msg;\n\t                return deflator.result\n\t            }\n\t            function deflateRaw(input, options) {\n\t                options = options || {};\n\t                options.raw = true;\n\t                return deflate(input, options)\n\t            }\n\t            function gzip(input, options) {\n\t                options = options || {};\n\t                options.gzip = true;\n\t                return deflate(input, options)\n\t            }\n\t            exports.Deflate = Deflate;\n\t            exports.deflate = deflate;\n\t            exports.deflateRaw = deflateRaw;\n\t            exports.gzip = gzip\n\t        }\n\t        , {\n\t            \"./utils/common\": 27,\n\t            \"./utils/strings\": 28,\n\t            \"./zlib/deflate.js\": 32,\n\t            \"./zlib/messages\": 37,\n\t            \"./zlib/zstream\": 39\n\t        }],\n\t        26: [function(_dereq_, module, exports) {\n\t            var zlib_inflate = _dereq_(\"./zlib/inflate.js\");\n\t            var utils = _dereq_(\"./utils/common\");\n\t            var strings = _dereq_(\"./utils/strings\");\n\t            var c = _dereq_(\"./zlib/constants\");\n\t            var msg = _dereq_(\"./zlib/messages\");\n\t            var zstream = _dereq_(\"./zlib/zstream\");\n\t            var gzheader = _dereq_(\"./zlib/gzheader\");\n\t            var Inflate = function(options) {\n\t                this.options = utils.assign({\n\t                    chunkSize: 16384,\n\t                    windowBits: 0,\n\t                    to: \"\"\n\t                }, options || {});\n\t                var opt = this.options;\n\t                if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {\n\t                    opt.windowBits = -opt.windowBits;\n\t                    if (opt.windowBits === 0)\n\t                        opt.windowBits = -15\n\t                }\n\t                if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits))\n\t                    opt.windowBits += 32;\n\t                if (opt.windowBits > 15 && opt.windowBits < 48)\n\t                    if ((opt.windowBits & 15) === 0)\n\t                        opt.windowBits |= 15;\n\t                this.err = 0;\n\t                this.msg = \"\";\n\t                this.ended = false;\n\t                this.chunks = [];\n\t                this.strm = new zstream;\n\t                this.strm.avail_out = 0;\n\t                var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);\n\t                if (status !== c.Z_OK)\n\t                    throw new Error(msg[status]);\n\t                this.header = new gzheader;\n\t                zlib_inflate.inflateGetHeader(this.strm, this.header)\n\t            };\n\t            Inflate.prototype.push = function(data, mode) {\n\t                var strm = this.strm;\n\t                var chunkSize = this.options.chunkSize;\n\t                var status, _mode;\n\t                var next_out_utf8, tail, utf8str;\n\t                if (this.ended)\n\t                    return false;\n\t                _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;\n\t                if (typeof data === \"string\")\n\t                    strm.input = strings.binstring2buf(data);\n\t                else\n\t                    strm.input = data;\n\t                strm.next_in = 0;\n\t                strm.avail_in = strm.input.length;\n\t                do {\n\t                    if (strm.avail_out === 0) {\n\t                        strm.output = new utils.Buf8(chunkSize);\n\t                        strm.next_out = 0;\n\t                        strm.avail_out = chunkSize\n\t                    }\n\t                    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);\n\t                    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {\n\t                        this.onEnd(status);\n\t                        this.ended = true;\n\t                        return false\n\t                    }\n\t                    if (strm.next_out)\n\t                        if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && _mode === c.Z_FINISH)\n\t                            if (this.options.to === \"string\") {\n\t                                next_out_utf8 = strings.utf8border(strm.output, strm.next_out);\n\t                                tail = strm.next_out - next_out_utf8;\n\t                                utf8str = strings.buf2string(strm.output, next_out_utf8);\n\t                                strm.next_out = tail;\n\t                                strm.avail_out = chunkSize - tail;\n\t                                if (tail)\n\t                                    utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);\n\t                                this.onData(utf8str)\n\t                            } else\n\t                                this.onData(utils.shrinkBuf(strm.output, strm.next_out))\n\t                } while (strm.avail_in > 0 && status !== c.Z_STREAM_END);\n\t                if (status === c.Z_STREAM_END)\n\t                    _mode = c.Z_FINISH;\n\t                if (_mode === c.Z_FINISH) {\n\t                    status = zlib_inflate.inflateEnd(this.strm);\n\t                    this.onEnd(status);\n\t                    this.ended = true;\n\t                    return status === c.Z_OK\n\t                }\n\t                return true\n\t            }\n\t            ;\n\t            Inflate.prototype.onData = function(chunk) {\n\t                this.chunks.push(chunk)\n\t            }\n\t            ;\n\t            Inflate.prototype.onEnd = function(status) {\n\t                if (status === c.Z_OK)\n\t                    if (this.options.to === \"string\")\n\t                        this.result = this.chunks.join(\"\");\n\t                    else\n\t                        this.result = utils.flattenChunks(this.chunks);\n\t                this.chunks = [];\n\t                this.err = status;\n\t                this.msg = this.strm.msg\n\t            }\n\t            ;\n\t            function inflate(input, options) {\n\t                var inflator = new Inflate(options);\n\t                inflator.push(input, true);\n\t                if (inflator.err)\n\t                    throw inflator.msg;\n\t                return inflator.result\n\t            }\n\t            function inflateRaw(input, options) {\n\t                options = options || {};\n\t                options.raw = true;\n\t                return inflate(input, options)\n\t            }\n\t            exports.Inflate = Inflate;\n\t            exports.inflate = inflate;\n\t            exports.inflateRaw = inflateRaw;\n\t            exports.ungzip = inflate\n\t        }\n\t        , {\n\t            \"./utils/common\": 27,\n\t            \"./utils/strings\": 28,\n\t            \"./zlib/constants\": 30,\n\t            \"./zlib/gzheader\": 33,\n\t            \"./zlib/inflate.js\": 35,\n\t            \"./zlib/messages\": 37,\n\t            \"./zlib/zstream\": 39\n\t        }],\n\t        27: [function(_dereq_, module, exports) {\n\t            var TYPED_OK = typeof Uint8Array !== \"undefined\" && typeof Uint16Array !== \"undefined\" && typeof Int32Array !== \"undefined\";\n\t            exports.assign = function(obj) {\n\t                var sources = Array.prototype.slice.call(arguments, 1);\n\t                while (sources.length) {\n\t                    var source = sources.shift();\n\t                    if (!source)\n\t                        continue;\n\t                    if (typeof source !== \"object\")\n\t                        throw new TypeError(source + \"must be non-object\");\n\t                    for (var p in source)\n\t                        if (source.hasOwnProperty(p))\n\t                            obj[p] = source[p]\n\t                }\n\t                return obj\n\t            }\n\t            ;\n\t            exports.shrinkBuf = function(buf, size) {\n\t                if (buf.length === size)\n\t                    return buf;\n\t                if (buf.subarray)\n\t                    return buf.subarray(0, size);\n\t                buf.length = size;\n\t                return buf\n\t            }\n\t            ;\n\t            var fnTyped = {\n\t                arraySet: function(dest, src, src_offs, len, dest_offs) {\n\t                    if (src.subarray && dest.subarray) {\n\t                        dest.set(src.subarray(src_offs, src_offs + len), dest_offs);\n\t                        return\n\t                    }\n\t                    for (var i = 0; i < len; i++)\n\t                        dest[dest_offs + i] = src[src_offs + i]\n\t                },\n\t                flattenChunks: function(chunks) {\n\t                    var i, l, len, pos, chunk, result;\n\t                    len = 0;\n\t                    for (i = 0,\n\t                    l = chunks.length; i < l; i++)\n\t                        len += chunks[i].length;\n\t                    result = new Uint8Array(len);\n\t                    pos = 0;\n\t                    for (i = 0,\n\t                    l = chunks.length; i < l; i++) {\n\t                        chunk = chunks[i];\n\t                        result.set(chunk, pos);\n\t                        pos += chunk.length\n\t                    }\n\t                    return result\n\t                }\n\t            };\n\t            var fnUntyped = {\n\t                arraySet: function(dest, src, src_offs, len, dest_offs) {\n\t                    for (var i = 0; i < len; i++)\n\t                        dest[dest_offs + i] = src[src_offs + i]\n\t                },\n\t                flattenChunks: function(chunks) {\n\t                    return [].concat.apply([], chunks)\n\t                }\n\t            };\n\t            exports.setTyped = function(on) {\n\t                if (on) {\n\t                    exports.Buf8 = Uint8Array;\n\t                    exports.Buf16 = Uint16Array;\n\t                    exports.Buf32 = Int32Array;\n\t                    exports.assign(exports, fnTyped)\n\t                } else {\n\t                    exports.Buf8 = Array;\n\t                    exports.Buf16 = Array;\n\t                    exports.Buf32 = Array;\n\t                    exports.assign(exports, fnUntyped)\n\t                }\n\t            }\n\t            ;\n\t            exports.setTyped(TYPED_OK)\n\t        }\n\t        , {}],\n\t        28: [function(_dereq_, module, exports) {\n\t            var utils = _dereq_(\"./common\");\n\t            var STR_APPLY_OK = true;\n\t            var STR_APPLY_UIA_OK = true;\n\t            try {\n\t                String.fromCharCode.apply(null, [0])\n\t            } catch (__) {\n\t                STR_APPLY_OK = false\n\t            }\n\t            try {\n\t                String.fromCharCode.apply(null, new Uint8Array(1))\n\t            } catch (__) {\n\t                STR_APPLY_UIA_OK = false\n\t            }\n\t            var _utf8len = new utils.Buf8(256);\n\t            for (var i = 0; i < 256; i++)\n\t                _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;\n\t            _utf8len[254] = _utf8len[254] = 1;\n\t            exports.string2buf = function(str) {\n\t                var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\t                for (m_pos = 0; m_pos < str_len; m_pos++) {\n\t                    c = str.charCodeAt(m_pos);\n\t                    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {\n\t                        c2 = str.charCodeAt(m_pos + 1);\n\t                        if ((c2 & 64512) === 56320) {\n\t                            c = 65536 + (c - 55296 << 10) + (c2 - 56320);\n\t                            m_pos++\n\t                        }\n\t                    }\n\t                    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4\n\t                }\n\t                buf = new utils.Buf8(buf_len);\n\t                for (i = 0,\n\t                m_pos = 0; i < buf_len; m_pos++) {\n\t                    c = str.charCodeAt(m_pos);\n\t                    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {\n\t                        c2 = str.charCodeAt(m_pos + 1);\n\t                        if ((c2 & 64512) === 56320) {\n\t                            c = 65536 + (c - 55296 << 10) + (c2 - 56320);\n\t                            m_pos++\n\t                        }\n\t                    }\n\t                    if (c < 128)\n\t                        buf[i++] = c;\n\t                    else if (c < 2048) {\n\t                        buf[i++] = 192 | c >>> 6;\n\t                        buf[i++] = 128 | c & 63\n\t                    } else if (c < 65536) {\n\t                        buf[i++] = 224 | c >>> 12;\n\t                        buf[i++] = 128 | c >>> 6 & 63;\n\t                        buf[i++] = 128 | c & 63\n\t                    } else {\n\t                        buf[i++] = 240 | c >>> 18;\n\t                        buf[i++] = 128 | c >>> 12 & 63;\n\t                        buf[i++] = 128 | c >>> 6 & 63;\n\t                        buf[i++] = 128 | c & 63\n\t                    }\n\t                }\n\t                return buf\n\t            }\n\t            ;\n\t            function buf2binstring(buf, len) {\n\t                if (len < 65537)\n\t                    if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK)\n\t                        return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));\n\t                var result = \"\";\n\t                for (var i = 0; i < len; i++)\n\t                    result += String.fromCharCode(buf[i]);\n\t                return result\n\t            }\n\t            exports.buf2binstring = function(buf) {\n\t                return buf2binstring(buf, buf.length)\n\t            }\n\t            ;\n\t            exports.binstring2buf = function(str) {\n\t                var buf = new utils.Buf8(str.length);\n\t                for (var i = 0, len = buf.length; i < len; i++)\n\t                    buf[i] = str.charCodeAt(i);\n\t                return buf\n\t            }\n\t            ;\n\t            exports.buf2string = function(buf, max) {\n\t                var i, out, c, c_len;\n\t                var len = max || buf.length;\n\t                var utf16buf = new Array(len * 2);\n\t                for (out = 0,\n\t                i = 0; i < len; ) {\n\t                    c = buf[i++];\n\t                    if (c < 128) {\n\t                        utf16buf[out++] = c;\n\t                        continue\n\t                    }\n\t                    c_len = _utf8len[c];\n\t                    if (c_len > 4) {\n\t                        utf16buf[out++] = 65533;\n\t                        i += c_len - 1;\n\t                        continue\n\t                    }\n\t                    c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;\n\t                    while (c_len > 1 && i < len) {\n\t                        c = c << 6 | buf[i++] & 63;\n\t                        c_len--\n\t                    }\n\t                    if (c_len > 1) {\n\t                        utf16buf[out++] = 65533;\n\t                        continue\n\t                    }\n\t                    if (c < 65536)\n\t                        utf16buf[out++] = c;\n\t                    else {\n\t                        c -= 65536;\n\t                        utf16buf[out++] = 55296 | c >> 10 & 1023;\n\t                        utf16buf[out++] = 56320 | c & 1023\n\t                    }\n\t                }\n\t                return buf2binstring(utf16buf, out)\n\t            }\n\t            ;\n\t            exports.utf8border = function(buf, max) {\n\t                var pos;\n\t                max = max || buf.length;\n\t                if (max > buf.length)\n\t                    max = buf.length;\n\t                pos = max - 1;\n\t                while (pos >= 0 && (buf[pos] & 192) === 128)\n\t                    pos--;\n\t                if (pos < 0)\n\t                    return max;\n\t                if (pos === 0)\n\t                    return max;\n\t                return pos + _utf8len[buf[pos]] > max ? pos : max\n\t            }\n\t        }\n\t        , {\n\t            \"./common\": 27\n\t        }],\n\t        29: [function(_dereq_, module, exports) {\n\t            function adler32(adler, buf, len, pos) {\n\t                var s1 = adler & 65535 | 0\n\t                  , s2 = adler >>> 16 & 65535 | 0\n\t                  , n = 0;\n\t                while (len !== 0) {\n\t                    n = len > 2E3 ? 2E3 : len;\n\t                    len -= n;\n\t                    do {\n\t                        s1 = s1 + buf[pos++] | 0;\n\t                        s2 = s2 + s1 | 0\n\t                    } while (--n);\n\t                    s1 %= 65521;\n\t                    s2 %= 65521\n\t                }\n\t                return s1 | s2 << 16 | 0\n\t            }\n\t            module.exports = adler32\n\t        }\n\t        , {}],\n\t        30: [function(_dereq_, module, exports) {\n\t            module.exports = {\n\t                Z_NO_FLUSH: 0,\n\t                Z_PARTIAL_FLUSH: 1,\n\t                Z_SYNC_FLUSH: 2,\n\t                Z_FULL_FLUSH: 3,\n\t                Z_FINISH: 4,\n\t                Z_BLOCK: 5,\n\t                Z_TREES: 6,\n\t                Z_OK: 0,\n\t                Z_STREAM_END: 1,\n\t                Z_NEED_DICT: 2,\n\t                Z_ERRNO: -1,\n\t                Z_STREAM_ERROR: -2,\n\t                Z_DATA_ERROR: -3,\n\t                Z_BUF_ERROR: -5,\n\t                Z_NO_COMPRESSION: 0,\n\t                Z_BEST_SPEED: 1,\n\t                Z_BEST_COMPRESSION: 9,\n\t                Z_DEFAULT_COMPRESSION: -1,\n\t                Z_FILTERED: 1,\n\t                Z_HUFFMAN_ONLY: 2,\n\t                Z_RLE: 3,\n\t                Z_FIXED: 4,\n\t                Z_DEFAULT_STRATEGY: 0,\n\t                Z_BINARY: 0,\n\t                Z_TEXT: 1,\n\t                Z_UNKNOWN: 2,\n\t                Z_DEFLATED: 8\n\t            }\n\t        }\n\t        , {}],\n\t        31: [function(_dereq_, module, exports) {\n\t            function makeTable() {\n\t                var c, table = [];\n\t                for (var n = 0; n < 256; n++) {\n\t                    c = n;\n\t                    for (var k = 0; k < 8; k++)\n\t                        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;\n\t                    table[n] = c\n\t                }\n\t                return table\n\t            }\n\t            var crcTable = makeTable();\n\t            function crc32(crc, buf, len, pos) {\n\t                var t = crcTable\n\t                  , end = pos + len;\n\t                crc = crc ^ -1;\n\t                for (var i = pos; i < end; i++)\n\t                    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];\n\t                return crc ^ -1\n\t            }\n\t            module.exports = crc32\n\t        }\n\t        , {}],\n\t        32: [function(_dereq_, module, exports) {\n\t            var utils = _dereq_(\"../utils/common\");\n\t            var trees = _dereq_(\"./trees\");\n\t            var adler32 = _dereq_(\"./adler32\");\n\t            var crc32 = _dereq_(\"./crc32\");\n\t            var msg = _dereq_(\"./messages\");\n\t            var Z_NO_FLUSH = 0;\n\t            var Z_PARTIAL_FLUSH = 1;\n\t            var Z_FULL_FLUSH = 3;\n\t            var Z_FINISH = 4;\n\t            var Z_BLOCK = 5;\n\t            var Z_OK = 0;\n\t            var Z_STREAM_END = 1;\n\t            var Z_STREAM_ERROR = -2;\n\t            var Z_DATA_ERROR = -3;\n\t            var Z_BUF_ERROR = -5;\n\t            var Z_DEFAULT_COMPRESSION = -1;\n\t            var Z_FILTERED = 1;\n\t            var Z_HUFFMAN_ONLY = 2;\n\t            var Z_RLE = 3;\n\t            var Z_FIXED = 4;\n\t            var Z_DEFAULT_STRATEGY = 0;\n\t            var Z_UNKNOWN = 2;\n\t            var Z_DEFLATED = 8;\n\t            var MAX_MEM_LEVEL = 9;\n\t            var MAX_WBITS = 15;\n\t            var DEF_MEM_LEVEL = 8;\n\t            var LENGTH_CODES = 29;\n\t            var LITERALS = 256;\n\t            var L_CODES = LITERALS + 1 + LENGTH_CODES;\n\t            var D_CODES = 30;\n\t            var BL_CODES = 19;\n\t            var HEAP_SIZE = 2 * L_CODES + 1;\n\t            var MAX_BITS = 15;\n\t            var MIN_MATCH = 3;\n\t            var MAX_MATCH = 258;\n\t            var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;\n\t            var PRESET_DICT = 32;\n\t            var INIT_STATE = 42;\n\t            var EXTRA_STATE = 69;\n\t            var NAME_STATE = 73;\n\t            var COMMENT_STATE = 91;\n\t            var HCRC_STATE = 103;\n\t            var BUSY_STATE = 113;\n\t            var FINISH_STATE = 666;\n\t            var BS_NEED_MORE = 1;\n\t            var BS_BLOCK_DONE = 2;\n\t            var BS_FINISH_STARTED = 3;\n\t            var BS_FINISH_DONE = 4;\n\t            var OS_CODE = 3;\n\t            function err(strm, errorCode) {\n\t                strm.msg = msg[errorCode];\n\t                return errorCode\n\t            }\n\t            function rank(f) {\n\t                return (f << 1) - (f > 4 ? 9 : 0)\n\t            }\n\t            function zero(buf) {\n\t                var len = buf.length;\n\t                while (--len >= 0)\n\t                    buf[len] = 0\n\t            }\n\t            function flush_pending(strm) {\n\t                var s = strm.state;\n\t                var len = s.pending;\n\t                if (len > strm.avail_out)\n\t                    len = strm.avail_out;\n\t                if (len === 0)\n\t                    return;\n\t                utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);\n\t                strm.next_out += len;\n\t                s.pending_out += len;\n\t                strm.total_out += len;\n\t                strm.avail_out -= len;\n\t                s.pending -= len;\n\t                if (s.pending === 0)\n\t                    s.pending_out = 0\n\t            }\n\t            function flush_block_only(s, last) {\n\t                trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);\n\t                s.block_start = s.strstart;\n\t                flush_pending(s.strm)\n\t            }\n\t            function put_byte(s, b) {\n\t                s.pending_buf[s.pending++] = b\n\t            }\n\t            function putShortMSB(s, b) {\n\t                s.pending_buf[s.pending++] = b >>> 8 & 255;\n\t                s.pending_buf[s.pending++] = b & 255\n\t            }\n\t            function read_buf(strm, buf, start, size) {\n\t                var len = strm.avail_in;\n\t                if (len > size)\n\t                    len = size;\n\t                if (len === 0)\n\t                    return 0;\n\t                strm.avail_in -= len;\n\t                utils.arraySet(buf, strm.input, strm.next_in, len, start);\n\t                if (strm.state.wrap === 1)\n\t                    strm.adler = adler32(strm.adler, buf, len, start);\n\t                else if (strm.state.wrap === 2)\n\t                    strm.adler = crc32(strm.adler, buf, len, start);\n\t                strm.next_in += len;\n\t                strm.total_in += len;\n\t                return len\n\t            }\n\t            function longest_match(s, cur_match) {\n\t                var chain_length = s.max_chain_length;\n\t                var scan = s.strstart;\n\t                var match;\n\t                var len;\n\t                var best_len = s.prev_length;\n\t                var nice_match = s.nice_match;\n\t                var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;\n\t                var _win = s.window;\n\t                var wmask = s.w_mask;\n\t                var prev = s.prev;\n\t                var strend = s.strstart + MAX_MATCH;\n\t                var scan_end1 = _win[scan + best_len - 1];\n\t                var scan_end = _win[scan + best_len];\n\t                if (s.prev_length >= s.good_match)\n\t                    chain_length >>= 2;\n\t                if (nice_match > s.lookahead)\n\t                    nice_match = s.lookahead;\n\t                do {\n\t                    match = cur_match;\n\t                    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1])\n\t                        continue;\n\t                    scan += 2;\n\t                    match++;\n\t                    do\n\t                        ;\n\t                    while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);\n\t                    len = MAX_MATCH - (strend - scan);\n\t                    scan = strend - MAX_MATCH;\n\t                    if (len > best_len) {\n\t                        s.match_start = cur_match;\n\t                        best_len = len;\n\t                        if (len >= nice_match)\n\t                            break;\n\t                        scan_end1 = _win[scan + best_len - 1];\n\t                        scan_end = _win[scan + best_len]\n\t                    }\n\t                } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\t                if (best_len <= s.lookahead)\n\t                    return best_len;\n\t                return s.lookahead\n\t            }\n\t            function fill_window(s) {\n\t                var _w_size = s.w_size;\n\t                var p, n, m, more, str;\n\t                do {\n\t                    more = s.window_size - s.lookahead - s.strstart;\n\t                    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n\t                        utils.arraySet(s.window, s.window, _w_size, _w_size, 0);\n\t                        s.match_start -= _w_size;\n\t                        s.strstart -= _w_size;\n\t                        s.block_start -= _w_size;\n\t                        n = s.hash_size;\n\t                        p = n;\n\t                        do {\n\t                            m = s.head[--p];\n\t                            s.head[p] = m >= _w_size ? m - _w_size : 0\n\t                        } while (--n);\n\t                        n = _w_size;\n\t                        p = n;\n\t                        do {\n\t                            m = s.prev[--p];\n\t                            s.prev[p] = m >= _w_size ? m - _w_size : 0\n\t                        } while (--n);\n\t                        more += _w_size\n\t                    }\n\t                    if (s.strm.avail_in === 0)\n\t                        break;\n\t                    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n\t                    s.lookahead += n;\n\t                    if (s.lookahead + s.insert >= MIN_MATCH) {\n\t                        str = s.strstart - s.insert;\n\t                        s.ins_h = s.window[str];\n\t                        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;\n\t                        while (s.insert) {\n\t                            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\t                            s.prev[str & s.w_mask] = s.head[s.ins_h];\n\t                            s.head[s.ins_h] = str;\n\t                            str++;\n\t                            s.insert--;\n\t                            if (s.lookahead + s.insert < MIN_MATCH)\n\t                                break\n\t                        }\n\t                    }\n\t                } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0)\n\t            }\n\t            function deflate_stored(s, flush) {\n\t                var max_block_size = 65535;\n\t                if (max_block_size > s.pending_buf_size - 5)\n\t                    max_block_size = s.pending_buf_size - 5;\n\t                for (; ; ) {\n\t                    if (s.lookahead <= 1) {\n\t                        fill_window(s);\n\t                        if (s.lookahead === 0 && flush === Z_NO_FLUSH)\n\t                            return BS_NEED_MORE;\n\t                        if (s.lookahead === 0)\n\t                            break\n\t                    }\n\t                    s.strstart += s.lookahead;\n\t                    s.lookahead = 0;\n\t                    var max_start = s.block_start + max_block_size;\n\t                    if (s.strstart === 0 || s.strstart >= max_start) {\n\t                        s.lookahead = s.strstart - max_start;\n\t                        s.strstart = max_start;\n\t                        flush_block_only(s, false);\n\t                        if (s.strm.avail_out === 0)\n\t                            return BS_NEED_MORE\n\t                    }\n\t                    if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {\n\t                        flush_block_only(s, false);\n\t                        if (s.strm.avail_out === 0)\n\t                            return BS_NEED_MORE\n\t                    }\n\t                }\n\t                s.insert = 0;\n\t                if (flush === Z_FINISH) {\n\t                    flush_block_only(s, true);\n\t                    if (s.strm.avail_out === 0)\n\t                        return BS_FINISH_STARTED;\n\t                    return BS_FINISH_DONE\n\t                }\n\t                if (s.strstart > s.block_start) {\n\t                    flush_block_only(s, false);\n\t                    if (s.strm.avail_out === 0)\n\t                        return BS_NEED_MORE\n\t                }\n\t                return BS_NEED_MORE\n\t            }\n\t            function deflate_fast(s, flush) {\n\t                var hash_head;\n\t                var bflush;\n\t                for (; ; ) {\n\t                    if (s.lookahead < MIN_LOOKAHEAD) {\n\t                        fill_window(s);\n\t                        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH)\n\t                            return BS_NEED_MORE;\n\t                        if (s.lookahead === 0)\n\t                            break\n\t                    }\n\t                    hash_head = 0;\n\t                    if (s.lookahead >= MIN_MATCH) {\n\t                        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n\t                        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n\t                        s.head[s.ins_h] = s.strstart\n\t                    }\n\t                    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD)\n\t                        s.match_length = longest_match(s, hash_head);\n\t                    if (s.match_length >= MIN_MATCH) {\n\t                        bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n\t                        s.lookahead -= s.match_length;\n\t                        if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {\n\t                            s.match_length--;\n\t                            do {\n\t                                s.strstart++;\n\t                                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n\t                                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n\t                                s.head[s.ins_h] = s.strstart\n\t                            } while (--s.match_length !== 0);\n\t                            s.strstart++\n\t                        } else {\n\t                            s.strstart += s.match_length;\n\t                            s.match_length = 0;\n\t                            s.ins_h = s.window[s.strstart];\n\t                            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask\n\t                        }\n\t                    } else {\n\t                        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\t                        s.lookahead--;\n\t                        s.strstart++\n\t                    }\n\t                    if (bflush) {\n\t                        flush_block_only(s, false);\n\t                        if (s.strm.avail_out === 0)\n\t                            return BS_NEED_MORE\n\t                    }\n\t                }\n\t                s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n\t                if (flush === Z_FINISH) {\n\t                    flush_block_only(s, true);\n\t                    if (s.strm.avail_out === 0)\n\t                        return BS_FINISH_STARTED;\n\t                    return BS_FINISH_DONE\n\t                }\n\t                if (s.last_lit) {\n\t                    flush_block_only(s, false);\n\t                    if (s.strm.avail_out === 0)\n\t                        return BS_NEED_MORE\n\t                }\n\t                return BS_BLOCK_DONE\n\t            }\n\t            function deflate_slow(s, flush) {\n\t                var hash_head;\n\t                var bflush;\n\t                var max_insert;\n\t                for (; ; ) {\n\t                    if (s.lookahead < MIN_LOOKAHEAD) {\n\t                        fill_window(s);\n\t                        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH)\n\t                            return BS_NEED_MORE;\n\t                        if (s.lookahead === 0)\n\t                            break\n\t                    }\n\t                    hash_head = 0;\n\t                    if (s.lookahead >= MIN_MATCH) {\n\t                        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n\t                        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n\t                        s.head[s.ins_h] = s.strstart\n\t                    }\n\t                    s.prev_length = s.match_length;\n\t                    s.prev_match = s.match_start;\n\t                    s.match_length = MIN_MATCH - 1;\n\t                    if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {\n\t                        s.match_length = longest_match(s, hash_head);\n\t                        if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096))\n\t                            s.match_length = MIN_MATCH - 1\n\t                    }\n\t                    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n\t                        max_insert = s.strstart + s.lookahead - MIN_MATCH;\n\t                        bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n\t                        s.lookahead -= s.prev_length - 1;\n\t                        s.prev_length -= 2;\n\t                        do\n\t                            if (++s.strstart <= max_insert) {\n\t                                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n\t                                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n\t                                s.head[s.ins_h] = s.strstart\n\t                            }\n\t                        while (--s.prev_length !== 0);\n\t                        s.match_available = 0;\n\t                        s.match_length = MIN_MATCH - 1;\n\t                        s.strstart++;\n\t                        if (bflush) {\n\t                            flush_block_only(s, false);\n\t                            if (s.strm.avail_out === 0)\n\t                                return BS_NEED_MORE\n\t                        }\n\t                    } else if (s.match_available) {\n\t                        bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\t                        if (bflush)\n\t                            flush_block_only(s, false);\n\t                        s.strstart++;\n\t                        s.lookahead--;\n\t                        if (s.strm.avail_out === 0)\n\t                            return BS_NEED_MORE\n\t                    } else {\n\t                        s.match_available = 1;\n\t                        s.strstart++;\n\t                        s.lookahead--\n\t                    }\n\t                }\n\t                if (s.match_available) {\n\t                    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\t                    s.match_available = 0\n\t                }\n\t                s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n\t                if (flush === Z_FINISH) {\n\t                    flush_block_only(s, true);\n\t                    if (s.strm.avail_out === 0)\n\t                        return BS_FINISH_STARTED;\n\t                    return BS_FINISH_DONE\n\t                }\n\t                if (s.last_lit) {\n\t                    flush_block_only(s, false);\n\t                    if (s.strm.avail_out === 0)\n\t                        return BS_NEED_MORE\n\t                }\n\t                return BS_BLOCK_DONE\n\t            }\n\t            function deflate_rle(s, flush) {\n\t                var bflush;\n\t                var prev;\n\t                var scan, strend;\n\t                var _win = s.window;\n\t                for (; ; ) {\n\t                    if (s.lookahead <= MAX_MATCH) {\n\t                        fill_window(s);\n\t                        if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH)\n\t                            return BS_NEED_MORE;\n\t                        if (s.lookahead === 0)\n\t                            break\n\t                    }\n\t                    s.match_length = 0;\n\t                    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n\t                        scan = s.strstart - 1;\n\t                        prev = _win[scan];\n\t                        if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n\t                            strend = s.strstart + MAX_MATCH;\n\t                            do\n\t                                ;\n\t                            while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);\n\t                            s.match_length = MAX_MATCH - (strend - scan);\n\t                            if (s.match_length > s.lookahead)\n\t                                s.match_length = s.lookahead\n\t                        }\n\t                    }\n\t                    if (s.match_length >= MIN_MATCH) {\n\t                        bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);\n\t                        s.lookahead -= s.match_length;\n\t                        s.strstart += s.match_length;\n\t                        s.match_length = 0\n\t                    } else {\n\t                        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\t                        s.lookahead--;\n\t                        s.strstart++\n\t                    }\n\t                    if (bflush) {\n\t                        flush_block_only(s, false);\n\t                        if (s.strm.avail_out === 0)\n\t                            return BS_NEED_MORE\n\t                    }\n\t                }\n\t                s.insert = 0;\n\t                if (flush === Z_FINISH) {\n\t                    flush_block_only(s, true);\n\t                    if (s.strm.avail_out === 0)\n\t                        return BS_FINISH_STARTED;\n\t                    return BS_FINISH_DONE\n\t                }\n\t                if (s.last_lit) {\n\t                    flush_block_only(s, false);\n\t                    if (s.strm.avail_out === 0)\n\t                        return BS_NEED_MORE\n\t                }\n\t                return BS_BLOCK_DONE\n\t            }\n\t            function deflate_huff(s, flush) {\n\t                var bflush;\n\t                for (; ; ) {\n\t                    if (s.lookahead === 0) {\n\t                        fill_window(s);\n\t                        if (s.lookahead === 0) {\n\t                            if (flush === Z_NO_FLUSH)\n\t                                return BS_NEED_MORE;\n\t                            break\n\t                        }\n\t                    }\n\t                    s.match_length = 0;\n\t                    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\t                    s.lookahead--;\n\t                    s.strstart++;\n\t                    if (bflush) {\n\t                        flush_block_only(s, false);\n\t                        if (s.strm.avail_out === 0)\n\t                            return BS_NEED_MORE\n\t                    }\n\t                }\n\t                s.insert = 0;\n\t                if (flush === Z_FINISH) {\n\t                    flush_block_only(s, true);\n\t                    if (s.strm.avail_out === 0)\n\t                        return BS_FINISH_STARTED;\n\t                    return BS_FINISH_DONE\n\t                }\n\t                if (s.last_lit) {\n\t                    flush_block_only(s, false);\n\t                    if (s.strm.avail_out === 0)\n\t                        return BS_NEED_MORE\n\t                }\n\t                return BS_BLOCK_DONE\n\t            }\n\t            var Config = function(good_length, max_lazy, nice_length, max_chain, func) {\n\t                this.good_length = good_length;\n\t                this.max_lazy = max_lazy;\n\t                this.nice_length = nice_length;\n\t                this.max_chain = max_chain;\n\t                this.func = func\n\t            };\n\t            var configuration_table;\n\t            configuration_table = [new Config(0,0,0,0,deflate_stored), new Config(4,4,8,4,deflate_fast), new Config(4,5,16,8,deflate_fast), new Config(4,6,32,32,deflate_fast), new Config(4,4,16,16,deflate_slow), new Config(8,16,32,32,deflate_slow), new Config(8,16,128,128,deflate_slow), new Config(8,32,128,256,deflate_slow), new Config(32,128,258,1024,deflate_slow), new Config(32,258,258,4096,deflate_slow)];\n\t            function lm_init(s) {\n\t                s.window_size = 2 * s.w_size;\n\t                zero(s.head);\n\t                s.max_lazy_match = configuration_table[s.level].max_lazy;\n\t                s.good_match = configuration_table[s.level].good_length;\n\t                s.nice_match = configuration_table[s.level].nice_length;\n\t                s.max_chain_length = configuration_table[s.level].max_chain;\n\t                s.strstart = 0;\n\t                s.block_start = 0;\n\t                s.lookahead = 0;\n\t                s.insert = 0;\n\t                s.match_length = s.prev_length = MIN_MATCH - 1;\n\t                s.match_available = 0;\n\t                s.ins_h = 0\n\t            }\n\t            function DeflateState() {\n\t                this.strm = null;\n\t                this.status = 0;\n\t                this.pending_buf = null;\n\t                this.pending_buf_size = 0;\n\t                this.pending_out = 0;\n\t                this.pending = 0;\n\t                this.wrap = 0;\n\t                this.gzhead = null;\n\t                this.gzindex = 0;\n\t                this.method = Z_DEFLATED;\n\t                this.last_flush = -1;\n\t                this.w_size = 0;\n\t                this.w_bits = 0;\n\t                this.w_mask = 0;\n\t                this.window = null;\n\t                this.window_size = 0;\n\t                this.prev = null;\n\t                this.head = null;\n\t                this.ins_h = 0;\n\t                this.hash_size = 0;\n\t                this.hash_bits = 0;\n\t                this.hash_mask = 0;\n\t                this.hash_shift = 0;\n\t                this.block_start = 0;\n\t                this.match_length = 0;\n\t                this.prev_match = 0;\n\t                this.match_available = 0;\n\t                this.strstart = 0;\n\t                this.match_start = 0;\n\t                this.lookahead = 0;\n\t                this.prev_length = 0;\n\t                this.max_chain_length = 0;\n\t                this.max_lazy_match = 0;\n\t                this.level = 0;\n\t                this.strategy = 0;\n\t                this.good_match = 0;\n\t                this.nice_match = 0;\n\t                this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);\n\t                this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);\n\t                this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);\n\t                zero(this.dyn_ltree);\n\t                zero(this.dyn_dtree);\n\t                zero(this.bl_tree);\n\t                this.l_desc = null;\n\t                this.d_desc = null;\n\t                this.bl_desc = null;\n\t                this.bl_count = new utils.Buf16(MAX_BITS + 1);\n\t                this.heap = new utils.Buf16(2 * L_CODES + 1);\n\t                zero(this.heap);\n\t                this.heap_len = 0;\n\t                this.heap_max = 0;\n\t                this.depth = new utils.Buf16(2 * L_CODES + 1);\n\t                zero(this.depth);\n\t                this.l_buf = 0;\n\t                this.lit_bufsize = 0;\n\t                this.last_lit = 0;\n\t                this.d_buf = 0;\n\t                this.opt_len = 0;\n\t                this.static_len = 0;\n\t                this.matches = 0;\n\t                this.insert = 0;\n\t                this.bi_buf = 0;\n\t                this.bi_valid = 0\n\t            }\n\t            function deflateResetKeep(strm) {\n\t                var s;\n\t                if (!strm || !strm.state)\n\t                    return err(strm, Z_STREAM_ERROR);\n\t                strm.total_in = strm.total_out = 0;\n\t                strm.data_type = Z_UNKNOWN;\n\t                s = strm.state;\n\t                s.pending = 0;\n\t                s.pending_out = 0;\n\t                if (s.wrap < 0)\n\t                    s.wrap = -s.wrap;\n\t                s.status = s.wrap ? INIT_STATE : BUSY_STATE;\n\t                strm.adler = s.wrap === 2 ? 0 : 1;\n\t                s.last_flush = Z_NO_FLUSH;\n\t                trees._tr_init(s);\n\t                return Z_OK\n\t            }\n\t            function deflateReset(strm) {\n\t                var ret = deflateResetKeep(strm);\n\t                if (ret === Z_OK)\n\t                    lm_init(strm.state);\n\t                return ret\n\t            }\n\t            function deflateSetHeader(strm, head) {\n\t                if (!strm || !strm.state)\n\t                    return Z_STREAM_ERROR;\n\t                if (strm.state.wrap !== 2)\n\t                    return Z_STREAM_ERROR;\n\t                strm.state.gzhead = head;\n\t                return Z_OK\n\t            }\n\t            function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n\t                if (!strm)\n\t                    return Z_STREAM_ERROR;\n\t                var wrap = 1;\n\t                if (level === Z_DEFAULT_COMPRESSION)\n\t                    level = 6;\n\t                if (windowBits < 0) {\n\t                    wrap = 0;\n\t                    windowBits = -windowBits\n\t                } else if (windowBits > 15) {\n\t                    wrap = 2;\n\t                    windowBits -= 16\n\t                }\n\t                if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED)\n\t                    return err(strm, Z_STREAM_ERROR);\n\t                if (windowBits === 8)\n\t                    windowBits = 9;\n\t                var s = new DeflateState;\n\t                strm.state = s;\n\t                s.strm = strm;\n\t                s.wrap = wrap;\n\t                s.gzhead = null;\n\t                s.w_bits = windowBits;\n\t                s.w_size = 1 << s.w_bits;\n\t                s.w_mask = s.w_size - 1;\n\t                s.hash_bits = memLevel + 7;\n\t                s.hash_size = 1 << s.hash_bits;\n\t                s.hash_mask = s.hash_size - 1;\n\t                s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\t                s.window = new utils.Buf8(s.w_size * 2);\n\t                s.head = new utils.Buf16(s.hash_size);\n\t                s.prev = new utils.Buf16(s.w_size);\n\t                s.lit_bufsize = 1 << memLevel + 6;\n\t                s.pending_buf_size = s.lit_bufsize * 4;\n\t                s.pending_buf = new utils.Buf8(s.pending_buf_size);\n\t                s.d_buf = s.lit_bufsize >> 1;\n\t                s.l_buf = (1 + 2) * s.lit_bufsize;\n\t                s.level = level;\n\t                s.strategy = strategy;\n\t                s.method = method;\n\t                return deflateReset(strm)\n\t            }\n\t            function deflateInit(strm, level) {\n\t                return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY)\n\t            }\n\t            function deflate(strm, flush) {\n\t                var old_flush, s;\n\t                var beg, val;\n\t                if (!strm || !strm.state || flush > Z_BLOCK || flush < 0)\n\t                    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n\t                s = strm.state;\n\t                if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH)\n\t                    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);\n\t                s.strm = strm;\n\t                old_flush = s.last_flush;\n\t                s.last_flush = flush;\n\t                if (s.status === INIT_STATE)\n\t                    if (s.wrap === 2) {\n\t                        strm.adler = 0;\n\t                        put_byte(s, 31);\n\t                        put_byte(s, 139);\n\t                        put_byte(s, 8);\n\t                        if (!s.gzhead) {\n\t                            put_byte(s, 0);\n\t                            put_byte(s, 0);\n\t                            put_byte(s, 0);\n\t                            put_byte(s, 0);\n\t                            put_byte(s, 0);\n\t                            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);\n\t                            put_byte(s, OS_CODE);\n\t                            s.status = BUSY_STATE\n\t                        } else {\n\t                            put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));\n\t                            put_byte(s, s.gzhead.time & 255);\n\t                            put_byte(s, s.gzhead.time >> 8 & 255);\n\t                            put_byte(s, s.gzhead.time >> 16 & 255);\n\t                            put_byte(s, s.gzhead.time >> 24 & 255);\n\t                            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);\n\t                            put_byte(s, s.gzhead.os & 255);\n\t                            if (s.gzhead.extra && s.gzhead.extra.length) {\n\t                                put_byte(s, s.gzhead.extra.length & 255);\n\t                                put_byte(s, s.gzhead.extra.length >> 8 & 255)\n\t                            }\n\t                            if (s.gzhead.hcrc)\n\t                                strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n\t                            s.gzindex = 0;\n\t                            s.status = EXTRA_STATE\n\t                        }\n\t                    } else {\n\t                        var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;\n\t                        var level_flags = -1;\n\t                        if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2)\n\t                            level_flags = 0;\n\t                        else if (s.level < 6)\n\t                            level_flags = 1;\n\t                        else if (s.level === 6)\n\t                            level_flags = 2;\n\t                        else\n\t                            level_flags = 3;\n\t                        header |= level_flags << 6;\n\t                        if (s.strstart !== 0)\n\t                            header |= PRESET_DICT;\n\t                        header += 31 - header % 31;\n\t                        s.status = BUSY_STATE;\n\t                        putShortMSB(s, header);\n\t                        if (s.strstart !== 0) {\n\t                            putShortMSB(s, strm.adler >>> 16);\n\t                            putShortMSB(s, strm.adler & 65535)\n\t                        }\n\t                        strm.adler = 1\n\t                    }\n\t                if (s.status === EXTRA_STATE)\n\t                    if (s.gzhead.extra) {\n\t                        beg = s.pending;\n\t                        while (s.gzindex < (s.gzhead.extra.length & 65535)) {\n\t                            if (s.pending === s.pending_buf_size) {\n\t                                if (s.gzhead.hcrc && s.pending > beg)\n\t                                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n\t                                flush_pending(strm);\n\t                                beg = s.pending;\n\t                                if (s.pending === s.pending_buf_size)\n\t                                    break\n\t                            }\n\t                            put_byte(s, s.gzhead.extra[s.gzindex] & 255);\n\t                            s.gzindex++\n\t                        }\n\t                        if (s.gzhead.hcrc && s.pending > beg)\n\t                            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n\t                        if (s.gzindex === s.gzhead.extra.length) {\n\t                            s.gzindex = 0;\n\t                            s.status = NAME_STATE\n\t                        }\n\t                    } else\n\t                        s.status = NAME_STATE;\n\t                if (s.status === NAME_STATE)\n\t                    if (s.gzhead.name) {\n\t                        beg = s.pending;\n\t                        do {\n\t                            if (s.pending === s.pending_buf_size) {\n\t                                if (s.gzhead.hcrc && s.pending > beg)\n\t                                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n\t                                flush_pending(strm);\n\t                                beg = s.pending;\n\t                                if (s.pending === s.pending_buf_size) {\n\t                                    val = 1;\n\t                                    break\n\t                                }\n\t                            }\n\t                            if (s.gzindex < s.gzhead.name.length)\n\t                                val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;\n\t                            else\n\t                                val = 0;\n\t                            put_byte(s, val)\n\t                        } while (val !== 0);\n\t                        if (s.gzhead.hcrc && s.pending > beg)\n\t                            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n\t                        if (val === 0) {\n\t                            s.gzindex = 0;\n\t                            s.status = COMMENT_STATE\n\t                        }\n\t                    } else\n\t                        s.status = COMMENT_STATE;\n\t                if (s.status === COMMENT_STATE)\n\t                    if (s.gzhead.comment) {\n\t                        beg = s.pending;\n\t                        do {\n\t                            if (s.pending === s.pending_buf_size) {\n\t                                if (s.gzhead.hcrc && s.pending > beg)\n\t                                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n\t                                flush_pending(strm);\n\t                                beg = s.pending;\n\t                                if (s.pending === s.pending_buf_size) {\n\t                                    val = 1;\n\t                                    break\n\t                                }\n\t                            }\n\t                            if (s.gzindex < s.gzhead.comment.length)\n\t                                val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;\n\t                            else\n\t                                val = 0;\n\t                            put_byte(s, val)\n\t                        } while (val !== 0);\n\t                        if (s.gzhead.hcrc && s.pending > beg)\n\t                            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n\t                        if (val === 0)\n\t                            s.status = HCRC_STATE\n\t                    } else\n\t                        s.status = HCRC_STATE;\n\t                if (s.status === HCRC_STATE)\n\t                    if (s.gzhead.hcrc) {\n\t                        if (s.pending + 2 > s.pending_buf_size)\n\t                            flush_pending(strm);\n\t                        if (s.pending + 2 <= s.pending_buf_size) {\n\t                            put_byte(s, strm.adler & 255);\n\t                            put_byte(s, strm.adler >> 8 & 255);\n\t                            strm.adler = 0;\n\t                            s.status = BUSY_STATE\n\t                        }\n\t                    } else\n\t                        s.status = BUSY_STATE;\n\t                if (s.pending !== 0) {\n\t                    flush_pending(strm);\n\t                    if (strm.avail_out === 0) {\n\t                        s.last_flush = -1;\n\t                        return Z_OK\n\t                    }\n\t                } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH)\n\t                    return err(strm, Z_BUF_ERROR);\n\t                if (s.status === FINISH_STATE && strm.avail_in !== 0)\n\t                    return err(strm, Z_BUF_ERROR);\n\t                if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {\n\t                    var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);\n\t                    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE)\n\t                        s.status = FINISH_STATE;\n\t                    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n\t                        if (strm.avail_out === 0)\n\t                            s.last_flush = -1;\n\t                        return Z_OK\n\t                    }\n\t                    if (bstate === BS_BLOCK_DONE) {\n\t                        if (flush === Z_PARTIAL_FLUSH)\n\t                            trees._tr_align(s);\n\t                        else if (flush !== Z_BLOCK) {\n\t                            trees._tr_stored_block(s, 0, 0, false);\n\t                            if (flush === Z_FULL_FLUSH) {\n\t                                zero(s.head);\n\t                                if (s.lookahead === 0) {\n\t                                    s.strstart = 0;\n\t                                    s.block_start = 0;\n\t                                    s.insert = 0\n\t                                }\n\t                            }\n\t                        }\n\t                        flush_pending(strm);\n\t                        if (strm.avail_out === 0) {\n\t                            s.last_flush = -1;\n\t                            return Z_OK\n\t                        }\n\t                    }\n\t                }\n\t                if (flush !== Z_FINISH)\n\t                    return Z_OK;\n\t                if (s.wrap <= 0)\n\t                    return Z_STREAM_END;\n\t                if (s.wrap === 2) {\n\t                    put_byte(s, strm.adler & 255);\n\t                    put_byte(s, strm.adler >> 8 & 255);\n\t                    put_byte(s, strm.adler >> 16 & 255);\n\t                    put_byte(s, strm.adler >> 24 & 255);\n\t                    put_byte(s, strm.total_in & 255);\n\t                    put_byte(s, strm.total_in >> 8 & 255);\n\t                    put_byte(s, strm.total_in >> 16 & 255);\n\t                    put_byte(s, strm.total_in >> 24 & 255)\n\t                } else {\n\t                    putShortMSB(s, strm.adler >>> 16);\n\t                    putShortMSB(s, strm.adler & 65535)\n\t                }\n\t                flush_pending(strm);\n\t                if (s.wrap > 0)\n\t                    s.wrap = -s.wrap;\n\t                return s.pending !== 0 ? Z_OK : Z_STREAM_END\n\t            }\n\t            function deflateEnd(strm) {\n\t                var status;\n\t                if (!strm || !strm.state)\n\t                    return Z_STREAM_ERROR;\n\t                status = strm.state.status;\n\t                if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE)\n\t                    return err(strm, Z_STREAM_ERROR);\n\t                strm.state = null;\n\t                return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK\n\t            }\n\t            exports.deflateInit = deflateInit;\n\t            exports.deflateInit2 = deflateInit2;\n\t            exports.deflateReset = deflateReset;\n\t            exports.deflateResetKeep = deflateResetKeep;\n\t            exports.deflateSetHeader = deflateSetHeader;\n\t            exports.deflate = deflate;\n\t            exports.deflateEnd = deflateEnd;\n\t            exports.deflateInfo = \"pako deflate (from Nodeca project)\"\n\t        }\n\t        , {\n\t            \"../utils/common\": 27,\n\t            \"./adler32\": 29,\n\t            \"./crc32\": 31,\n\t            \"./messages\": 37,\n\t            \"./trees\": 38\n\t        }],\n\t        33: [function(_dereq_, module, exports) {\n\t            function GZheader() {\n\t                this.text = 0;\n\t                this.time = 0;\n\t                this.xflags = 0;\n\t                this.os = 0;\n\t                this.extra = null;\n\t                this.extra_len = 0;\n\t                this.name = \"\";\n\t                this.comment = \"\";\n\t                this.hcrc = 0;\n\t                this.done = false\n\t            }\n\t            module.exports = GZheader\n\t        }\n\t        , {}],\n\t        34: [function(_dereq_, module, exports) {\n\t            var BAD = 30;\n\t            var TYPE = 12;\n\t            module.exports = function inflate_fast(strm, start) {\n\t                var state;\n\t                var _in;\n\t                var last;\n\t                var _out;\n\t                var beg;\n\t                var end;\n\t                var dmax;\n\t                var wsize;\n\t                var whave;\n\t                var wnext;\n\t                var window;\n\t                var hold;\n\t                var bits;\n\t                var lcode;\n\t                var dcode;\n\t                var lmask;\n\t                var dmask;\n\t                var here;\n\t                var op;\n\t                var len;\n\t                var dist;\n\t                var from;\n\t                var from_source;\n\t                var input, output;\n\t                state = strm.state;\n\t                _in = strm.next_in;\n\t                input = strm.input;\n\t                last = _in + (strm.avail_in - 5);\n\t                _out = strm.next_out;\n\t                output = strm.output;\n\t                beg = _out - (start - strm.avail_out);\n\t                end = _out + (strm.avail_out - 257);\n\t                dmax = state.dmax;\n\t                wsize = state.wsize;\n\t                whave = state.whave;\n\t                wnext = state.wnext;\n\t                window = state.window;\n\t                hold = state.hold;\n\t                bits = state.bits;\n\t                lcode = state.lencode;\n\t                dcode = state.distcode;\n\t                lmask = (1 << state.lenbits) - 1;\n\t                dmask = (1 << state.distbits) - 1;\n\t                top: do {\n\t                    if (bits < 15) {\n\t                        hold += input[_in++] << bits;\n\t                        bits += 8;\n\t                        hold += input[_in++] << bits;\n\t                        bits += 8\n\t                    }\n\t                    here = lcode[hold & lmask];\n\t                    dolen: for (; ; ) {\n\t                        op = here >>> 24;\n\t                        hold >>>= op;\n\t                        bits -= op;\n\t                        op = here >>> 16 & 255;\n\t                        if (op === 0)\n\t                            output[_out++] = here & 65535;\n\t                        else if (op & 16) {\n\t                            len = here & 65535;\n\t                            op &= 15;\n\t                            if (op) {\n\t                                if (bits < op) {\n\t                                    hold += input[_in++] << bits;\n\t                                    bits += 8\n\t                                }\n\t                                len += hold & (1 << op) - 1;\n\t                                hold >>>= op;\n\t                                bits -= op\n\t                            }\n\t                            if (bits < 15) {\n\t                                hold += input[_in++] << bits;\n\t                                bits += 8;\n\t                                hold += input[_in++] << bits;\n\t                                bits += 8\n\t                            }\n\t                            here = dcode[hold & dmask];\n\t                            dodist: for (; ; ) {\n\t                                op = here >>> 24;\n\t                                hold >>>= op;\n\t                                bits -= op;\n\t                                op = here >>> 16 & 255;\n\t                                if (op & 16) {\n\t                                    dist = here & 65535;\n\t                                    op &= 15;\n\t                                    if (bits < op) {\n\t                                        hold += input[_in++] << bits;\n\t                                        bits += 8;\n\t                                        if (bits < op) {\n\t                                            hold += input[_in++] << bits;\n\t                                            bits += 8\n\t                                        }\n\t                                    }\n\t                                    dist += hold & (1 << op) - 1;\n\t                                    if (dist > dmax) {\n\t                                        strm.msg = \"invalid distance too far back\";\n\t                                        state.mode = BAD;\n\t                                        break top\n\t                                    }\n\t                                    hold >>>= op;\n\t                                    bits -= op;\n\t                                    op = _out - beg;\n\t                                    if (dist > op) {\n\t                                        op = dist - op;\n\t                                        if (op > whave)\n\t                                            if (state.sane) {\n\t                                                strm.msg = \"invalid distance too far back\";\n\t                                                state.mode = BAD;\n\t                                                break top\n\t                                            }\n\t                                        from = 0;\n\t                                        from_source = window;\n\t                                        if (wnext === 0) {\n\t                                            from += wsize - op;\n\t                                            if (op < len) {\n\t                                                len -= op;\n\t                                                do\n\t                                                    output[_out++] = window[from++];\n\t                                                while (--op);\n\t                                                from = _out - dist;\n\t                                                from_source = output\n\t                                            }\n\t                                        } else if (wnext < op) {\n\t                                            from += wsize + wnext - op;\n\t                                            op -= wnext;\n\t                                            if (op < len) {\n\t                                                len -= op;\n\t                                                do\n\t                                                    output[_out++] = window[from++];\n\t                                                while (--op);\n\t                                                from = 0;\n\t                                                if (wnext < len) {\n\t                                                    op = wnext;\n\t                                                    len -= op;\n\t                                                    do\n\t                                                        output[_out++] = window[from++];\n\t                                                    while (--op);\n\t                                                    from = _out - dist;\n\t                                                    from_source = output\n\t                                                }\n\t                                            }\n\t                                        } else {\n\t                                            from += wnext - op;\n\t                                            if (op < len) {\n\t                                                len -= op;\n\t                                                do\n\t                                                    output[_out++] = window[from++];\n\t                                                while (--op);\n\t                                                from = _out - dist;\n\t                                                from_source = output\n\t                                            }\n\t                                        }\n\t                                        while (len > 2) {\n\t                                            output[_out++] = from_source[from++];\n\t                                            output[_out++] = from_source[from++];\n\t                                            output[_out++] = from_source[from++];\n\t                                            len -= 3\n\t                                        }\n\t                                        if (len) {\n\t                                            output[_out++] = from_source[from++];\n\t                                            if (len > 1)\n\t                                                output[_out++] = from_source[from++]\n\t                                        }\n\t                                    } else {\n\t                                        from = _out - dist;\n\t                                        do {\n\t                                            output[_out++] = output[from++];\n\t                                            output[_out++] = output[from++];\n\t                                            output[_out++] = output[from++];\n\t                                            len -= 3\n\t                                        } while (len > 2);\n\t                                        if (len) {\n\t                                            output[_out++] = output[from++];\n\t                                            if (len > 1)\n\t                                                output[_out++] = output[from++]\n\t                                        }\n\t                                    }\n\t                                } else if ((op & 64) === 0) {\n\t                                    here = dcode[(here & 65535) + (hold & (1 << op) - 1)];\n\t                                    continue dodist\n\t                                } else {\n\t                                    strm.msg = \"invalid distance code\";\n\t                                    state.mode = BAD;\n\t                                    break top\n\t                                }\n\t                                break\n\t                            }\n\t                        } else if ((op & 64) === 0) {\n\t                            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];\n\t                            continue dolen\n\t                        } else if (op & 32) {\n\t                            state.mode = TYPE;\n\t                            break top\n\t                        } else {\n\t                            strm.msg = \"invalid literal/length code\";\n\t                            state.mode = BAD;\n\t                            break top\n\t                        }\n\t                        break\n\t                    }\n\t                } while (_in < last && _out < end);\n\t                len = bits >> 3;\n\t                _in -= len;\n\t                bits -= len << 3;\n\t                hold &= (1 << bits) - 1;\n\t                strm.next_in = _in;\n\t                strm.next_out = _out;\n\t                strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);\n\t                strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);\n\t                state.hold = hold;\n\t                state.bits = bits;\n\t                return\n\t            }\n\t        }\n\t        , {}],\n\t        35: [function(_dereq_, module, exports) {\n\t            var utils = _dereq_(\"../utils/common\");\n\t            var adler32 = _dereq_(\"./adler32\");\n\t            var crc32 = _dereq_(\"./crc32\");\n\t            var inflate_fast = _dereq_(\"./inffast\");\n\t            var inflate_table = _dereq_(\"./inftrees\");\n\t            var CODES = 0;\n\t            var LENS = 1;\n\t            var DISTS = 2;\n\t            var Z_FINISH = 4;\n\t            var Z_BLOCK = 5;\n\t            var Z_TREES = 6;\n\t            var Z_OK = 0;\n\t            var Z_STREAM_END = 1;\n\t            var Z_NEED_DICT = 2;\n\t            var Z_STREAM_ERROR = -2;\n\t            var Z_DATA_ERROR = -3;\n\t            var Z_MEM_ERROR = -4;\n\t            var Z_BUF_ERROR = -5;\n\t            var Z_DEFLATED = 8;\n\t            var HEAD = 1;\n\t            var FLAGS = 2;\n\t            var TIME = 3;\n\t            var OS = 4;\n\t            var EXLEN = 5;\n\t            var EXTRA = 6;\n\t            var NAME = 7;\n\t            var COMMENT = 8;\n\t            var HCRC = 9;\n\t            var DICTID = 10;\n\t            var DICT = 11;\n\t            var TYPE = 12;\n\t            var TYPEDO = 13;\n\t            var STORED = 14;\n\t            var COPY_ = 15;\n\t            var COPY = 16;\n\t            var TABLE = 17;\n\t            var LENLENS = 18;\n\t            var CODELENS = 19;\n\t            var LEN_ = 20;\n\t            var LEN = 21;\n\t            var LENEXT = 22;\n\t            var DIST = 23;\n\t            var DISTEXT = 24;\n\t            var MATCH = 25;\n\t            var LIT = 26;\n\t            var CHECK = 27;\n\t            var LENGTH = 28;\n\t            var DONE = 29;\n\t            var BAD = 30;\n\t            var MEM = 31;\n\t            var SYNC = 32;\n\t            var ENOUGH_LENS = 852;\n\t            var ENOUGH_DISTS = 592;\n\t            var MAX_WBITS = 15;\n\t            var DEF_WBITS = MAX_WBITS;\n\t            function ZSWAP32(q) {\n\t                return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24)\n\t            }\n\t            function InflateState() {\n\t                this.mode = 0;\n\t                this.last = false;\n\t                this.wrap = 0;\n\t                this.havedict = false;\n\t                this.flags = 0;\n\t                this.dmax = 0;\n\t                this.check = 0;\n\t                this.total = 0;\n\t                this.head = null;\n\t                this.wbits = 0;\n\t                this.wsize = 0;\n\t                this.whave = 0;\n\t                this.wnext = 0;\n\t                this.window = null;\n\t                this.hold = 0;\n\t                this.bits = 0;\n\t                this.length = 0;\n\t                this.offset = 0;\n\t                this.extra = 0;\n\t                this.lencode = null;\n\t                this.distcode = null;\n\t                this.lenbits = 0;\n\t                this.distbits = 0;\n\t                this.ncode = 0;\n\t                this.nlen = 0;\n\t                this.ndist = 0;\n\t                this.have = 0;\n\t                this.next = null;\n\t                this.lens = new utils.Buf16(320);\n\t                this.work = new utils.Buf16(288);\n\t                this.lendyn = null;\n\t                this.distdyn = null;\n\t                this.sane = 0;\n\t                this.back = 0;\n\t                this.was = 0\n\t            }\n\t            function inflateResetKeep(strm) {\n\t                var state;\n\t                if (!strm || !strm.state)\n\t                    return Z_STREAM_ERROR;\n\t                state = strm.state;\n\t                strm.total_in = strm.total_out = state.total = 0;\n\t                strm.msg = \"\";\n\t                if (state.wrap)\n\t                    strm.adler = state.wrap & 1;\n\t                state.mode = HEAD;\n\t                state.last = 0;\n\t                state.havedict = 0;\n\t                state.dmax = 32768;\n\t                state.head = null;\n\t                state.hold = 0;\n\t                state.bits = 0;\n\t                state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);\n\t                state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);\n\t                state.sane = 1;\n\t                state.back = -1;\n\t                return Z_OK\n\t            }\n\t            function inflateReset(strm) {\n\t                var state;\n\t                if (!strm || !strm.state)\n\t                    return Z_STREAM_ERROR;\n\t                state = strm.state;\n\t                state.wsize = 0;\n\t                state.whave = 0;\n\t                state.wnext = 0;\n\t                return inflateResetKeep(strm)\n\t            }\n\t            function inflateReset2(strm, windowBits) {\n\t                var wrap;\n\t                var state;\n\t                if (!strm || !strm.state)\n\t                    return Z_STREAM_ERROR;\n\t                state = strm.state;\n\t                if (windowBits < 0) {\n\t                    wrap = 0;\n\t                    windowBits = -windowBits\n\t                } else {\n\t                    wrap = (windowBits >> 4) + 1;\n\t                    if (windowBits < 48)\n\t                        windowBits &= 15\n\t                }\n\t                if (windowBits && (windowBits < 8 || windowBits > 15))\n\t                    return Z_STREAM_ERROR;\n\t                if (state.window !== null && state.wbits !== windowBits)\n\t                    state.window = null;\n\t                state.wrap = wrap;\n\t                state.wbits = windowBits;\n\t                return inflateReset(strm)\n\t            }\n\t            function inflateInit2(strm, windowBits) {\n\t                var ret;\n\t                var state;\n\t                if (!strm)\n\t                    return Z_STREAM_ERROR;\n\t                state = new InflateState;\n\t                strm.state = state;\n\t                state.window = null;\n\t                ret = inflateReset2(strm, windowBits);\n\t                if (ret !== Z_OK)\n\t                    strm.state = null;\n\t                return ret\n\t            }\n\t            function inflateInit(strm) {\n\t                return inflateInit2(strm, DEF_WBITS)\n\t            }\n\t            var virgin = true;\n\t            var lenfix, distfix;\n\t            function fixedtables(state) {\n\t                if (virgin) {\n\t                    var sym;\n\t                    lenfix = new utils.Buf32(512);\n\t                    distfix = new utils.Buf32(32);\n\t                    sym = 0;\n\t                    while (sym < 144)\n\t                        state.lens[sym++] = 8;\n\t                    while (sym < 256)\n\t                        state.lens[sym++] = 9;\n\t                    while (sym < 280)\n\t                        state.lens[sym++] = 7;\n\t                    while (sym < 288)\n\t                        state.lens[sym++] = 8;\n\t                    inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {\n\t                        bits: 9\n\t                    });\n\t                    sym = 0;\n\t                    while (sym < 32)\n\t                        state.lens[sym++] = 5;\n\t                    inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {\n\t                        bits: 5\n\t                    });\n\t                    virgin = false\n\t                }\n\t                state.lencode = lenfix;\n\t                state.lenbits = 9;\n\t                state.distcode = distfix;\n\t                state.distbits = 5\n\t            }\n\t            function updatewindow(strm, src, end, copy) {\n\t                var dist;\n\t                var state = strm.state;\n\t                if (state.window === null) {\n\t                    state.wsize = 1 << state.wbits;\n\t                    state.wnext = 0;\n\t                    state.whave = 0;\n\t                    state.window = new utils.Buf8(state.wsize)\n\t                }\n\t                if (copy >= state.wsize) {\n\t                    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);\n\t                    state.wnext = 0;\n\t                    state.whave = state.wsize\n\t                } else {\n\t                    dist = state.wsize - state.wnext;\n\t                    if (dist > copy)\n\t                        dist = copy;\n\t                    utils.arraySet(state.window, src, end - copy, dist, state.wnext);\n\t                    copy -= dist;\n\t                    if (copy) {\n\t                        utils.arraySet(state.window, src, end - copy, copy, 0);\n\t                        state.wnext = copy;\n\t                        state.whave = state.wsize\n\t                    } else {\n\t                        state.wnext += dist;\n\t                        if (state.wnext === state.wsize)\n\t                            state.wnext = 0;\n\t                        if (state.whave < state.wsize)\n\t                            state.whave += dist\n\t                    }\n\t                }\n\t                return 0\n\t            }\n\t            function inflate(strm, flush) {\n\t                var state;\n\t                var input, output;\n\t                var next;\n\t                var put;\n\t                var have, left;\n\t                var hold;\n\t                var bits;\n\t                var _in, _out;\n\t                var copy;\n\t                var from;\n\t                var from_source;\n\t                var here = 0;\n\t                var here_bits, here_op, here_val;\n\t                var last_bits, last_op, last_val;\n\t                var len;\n\t                var ret;\n\t                var hbuf = new utils.Buf8(4);\n\t                var opts;\n\t                var n;\n\t                var order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n\t                if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0)\n\t                    return Z_STREAM_ERROR;\n\t                state = strm.state;\n\t                if (state.mode === TYPE)\n\t                    state.mode = TYPEDO;\n\t                put = strm.next_out;\n\t                output = strm.output;\n\t                left = strm.avail_out;\n\t                next = strm.next_in;\n\t                input = strm.input;\n\t                have = strm.avail_in;\n\t                hold = state.hold;\n\t                bits = state.bits;\n\t                _in = have;\n\t                _out = left;\n\t                ret = Z_OK;\n\t                inf_leave: for (; ; )\n\t                    switch (state.mode) {\n\t                    case HEAD:\n\t                        if (state.wrap === 0) {\n\t                            state.mode = TYPEDO;\n\t                            break\n\t                        }\n\t                        while (bits < 16) {\n\t                            if (have === 0)\n\t                                break inf_leave;\n\t                            have--;\n\t                            hold += input[next++] << bits;\n\t                            bits += 8\n\t                        }\n\t                        if (state.wrap & 2 && hold === 35615) {\n\t                            state.check = 0;\n\t                            hbuf[0] = hold & 255;\n\t                            hbuf[1] = hold >>> 8 & 255;\n\t                            state.check = crc32(state.check, hbuf, 2, 0);\n\t                            hold = 0;\n\t                            bits = 0;\n\t                            state.mode = FLAGS;\n\t                            break\n\t                        }\n\t                        state.flags = 0;\n\t                        if (state.head)\n\t                            state.head.done = false;\n\t                        if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {\n\t                            strm.msg = \"incorrect header check\";\n\t                            state.mode = BAD;\n\t                            break\n\t                        }\n\t                        if ((hold & 15) !== Z_DEFLATED) {\n\t                            strm.msg = \"unknown compression method\";\n\t                            state.mode = BAD;\n\t                            break\n\t                        }\n\t                        hold >>>= 4;\n\t                        bits -= 4;\n\t                        len = (hold & 15) + 8;\n\t                        if (state.wbits === 0)\n\t                            state.wbits = len;\n\t                        else if (len > state.wbits) {\n\t                            strm.msg = \"invalid window size\";\n\t                            state.mode = BAD;\n\t                            break\n\t                        }\n\t                        state.dmax = 1 << len;\n\t                        strm.adler = state.check = 1;\n\t                        state.mode = hold & 512 ? DICTID : TYPE;\n\t                        hold = 0;\n\t                        bits = 0;\n\t                        break;\n\t                    case FLAGS:\n\t                        while (bits < 16) {\n\t                            if (have === 0)\n\t                                break inf_leave;\n\t                            have--;\n\t                            hold += input[next++] << bits;\n\t                            bits += 8\n\t                        }\n\t                        state.flags = hold;\n\t                        if ((state.flags & 255) !== Z_DEFLATED) {\n\t                            strm.msg = \"unknown compression method\";\n\t                            state.mode = BAD;\n\t                            break\n\t                        }\n\t                        if (state.flags & 57344) {\n\t                            strm.msg = \"unknown header flags set\";\n\t                            state.mode = BAD;\n\t                            break\n\t                        }\n\t                        if (state.head)\n\t                            state.head.text = hold >> 8 & 1;\n\t                        if (state.flags & 512) {\n\t                            hbuf[0] = hold & 255;\n\t                            hbuf[1] = hold >>> 8 & 255;\n\t                            state.check = crc32(state.check, hbuf, 2, 0)\n\t                        }\n\t                        hold = 0;\n\t                        bits = 0;\n\t                        state.mode = TIME;\n\t                    case TIME:\n\t                        while (bits < 32) {\n\t                            if (have === 0)\n\t                                break inf_leave;\n\t                            have--;\n\t                            hold += input[next++] << bits;\n\t                            bits += 8\n\t                        }\n\t                        if (state.head)\n\t                            state.head.time = hold;\n\t                        if (state.flags & 512) {\n\t                            hbuf[0] = hold & 255;\n\t                            hbuf[1] = hold >>> 8 & 255;\n\t                            hbuf[2] = hold >>> 16 & 255;\n\t                            hbuf[3] = hold >>> 24 & 255;\n\t                            state.check = crc32(state.check, hbuf, 4, 0)\n\t                        }\n\t                        hold = 0;\n\t                        bits = 0;\n\t                        state.mode = OS;\n\t                    case OS:\n\t                        while (bits < 16) {\n\t                            if (have === 0)\n\t                                break inf_leave;\n\t                            have--;\n\t                            hold += input[next++] << bits;\n\t                            bits += 8\n\t                        }\n\t                        if (state.head) {\n\t                            state.head.xflags = hold & 255;\n\t                            state.head.os = hold >> 8\n\t                        }\n\t                        if (state.flags & 512) {\n\t                            hbuf[0] = hold & 255;\n\t                            hbuf[1] = hold >>> 8 & 255;\n\t                            state.check = crc32(state.check, hbuf, 2, 0)\n\t                        }\n\t                        hold = 0;\n\t                        bits = 0;\n\t                        state.mode = EXLEN;\n\t                    case EXLEN:\n\t                        if (state.flags & 1024) {\n\t                            while (bits < 16) {\n\t                                if (have === 0)\n\t                                    break inf_leave;\n\t                                have--;\n\t                                hold += input[next++] << bits;\n\t                                bits += 8\n\t                            }\n\t                            state.length = hold;\n\t                            if (state.head)\n\t                                state.head.extra_len = hold;\n\t                            if (state.flags & 512) {\n\t                                hbuf[0] = hold & 255;\n\t                                hbuf[1] = hold >>> 8 & 255;\n\t                                state.check = crc32(state.check, hbuf, 2, 0)\n\t                            }\n\t                            hold = 0;\n\t                            bits = 0\n\t                        } else if (state.head)\n\t                            state.head.extra = null;\n\t                        state.mode = EXTRA;\n\t                    case EXTRA:\n\t                        if (state.flags & 1024) {\n\t                            copy = state.length;\n\t                            if (copy > have)\n\t                                copy = have;\n\t                            if (copy) {\n\t                                if (state.head) {\n\t                                    len = state.head.extra_len - state.length;\n\t                                    if (!state.head.extra)\n\t                                        state.head.extra = new Array(state.head.extra_len);\n\t                                    utils.arraySet(state.head.extra, input, next, copy, len)\n\t                                }\n\t                                if (state.flags & 512)\n\t                                    state.check = crc32(state.check, input, copy, next);\n\t                                have -= copy;\n\t                                next += copy;\n\t                                state.length -= copy\n\t                            }\n\t                            if (state.length)\n\t                                break inf_leave\n\t                        }\n\t                        state.length = 0;\n\t                        state.mode = NAME;\n\t                    case NAME:\n\t                        if (state.flags & 2048) {\n\t                            if (have === 0)\n\t                                break inf_leave;\n\t                            copy = 0;\n\t                            do {\n\t                                len = input[next + copy++];\n\t                                if (state.head && len && state.length < 65536)\n\t                                    state.head.name += String.fromCharCode(len)\n\t                            } while (len && copy < have);\n\t                            if (state.flags & 512)\n\t                                state.check = crc32(state.check, input, copy, next);\n\t                            have -= copy;\n\t                            next += copy;\n\t                            if (len)\n\t                                break inf_leave\n\t                        } else if (state.head)\n\t                            state.head.name = null;\n\t                        state.length = 0;\n\t                        state.mode = COMMENT;\n\t                    case COMMENT:\n\t                        if (state.flags & 4096) {\n\t                            if (have === 0)\n\t                                break inf_leave;\n\t                            copy = 0;\n\t                            do {\n\t                                len = input[next + copy++];\n\t                                if (state.head && len && state.length < 65536)\n\t                                    state.head.comment += String.fromCharCode(len)\n\t                            } while (len && copy < have);\n\t                            if (state.flags & 512)\n\t                                state.check = crc32(state.check, input, copy, next);\n\t                            have -= copy;\n\t                            next += copy;\n\t                            if (len)\n\t                                break inf_leave\n\t                        } else if (state.head)\n\t                            state.head.comment = null;\n\t                        state.mode = HCRC;\n\t                    case HCRC:\n\t                        if (state.flags & 512) {\n\t                            while (bits < 16) {\n\t                                if (have === 0)\n\t                                    break inf_leave;\n\t                                have--;\n\t                                hold += input[next++] << bits;\n\t                                bits += 8\n\t                            }\n\t                            if (hold !== (state.check & 65535)) {\n\t                                strm.msg = \"header crc mismatch\";\n\t                                state.mode = BAD;\n\t                                break\n\t                            }\n\t                            hold = 0;\n\t                            bits = 0\n\t                        }\n\t                        if (state.head) {\n\t                            state.head.hcrc = state.flags >> 9 & 1;\n\t                            state.head.done = true\n\t                        }\n\t                        strm.adler = state.check = 0;\n\t                        state.mode = TYPE;\n\t                        break;\n\t                    case DICTID:\n\t                        while (bits < 32) {\n\t                            if (have === 0)\n\t                                break inf_leave;\n\t                            have--;\n\t                            hold += input[next++] << bits;\n\t                            bits += 8\n\t                        }\n\t                        strm.adler = state.check = ZSWAP32(hold);\n\t                        hold = 0;\n\t                        bits = 0;\n\t                        state.mode = DICT;\n\t                    case DICT:\n\t                        if (state.havedict === 0) {\n\t                            strm.next_out = put;\n\t                            strm.avail_out = left;\n\t                            strm.next_in = next;\n\t                            strm.avail_in = have;\n\t                            state.hold = hold;\n\t                            state.bits = bits;\n\t                            return Z_NEED_DICT\n\t                        }\n\t                        strm.adler = state.check = 1;\n\t                        state.mode = TYPE;\n\t                    case TYPE:\n\t                        if (flush === Z_BLOCK || flush === Z_TREES)\n\t                            break inf_leave;\n\t                    case TYPEDO:\n\t                        if (state.last) {\n\t                            hold >>>= bits & 7;\n\t                            bits -= bits & 7;\n\t                            state.mode = CHECK;\n\t                            break\n\t                        }\n\t                        while (bits < 3) {\n\t                            if (have === 0)\n\t                                break inf_leave;\n\t                            have--;\n\t                            hold += input[next++] << bits;\n\t                            bits += 8\n\t                        }\n\t                        state.last = hold & 1;\n\t                        hold >>>= 1;\n\t                        bits -= 1;\n\t                        switch (hold & 3) {\n\t                        case 0:\n\t                            state.mode = STORED;\n\t                            break;\n\t                        case 1:\n\t                            fixedtables(state);\n\t                            state.mode = LEN_;\n\t                            if (flush === Z_TREES) {\n\t                                hold >>>= 2;\n\t                                bits -= 2;\n\t                                break inf_leave\n\t                            }\n\t                            break;\n\t                        case 2:\n\t                            state.mode = TABLE;\n\t                            break;\n\t                        case 3:\n\t                            strm.msg = \"invalid block type\";\n\t                            state.mode = BAD\n\t                        }\n\t                        hold >>>= 2;\n\t                        bits -= 2;\n\t                        break;\n\t                    case STORED:\n\t                        hold >>>= bits & 7;\n\t                        bits -= bits & 7;\n\t                        while (bits < 32) {\n\t                            if (have === 0)\n\t                                break inf_leave;\n\t                            have--;\n\t                            hold += input[next++] << bits;\n\t                            bits += 8\n\t                        }\n\t                        if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {\n\t                            strm.msg = \"invalid stored block lengths\";\n\t                            state.mode = BAD;\n\t                            break\n\t                        }\n\t                        state.length = hold & 65535;\n\t                        hold = 0;\n\t                        bits = 0;\n\t                        state.mode = COPY_;\n\t                        if (flush === Z_TREES)\n\t                            break inf_leave;\n\t                    case COPY_:\n\t                        state.mode = COPY;\n\t                    case COPY:\n\t                        copy = state.length;\n\t                        if (copy) {\n\t                            if (copy > have)\n\t                                copy = have;\n\t                            if (copy > left)\n\t                                copy = left;\n\t                            if (copy === 0)\n\t                                break inf_leave;\n\t                            utils.arraySet(output, input, next, copy, put);\n\t                            have -= copy;\n\t                            next += copy;\n\t                            left -= copy;\n\t                            put += copy;\n\t                            state.length -= copy;\n\t                            break\n\t                        }\n\t                        state.mode = TYPE;\n\t                        break;\n\t                    case TABLE:\n\t                        while (bits < 14) {\n\t                            if (have === 0)\n\t                                break inf_leave;\n\t                            have--;\n\t                            hold += input[next++] << bits;\n\t                            bits += 8\n\t                        }\n\t                        state.nlen = (hold & 31) + 257;\n\t                        hold >>>= 5;\n\t                        bits -= 5;\n\t                        state.ndist = (hold & 31) + 1;\n\t                        hold >>>= 5;\n\t                        bits -= 5;\n\t                        state.ncode = (hold & 15) + 4;\n\t                        hold >>>= 4;\n\t                        bits -= 4;\n\t                        if (state.nlen > 286 || state.ndist > 30) {\n\t                            strm.msg = \"too many length or distance symbols\";\n\t                            state.mode = BAD;\n\t                            break\n\t                        }\n\t                        state.have = 0;\n\t                        state.mode = LENLENS;\n\t                    case LENLENS:\n\t                        while (state.have < state.ncode) {\n\t                            while (bits < 3) {\n\t                                if (have === 0)\n\t                                    break inf_leave;\n\t                                have--;\n\t                                hold += input[next++] << bits;\n\t                                bits += 8\n\t                            }\n\t                            state.lens[order[state.have++]] = hold & 7;\n\t                            hold >>>= 3;\n\t                            bits -= 3\n\t                        }\n\t                        while (state.have < 19)\n\t                            state.lens[order[state.have++]] = 0;\n\t                        state.lencode = state.lendyn;\n\t                        state.lenbits = 7;\n\t                        opts = {\n\t                            bits: state.lenbits\n\t                        };\n\t                        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);\n\t                        state.lenbits = opts.bits;\n\t                        if (ret) {\n\t                            strm.msg = \"invalid code lengths set\";\n\t                            state.mode = BAD;\n\t                            break\n\t                        }\n\t                        state.have = 0;\n\t                        state.mode = CODELENS;\n\t                    case CODELENS:\n\t                        while (state.have < state.nlen + state.ndist) {\n\t                            for (; ; ) {\n\t                                here = state.lencode[hold & (1 << state.lenbits) - 1];\n\t                                here_bits = here >>> 24;\n\t                                here_op = here >>> 16 & 255;\n\t                                here_val = here & 65535;\n\t                                if (here_bits <= bits)\n\t                                    break;\n\t                                if (have === 0)\n\t                                    break inf_leave;\n\t                                have--;\n\t                                hold += input[next++] << bits;\n\t                                bits += 8\n\t                            }\n\t                            if (here_val < 16) {\n\t                                hold >>>= here_bits;\n\t                                bits -= here_bits;\n\t                                state.lens[state.have++] = here_val\n\t                            } else {\n\t                                if (here_val === 16) {\n\t                                    n = here_bits + 2;\n\t                                    while (bits < n) {\n\t                                        if (have === 0)\n\t                                            break inf_leave;\n\t                                        have--;\n\t                                        hold += input[next++] << bits;\n\t                                        bits += 8\n\t                                    }\n\t                                    hold >>>= here_bits;\n\t                                    bits -= here_bits;\n\t                                    if (state.have === 0) {\n\t                                        strm.msg = \"invalid bit length repeat\";\n\t                                        state.mode = BAD;\n\t                                        break\n\t                                    }\n\t                                    len = state.lens[state.have - 1];\n\t                                    copy = 3 + (hold & 3);\n\t                                    hold >>>= 2;\n\t                                    bits -= 2\n\t                                } else if (here_val === 17) {\n\t                                    n = here_bits + 3;\n\t                                    while (bits < n) {\n\t                                        if (have === 0)\n\t                                            break inf_leave;\n\t                                        have--;\n\t                                        hold += input[next++] << bits;\n\t                                        bits += 8\n\t                                    }\n\t                                    hold >>>= here_bits;\n\t                                    bits -= here_bits;\n\t                                    len = 0;\n\t                                    copy = 3 + (hold & 7);\n\t                                    hold >>>= 3;\n\t                                    bits -= 3\n\t                                } else {\n\t                                    n = here_bits + 7;\n\t                                    while (bits < n) {\n\t                                        if (have === 0)\n\t                                            break inf_leave;\n\t                                        have--;\n\t                                        hold += input[next++] << bits;\n\t                                        bits += 8\n\t                                    }\n\t                                    hold >>>= here_bits;\n\t                                    bits -= here_bits;\n\t                                    len = 0;\n\t                                    copy = 11 + (hold & 127);\n\t                                    hold >>>= 7;\n\t                                    bits -= 7\n\t                                }\n\t                                if (state.have + copy > state.nlen + state.ndist) {\n\t                                    strm.msg = \"invalid bit length repeat\";\n\t                                    state.mode = BAD;\n\t                                    break\n\t                                }\n\t                                while (copy--)\n\t                                    state.lens[state.have++] = len\n\t                            }\n\t                        }\n\t                        if (state.mode === BAD)\n\t                            break;\n\t                        if (state.lens[256] === 0) {\n\t                            strm.msg = \"invalid code -- missing end-of-block\";\n\t                            state.mode = BAD;\n\t                            break\n\t                        }\n\t                        state.lenbits = 9;\n\t                        opts = {\n\t                            bits: state.lenbits\n\t                        };\n\t                        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);\n\t                        state.lenbits = opts.bits;\n\t                        if (ret) {\n\t                            strm.msg = \"invalid literal/lengths set\";\n\t                            state.mode = BAD;\n\t                            break\n\t                        }\n\t                        state.distbits = 6;\n\t                        state.distcode = state.distdyn;\n\t                        opts = {\n\t                            bits: state.distbits\n\t                        };\n\t                        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);\n\t                        state.distbits = opts.bits;\n\t                        if (ret) {\n\t                            strm.msg = \"invalid distances set\";\n\t                            state.mode = BAD;\n\t                            break\n\t                        }\n\t                        state.mode = LEN_;\n\t                        if (flush === Z_TREES)\n\t                            break inf_leave;\n\t                    case LEN_:\n\t                        state.mode = LEN;\n\t                    case LEN:\n\t                        if (have >= 6 && left >= 258) {\n\t                            strm.next_out = put;\n\t                            strm.avail_out = left;\n\t                            strm.next_in = next;\n\t                            strm.avail_in = have;\n\t                            state.hold = hold;\n\t                            state.bits = bits;\n\t                            inflate_fast(strm, _out);\n\t                            put = strm.next_out;\n\t                            output = strm.output;\n\t                            left = strm.avail_out;\n\t                            next = strm.next_in;\n\t                            input = strm.input;\n\t                            have = strm.avail_in;\n\t                            hold = state.hold;\n\t                            bits = state.bits;\n\t                            if (state.mode === TYPE)\n\t                                state.back = -1;\n\t                            break\n\t                        }\n\t                        state.back = 0;\n\t                        for (; ; ) {\n\t                            here = state.lencode[hold & (1 << state.lenbits) - 1];\n\t                            here_bits = here >>> 24;\n\t                            here_op = here >>> 16 & 255;\n\t                            here_val = here & 65535;\n\t                            if (here_bits <= bits)\n\t                                break;\n\t                            if (have === 0)\n\t                                break inf_leave;\n\t                            have--;\n\t                            hold += input[next++] << bits;\n\t                            bits += 8\n\t                        }\n\t                        if (here_op && (here_op & 240) === 0) {\n\t                            last_bits = here_bits;\n\t                            last_op = here_op;\n\t                            last_val = here_val;\n\t                            for (; ; ) {\n\t                                here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];\n\t                                here_bits = here >>> 24;\n\t                                here_op = here >>> 16 & 255;\n\t                                here_val = here & 65535;\n\t                                if (last_bits + here_bits <= bits)\n\t                                    break;\n\t                                if (have === 0)\n\t                                    break inf_leave;\n\t                                have--;\n\t                                hold += input[next++] << bits;\n\t                                bits += 8\n\t                            }\n\t                            hold >>>= last_bits;\n\t                            bits -= last_bits;\n\t                            state.back += last_bits\n\t                        }\n\t                        hold >>>= here_bits;\n\t                        bits -= here_bits;\n\t                        state.back += here_bits;\n\t                        state.length = here_val;\n\t                        if (here_op === 0) {\n\t                            state.mode = LIT;\n\t                            break\n\t                        }\n\t                        if (here_op & 32) {\n\t                            state.back = -1;\n\t                            state.mode = TYPE;\n\t                            break\n\t                        }\n\t                        if (here_op & 64) {\n\t                            strm.msg = \"invalid literal/length code\";\n\t                            state.mode = BAD;\n\t                            break\n\t                        }\n\t                        state.extra = here_op & 15;\n\t                        state.mode = LENEXT;\n\t                    case LENEXT:\n\t                        if (state.extra) {\n\t                            n = state.extra;\n\t                            while (bits < n) {\n\t                                if (have === 0)\n\t                                    break inf_leave;\n\t                                have--;\n\t                                hold += input[next++] << bits;\n\t                                bits += 8\n\t                            }\n\t                            state.length += hold & (1 << state.extra) - 1;\n\t                            hold >>>= state.extra;\n\t                            bits -= state.extra;\n\t                            state.back += state.extra\n\t                        }\n\t                        state.was = state.length;\n\t                        state.mode = DIST;\n\t                    case DIST:\n\t                        for (; ; ) {\n\t                            here = state.distcode[hold & (1 << state.distbits) - 1];\n\t                            here_bits = here >>> 24;\n\t                            here_op = here >>> 16 & 255;\n\t                            here_val = here & 65535;\n\t                            if (here_bits <= bits)\n\t                                break;\n\t                            if (have === 0)\n\t                                break inf_leave;\n\t                            have--;\n\t                            hold += input[next++] << bits;\n\t                            bits += 8\n\t                        }\n\t                        if ((here_op & 240) === 0) {\n\t                            last_bits = here_bits;\n\t                            last_op = here_op;\n\t                            last_val = here_val;\n\t                            for (; ; ) {\n\t                                here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];\n\t                                here_bits = here >>> 24;\n\t                                here_op = here >>> 16 & 255;\n\t                                here_val = here & 65535;\n\t                                if (last_bits + here_bits <= bits)\n\t                                    break;\n\t                                if (have === 0)\n\t                                    break inf_leave;\n\t                                have--;\n\t                                hold += input[next++] << bits;\n\t                                bits += 8\n\t                            }\n\t                            hold >>>= last_bits;\n\t                            bits -= last_bits;\n\t                            state.back += last_bits\n\t                        }\n\t                        hold >>>= here_bits;\n\t                        bits -= here_bits;\n\t                        state.back += here_bits;\n\t                        if (here_op & 64) {\n\t                            strm.msg = \"invalid distance code\";\n\t                            state.mode = BAD;\n\t                            break\n\t                        }\n\t                        state.offset = here_val;\n\t                        state.extra = here_op & 15;\n\t                        state.mode = DISTEXT;\n\t                    case DISTEXT:\n\t                        if (state.extra) {\n\t                            n = state.extra;\n\t                            while (bits < n) {\n\t                                if (have === 0)\n\t                                    break inf_leave;\n\t                                have--;\n\t                                hold += input[next++] << bits;\n\t                                bits += 8\n\t                            }\n\t                            state.offset += hold & (1 << state.extra) - 1;\n\t                            hold >>>= state.extra;\n\t                            bits -= state.extra;\n\t                            state.back += state.extra\n\t                        }\n\t                        if (state.offset > state.dmax) {\n\t                            strm.msg = \"invalid distance too far back\";\n\t                            state.mode = BAD;\n\t                            break\n\t                        }\n\t                        state.mode = MATCH;\n\t                    case MATCH:\n\t                        if (left === 0)\n\t                            break inf_leave;\n\t                        copy = _out - left;\n\t                        if (state.offset > copy) {\n\t                            copy = state.offset - copy;\n\t                            if (copy > state.whave)\n\t                                if (state.sane) {\n\t                                    strm.msg = \"invalid distance too far back\";\n\t                                    state.mode = BAD;\n\t                                    break\n\t                                }\n\t                            if (copy > state.wnext) {\n\t                                copy -= state.wnext;\n\t                                from = state.wsize - copy\n\t                            } else\n\t                                from = state.wnext - copy;\n\t                            if (copy > state.length)\n\t                                copy = state.length;\n\t                            from_source = state.window\n\t                        } else {\n\t                            from_source = output;\n\t                            from = put - state.offset;\n\t                            copy = state.length\n\t                        }\n\t                        if (copy > left)\n\t                            copy = left;\n\t                        left -= copy;\n\t                        state.length -= copy;\n\t                        do\n\t                            output[put++] = from_source[from++];\n\t                        while (--copy);\n\t                        if (state.length === 0)\n\t                            state.mode = LEN;\n\t                        break;\n\t                    case LIT:\n\t                        if (left === 0)\n\t                            break inf_leave;\n\t                        output[put++] = state.length;\n\t                        left--;\n\t                        state.mode = LEN;\n\t                        break;\n\t                    case CHECK:\n\t                        if (state.wrap) {\n\t                            while (bits < 32) {\n\t                                if (have === 0)\n\t                                    break inf_leave;\n\t                                have--;\n\t                                hold |= input[next++] << bits;\n\t                                bits += 8\n\t                            }\n\t                            _out -= left;\n\t                            strm.total_out += _out;\n\t                            state.total += _out;\n\t                            if (_out)\n\t                                strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);\n\t                            _out = left;\n\t                            if ((state.flags ? hold : ZSWAP32(hold)) !== state.check) {\n\t                                strm.msg = \"incorrect data check\";\n\t                                state.mode = BAD;\n\t                                break\n\t                            }\n\t                            hold = 0;\n\t                            bits = 0\n\t                        }\n\t                        state.mode = LENGTH;\n\t                    case LENGTH:\n\t                        if (state.wrap && state.flags) {\n\t                            while (bits < 32) {\n\t                                if (have === 0)\n\t                                    break inf_leave;\n\t                                have--;\n\t                                hold += input[next++] << bits;\n\t                                bits += 8\n\t                            }\n\t                            if (hold !== (state.total & 4294967295)) {\n\t                                strm.msg = \"incorrect length check\";\n\t                                state.mode = BAD;\n\t                                break\n\t                            }\n\t                            hold = 0;\n\t                            bits = 0\n\t                        }\n\t                        state.mode = DONE;\n\t                    case DONE:\n\t                        ret = Z_STREAM_END;\n\t                        break inf_leave;\n\t                    case BAD:\n\t                        ret = Z_DATA_ERROR;\n\t                        break inf_leave;\n\t                    case MEM:\n\t                        return Z_MEM_ERROR;\n\t                    case SYNC:\n\t                    default:\n\t                        return Z_STREAM_ERROR\n\t                    }\n\t                strm.next_out = put;\n\t                strm.avail_out = left;\n\t                strm.next_in = next;\n\t                strm.avail_in = have;\n\t                state.hold = hold;\n\t                state.bits = bits;\n\t                if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH))\n\t                    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {\n\t                        state.mode = MEM;\n\t                        return Z_MEM_ERROR\n\t                    }\n\t                _in -= strm.avail_in;\n\t                _out -= strm.avail_out;\n\t                strm.total_in += _in;\n\t                strm.total_out += _out;\n\t                state.total += _out;\n\t                if (state.wrap && _out)\n\t                    strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);\n\t                strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);\n\t                if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK)\n\t                    ret = Z_BUF_ERROR;\n\t                return ret\n\t            }\n\t            function inflateEnd(strm) {\n\t                if (!strm || !strm.state)\n\t                    return Z_STREAM_ERROR;\n\t                var state = strm.state;\n\t                if (state.window)\n\t                    state.window = null;\n\t                strm.state = null;\n\t                return Z_OK\n\t            }\n\t            function inflateGetHeader(strm, head) {\n\t                var state;\n\t                if (!strm || !strm.state)\n\t                    return Z_STREAM_ERROR;\n\t                state = strm.state;\n\t                if ((state.wrap & 2) === 0)\n\t                    return Z_STREAM_ERROR;\n\t                state.head = head;\n\t                head.done = false;\n\t                return Z_OK\n\t            }\n\t            exports.inflateReset = inflateReset;\n\t            exports.inflateReset2 = inflateReset2;\n\t            exports.inflateResetKeep = inflateResetKeep;\n\t            exports.inflateInit = inflateInit;\n\t            exports.inflateInit2 = inflateInit2;\n\t            exports.inflate = inflate;\n\t            exports.inflateEnd = inflateEnd;\n\t            exports.inflateGetHeader = inflateGetHeader;\n\t            exports.inflateInfo = \"pako inflate (from Nodeca project)\"\n\t        }\n\t        , {\n\t            \"../utils/common\": 27,\n\t            \"./adler32\": 29,\n\t            \"./crc32\": 31,\n\t            \"./inffast\": 34,\n\t            \"./inftrees\": 36\n\t        }],\n\t        36: [function(_dereq_, module, exports) {\n\t            var utils = _dereq_(\"../utils/common\");\n\t            var MAXBITS = 15;\n\t            var ENOUGH_LENS = 852;\n\t            var ENOUGH_DISTS = 592;\n\t            var CODES = 0;\n\t            var LENS = 1;\n\t            var DISTS = 2;\n\t            var lbase = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];\n\t            var lext = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78];\n\t            var dbase = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0];\n\t            var dext = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];\n\t            module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {\n\t                var bits = opts.bits;\n\t                var len = 0;\n\t                var sym = 0;\n\t                var min = 0\n\t                  , max = 0;\n\t                var root = 0;\n\t                var curr = 0;\n\t                var drop = 0;\n\t                var left = 0;\n\t                var used = 0;\n\t                var huff = 0;\n\t                var incr;\n\t                var fill;\n\t                var low;\n\t                var mask;\n\t                var next;\n\t                var base = null;\n\t                var base_index = 0;\n\t                var end;\n\t                var count = new utils.Buf16(MAXBITS + 1);\n\t                var offs = new utils.Buf16(MAXBITS + 1);\n\t                var extra = null;\n\t                var extra_index = 0;\n\t                var here_bits, here_op, here_val;\n\t                for (len = 0; len <= MAXBITS; len++)\n\t                    count[len] = 0;\n\t                for (sym = 0; sym < codes; sym++)\n\t                    count[lens[lens_index + sym]]++;\n\t                root = bits;\n\t                for (max = MAXBITS; max >= 1; max--)\n\t                    if (count[max] !== 0)\n\t                        break;\n\t                if (root > max)\n\t                    root = max;\n\t                if (max === 0) {\n\t                    table[table_index++] = 1 << 24 | 64 << 16 | 0;\n\t                    table[table_index++] = 1 << 24 | 64 << 16 | 0;\n\t                    opts.bits = 1;\n\t                    return 0\n\t                }\n\t                for (min = 1; min < max; min++)\n\t                    if (count[min] !== 0)\n\t                        break;\n\t                if (root < min)\n\t                    root = min;\n\t                left = 1;\n\t                for (len = 1; len <= MAXBITS; len++) {\n\t                    left <<= 1;\n\t                    left -= count[len];\n\t                    if (left < 0)\n\t                        return -1\n\t                }\n\t                if (left > 0 && (type === CODES || max !== 1))\n\t                    return -1;\n\t                offs[1] = 0;\n\t                for (len = 1; len < MAXBITS; len++)\n\t                    offs[len + 1] = offs[len] + count[len];\n\t                for (sym = 0; sym < codes; sym++)\n\t                    if (lens[lens_index + sym] !== 0)\n\t                        work[offs[lens[lens_index + sym]]++] = sym;\n\t                if (type === CODES) {\n\t                    base = extra = work;\n\t                    end = 19\n\t                } else if (type === LENS) {\n\t                    base = lbase;\n\t                    base_index -= 257;\n\t                    extra = lext;\n\t                    extra_index -= 257;\n\t                    end = 256\n\t                } else {\n\t                    base = dbase;\n\t                    extra = dext;\n\t                    end = -1\n\t                }\n\t                huff = 0;\n\t                sym = 0;\n\t                len = min;\n\t                next = table_index;\n\t                curr = root;\n\t                drop = 0;\n\t                low = -1;\n\t                used = 1 << root;\n\t                mask = used - 1;\n\t                if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS)\n\t                    return 1;\n\t                var i = 0;\n\t                for (; ; ) {\n\t                    i++;\n\t                    here_bits = len - drop;\n\t                    if (work[sym] < end) {\n\t                        here_op = 0;\n\t                        here_val = work[sym]\n\t                    } else if (work[sym] > end) {\n\t                        here_op = extra[extra_index + work[sym]];\n\t                        here_val = base[base_index + work[sym]]\n\t                    } else {\n\t                        here_op = 32 + 64;\n\t                        here_val = 0\n\t                    }\n\t                    incr = 1 << len - drop;\n\t                    fill = 1 << curr;\n\t                    min = fill;\n\t                    do {\n\t                        fill -= incr;\n\t                        table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0\n\t                    } while (fill !== 0);\n\t                    incr = 1 << len - 1;\n\t                    while (huff & incr)\n\t                        incr >>= 1;\n\t                    if (incr !== 0) {\n\t                        huff &= incr - 1;\n\t                        huff += incr\n\t                    } else\n\t                        huff = 0;\n\t                    sym++;\n\t                    if (--count[len] === 0) {\n\t                        if (len === max)\n\t                            break;\n\t                        len = lens[lens_index + work[sym]]\n\t                    }\n\t                    if (len > root && (huff & mask) !== low) {\n\t                        if (drop === 0)\n\t                            drop = root;\n\t                        next += min;\n\t                        curr = len - drop;\n\t                        left = 1 << curr;\n\t                        while (curr + drop < max) {\n\t                            left -= count[curr + drop];\n\t                            if (left <= 0)\n\t                                break;\n\t                            curr++;\n\t                            left <<= 1\n\t                        }\n\t                        used += 1 << curr;\n\t                        if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS)\n\t                            return 1;\n\t                        low = huff & mask;\n\t                        table[low] = root << 24 | curr << 16 | next - table_index | 0\n\t                    }\n\t                }\n\t                if (huff !== 0)\n\t                    table[next + huff] = len - drop << 24 | 64 << 16 | 0;\n\t                opts.bits = root;\n\t                return 0\n\t            }\n\t        }\n\t        , {\n\t            \"../utils/common\": 27\n\t        }],\n\t        37: [function(_dereq_, module, exports) {\n\t            module.exports = {\n\t                2: \"need dictionary\",\n\t                1: \"stream end\",\n\t                0: \"\",\n\t                \"-1\": \"file error\",\n\t                \"-2\": \"stream error\",\n\t                \"-3\": \"data error\",\n\t                \"-4\": \"insufficient memory\",\n\t                \"-5\": \"buffer error\",\n\t                \"-6\": \"incompatible version\"\n\t            }\n\t        }\n\t        , {}],\n\t        38: [function(_dereq_, module, exports) {\n\t            var utils = _dereq_(\"../utils/common\");\n\t            var Z_FIXED = 4;\n\t            var Z_BINARY = 0;\n\t            var Z_TEXT = 1;\n\t            var Z_UNKNOWN = 2;\n\t            function zero(buf) {\n\t                var len = buf.length;\n\t                while (--len >= 0)\n\t                    buf[len] = 0\n\t            }\n\t            var STORED_BLOCK = 0;\n\t            var STATIC_TREES = 1;\n\t            var DYN_TREES = 2;\n\t            var MIN_MATCH = 3;\n\t            var MAX_MATCH = 258;\n\t            var LENGTH_CODES = 29;\n\t            var LITERALS = 256;\n\t            var L_CODES = LITERALS + 1 + LENGTH_CODES;\n\t            var D_CODES = 30;\n\t            var BL_CODES = 19;\n\t            var HEAP_SIZE = 2 * L_CODES + 1;\n\t            var MAX_BITS = 15;\n\t            var Buf_size = 16;\n\t            var MAX_BL_BITS = 7;\n\t            var END_BLOCK = 256;\n\t            var REP_3_6 = 16;\n\t            var REPZ_3_10 = 17;\n\t            var REPZ_11_138 = 18;\n\t            var extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];\n\t            var extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];\n\t            var extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];\n\t            var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n\t            var DIST_CODE_LEN = 512;\n\t            var static_ltree = new Array((L_CODES + 2) * 2);\n\t            zero(static_ltree);\n\t            var static_dtree = new Array(D_CODES * 2);\n\t            zero(static_dtree);\n\t            var _dist_code = new Array(DIST_CODE_LEN);\n\t            zero(_dist_code);\n\t            var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);\n\t            zero(_length_code);\n\t            var base_length = new Array(LENGTH_CODES);\n\t            zero(base_length);\n\t            var base_dist = new Array(D_CODES);\n\t            zero(base_dist);\n\t            var StaticTreeDesc = function(static_tree, extra_bits, extra_base, elems, max_length) {\n\t                this.static_tree = static_tree;\n\t                this.extra_bits = extra_bits;\n\t                this.extra_base = extra_base;\n\t                this.elems = elems;\n\t                this.max_length = max_length;\n\t                this.has_stree = static_tree && static_tree.length\n\t            };\n\t            var static_l_desc;\n\t            var static_d_desc;\n\t            var static_bl_desc;\n\t            var TreeDesc = function(dyn_tree, stat_desc) {\n\t                this.dyn_tree = dyn_tree;\n\t                this.max_code = 0;\n\t                this.stat_desc = stat_desc\n\t            };\n\t            function d_code(dist) {\n\t                return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)]\n\t            }\n\t            function put_short(s, w) {\n\t                s.pending_buf[s.pending++] = w & 255;\n\t                s.pending_buf[s.pending++] = w >>> 8 & 255\n\t            }\n\t            function send_bits(s, value, length) {\n\t                if (s.bi_valid > Buf_size - length) {\n\t                    s.bi_buf |= value << s.bi_valid & 65535;\n\t                    put_short(s, s.bi_buf);\n\t                    s.bi_buf = value >> Buf_size - s.bi_valid;\n\t                    s.bi_valid += length - Buf_size\n\t                } else {\n\t                    s.bi_buf |= value << s.bi_valid & 65535;\n\t                    s.bi_valid += length\n\t                }\n\t            }\n\t            function send_code(s, c, tree) {\n\t                send_bits(s, tree[c * 2], tree[c * 2 + 1])\n\t            }\n\t            function bi_reverse(code, len) {\n\t                var res = 0;\n\t                do {\n\t                    res |= code & 1;\n\t                    code >>>= 1;\n\t                    res <<= 1\n\t                } while (--len > 0);\n\t                return res >>> 1\n\t            }\n\t            function bi_flush(s) {\n\t                if (s.bi_valid === 16) {\n\t                    put_short(s, s.bi_buf);\n\t                    s.bi_buf = 0;\n\t                    s.bi_valid = 0\n\t                } else if (s.bi_valid >= 8) {\n\t                    s.pending_buf[s.pending++] = s.bi_buf & 255;\n\t                    s.bi_buf >>= 8;\n\t                    s.bi_valid -= 8\n\t                }\n\t            }\n\t            function gen_bitlen(s, desc) {\n\t                var tree = desc.dyn_tree;\n\t                var max_code = desc.max_code;\n\t                var stree = desc.stat_desc.static_tree;\n\t                var has_stree = desc.stat_desc.has_stree;\n\t                var extra = desc.stat_desc.extra_bits;\n\t                var base = desc.stat_desc.extra_base;\n\t                var max_length = desc.stat_desc.max_length;\n\t                var h;\n\t                var n, m;\n\t                var bits;\n\t                var xbits;\n\t                var f;\n\t                var overflow = 0;\n\t                for (bits = 0; bits <= MAX_BITS; bits++)\n\t                    s.bl_count[bits] = 0;\n\t                tree[s.heap[s.heap_max] * 2 + 1] = 0;\n\t                for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n\t                    n = s.heap[h];\n\t                    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;\n\t                    if (bits > max_length) {\n\t                        bits = max_length;\n\t                        overflow++\n\t                    }\n\t                    tree[n * 2 + 1] = bits;\n\t                    if (n > max_code)\n\t                        continue;\n\t                    s.bl_count[bits]++;\n\t                    xbits = 0;\n\t                    if (n >= base)\n\t                        xbits = extra[n - base];\n\t                    f = tree[n * 2];\n\t                    s.opt_len += f * (bits + xbits);\n\t                    if (has_stree)\n\t                        s.static_len += f * (stree[n * 2 + 1] + xbits)\n\t                }\n\t                if (overflow === 0)\n\t                    return;\n\t                do {\n\t                    bits = max_length - 1;\n\t                    while (s.bl_count[bits] === 0)\n\t                        bits--;\n\t                    s.bl_count[bits]--;\n\t                    s.bl_count[bits + 1] += 2;\n\t                    s.bl_count[max_length]--;\n\t                    overflow -= 2\n\t                } while (overflow > 0);\n\t                for (bits = max_length; bits !== 0; bits--) {\n\t                    n = s.bl_count[bits];\n\t                    while (n !== 0) {\n\t                        m = s.heap[--h];\n\t                        if (m > max_code)\n\t                            continue;\n\t                        if (tree[m * 2 + 1] !== bits) {\n\t                            s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];\n\t                            tree[m * 2 + 1] = bits\n\t                        }\n\t                        n--\n\t                    }\n\t                }\n\t            }\n\t            function gen_codes(tree, max_code, bl_count) {\n\t                var next_code = new Array(MAX_BITS + 1);\n\t                var code = 0;\n\t                var bits;\n\t                var n;\n\t                for (bits = 1; bits <= MAX_BITS; bits++)\n\t                    next_code[bits] = code = code + bl_count[bits - 1] << 1;\n\t                for (n = 0; n <= max_code; n++) {\n\t                    var len = tree[n * 2 + 1];\n\t                    if (len === 0)\n\t                        continue;\n\t                    tree[n * 2] = bi_reverse(next_code[len]++, len)\n\t                }\n\t            }\n\t            function tr_static_init() {\n\t                var n;\n\t                var bits;\n\t                var length;\n\t                var code;\n\t                var dist;\n\t                var bl_count = new Array(MAX_BITS + 1);\n\t                length = 0;\n\t                for (code = 0; code < LENGTH_CODES - 1; code++) {\n\t                    base_length[code] = length;\n\t                    for (n = 0; n < 1 << extra_lbits[code]; n++)\n\t                        _length_code[length++] = code\n\t                }\n\t                _length_code[length - 1] = code;\n\t                dist = 0;\n\t                for (code = 0; code < 16; code++) {\n\t                    base_dist[code] = dist;\n\t                    for (n = 0; n < 1 << extra_dbits[code]; n++)\n\t                        _dist_code[dist++] = code\n\t                }\n\t                dist >>= 7;\n\t                for (; code < D_CODES; code++) {\n\t                    base_dist[code] = dist << 7;\n\t                    for (n = 0; n < 1 << extra_dbits[code] - 7; n++)\n\t                        _dist_code[256 + dist++] = code\n\t                }\n\t                for (bits = 0; bits <= MAX_BITS; bits++)\n\t                    bl_count[bits] = 0;\n\t                n = 0;\n\t                while (n <= 143) {\n\t                    static_ltree[n * 2 + 1] = 8;\n\t                    n++;\n\t                    bl_count[8]++\n\t                }\n\t                while (n <= 255) {\n\t                    static_ltree[n * 2 + 1] = 9;\n\t                    n++;\n\t                    bl_count[9]++\n\t                }\n\t                while (n <= 279) {\n\t                    static_ltree[n * 2 + 1] = 7;\n\t                    n++;\n\t                    bl_count[7]++\n\t                }\n\t                while (n <= 287) {\n\t                    static_ltree[n * 2 + 1] = 8;\n\t                    n++;\n\t                    bl_count[8]++\n\t                }\n\t                gen_codes(static_ltree, L_CODES + 1, bl_count);\n\t                for (n = 0; n < D_CODES; n++) {\n\t                    static_dtree[n * 2 + 1] = 5;\n\t                    static_dtree[n * 2] = bi_reverse(n, 5)\n\t                }\n\t                static_l_desc = new StaticTreeDesc(static_ltree,extra_lbits,LITERALS + 1,L_CODES,MAX_BITS);\n\t                static_d_desc = new StaticTreeDesc(static_dtree,extra_dbits,0,D_CODES,MAX_BITS);\n\t                static_bl_desc = new StaticTreeDesc(new Array(0),extra_blbits,0,BL_CODES,MAX_BL_BITS)\n\t            }\n\t            function init_block(s) {\n\t                var n;\n\t                for (n = 0; n < L_CODES; n++)\n\t                    s.dyn_ltree[n * 2] = 0;\n\t                for (n = 0; n < D_CODES; n++)\n\t                    s.dyn_dtree[n * 2] = 0;\n\t                for (n = 0; n < BL_CODES; n++)\n\t                    s.bl_tree[n * 2] = 0;\n\t                s.dyn_ltree[END_BLOCK * 2] = 1;\n\t                s.opt_len = s.static_len = 0;\n\t                s.last_lit = s.matches = 0\n\t            }\n\t            function bi_windup(s) {\n\t                if (s.bi_valid > 8)\n\t                    put_short(s, s.bi_buf);\n\t                else if (s.bi_valid > 0)\n\t                    s.pending_buf[s.pending++] = s.bi_buf;\n\t                s.bi_buf = 0;\n\t                s.bi_valid = 0\n\t            }\n\t            function copy_block(s, buf, len, header) {\n\t                bi_windup(s);\n\t                if (header) {\n\t                    put_short(s, len);\n\t                    put_short(s, ~len)\n\t                }\n\t                utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);\n\t                s.pending += len\n\t            }\n\t            function smaller(tree, n, m, depth) {\n\t                var _n2 = n * 2;\n\t                var _m2 = m * 2;\n\t                return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m]\n\t            }\n\t            function pqdownheap(s, tree, k) {\n\t                var v = s.heap[k];\n\t                var j = k << 1;\n\t                while (j <= s.heap_len) {\n\t                    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth))\n\t                        j++;\n\t                    if (smaller(tree, v, s.heap[j], s.depth))\n\t                        break;\n\t                    s.heap[k] = s.heap[j];\n\t                    k = j;\n\t                    j <<= 1\n\t                }\n\t                s.heap[k] = v\n\t            }\n\t            function compress_block(s, ltree, dtree) {\n\t                var dist;\n\t                var lc;\n\t                var lx = 0;\n\t                var code;\n\t                var extra;\n\t                if (s.last_lit !== 0) {\n\t                    do {\n\t                        dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];\n\t                        lc = s.pending_buf[s.l_buf + lx];\n\t                        lx++;\n\t                        if (dist === 0)\n\t                            send_code(s, lc, ltree);\n\t                        else {\n\t                            code = _length_code[lc];\n\t                            send_code(s, code + LITERALS + 1, ltree);\n\t                            extra = extra_lbits[code];\n\t                            if (extra !== 0) {\n\t                                lc -= base_length[code];\n\t                                send_bits(s, lc, extra)\n\t                            }\n\t                            dist--;\n\t                            code = d_code(dist);\n\t                            send_code(s, code, dtree);\n\t                            extra = extra_dbits[code];\n\t                            if (extra !== 0) {\n\t                                dist -= base_dist[code];\n\t                                send_bits(s, dist, extra)\n\t                            }\n\t                        }\n\t                    } while (lx < s.last_lit)\n\t                }\n\t                send_code(s, END_BLOCK, ltree)\n\t            }\n\t            function build_tree(s, desc) {\n\t                var tree = desc.dyn_tree;\n\t                var stree = desc.stat_desc.static_tree;\n\t                var has_stree = desc.stat_desc.has_stree;\n\t                var elems = desc.stat_desc.elems;\n\t                var n, m;\n\t                var max_code = -1;\n\t                var node;\n\t                s.heap_len = 0;\n\t                s.heap_max = HEAP_SIZE;\n\t                for (n = 0; n < elems; n++)\n\t                    if (tree[n * 2] !== 0) {\n\t                        s.heap[++s.heap_len] = max_code = n;\n\t                        s.depth[n] = 0\n\t                    } else\n\t                        tree[n * 2 + 1] = 0;\n\t                while (s.heap_len < 2) {\n\t                    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;\n\t                    tree[node * 2] = 1;\n\t                    s.depth[node] = 0;\n\t                    s.opt_len--;\n\t                    if (has_stree)\n\t                        s.static_len -= stree[node * 2 + 1]\n\t                }\n\t                desc.max_code = max_code;\n\t                for (n = s.heap_len >> 1; n >= 1; n--)\n\t                    pqdownheap(s, tree, n);\n\t                node = elems;\n\t                do {\n\t                    n = s.heap[1];\n\t                    s.heap[1] = s.heap[s.heap_len--];\n\t                    pqdownheap(s, tree, 1);\n\t                    m = s.heap[1];\n\t                    s.heap[--s.heap_max] = n;\n\t                    s.heap[--s.heap_max] = m;\n\t                    tree[node * 2] = tree[n * 2] + tree[m * 2];\n\t                    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n\t                    tree[n * 2 + 1] = tree[m * 2 + 1] = node;\n\t                    s.heap[1] = node++;\n\t                    pqdownheap(s, tree, 1)\n\t                } while (s.heap_len >= 2);\n\t                s.heap[--s.heap_max] = s.heap[1];\n\t                gen_bitlen(s, desc);\n\t                gen_codes(tree, max_code, s.bl_count)\n\t            }\n\t            function scan_tree(s, tree, max_code) {\n\t                var n;\n\t                var prevlen = -1;\n\t                var curlen;\n\t                var nextlen = tree[0 * 2 + 1];\n\t                var count = 0;\n\t                var max_count = 7;\n\t                var min_count = 4;\n\t                if (nextlen === 0) {\n\t                    max_count = 138;\n\t                    min_count = 3\n\t                }\n\t                tree[(max_code + 1) * 2 + 1] = 65535;\n\t                for (n = 0; n <= max_code; n++) {\n\t                    curlen = nextlen;\n\t                    nextlen = tree[(n + 1) * 2 + 1];\n\t                    if (++count < max_count && curlen === nextlen)\n\t                        continue;\n\t                    else if (count < min_count)\n\t                        s.bl_tree[curlen * 2] += count;\n\t                    else if (curlen !== 0) {\n\t                        if (curlen !== prevlen)\n\t                            s.bl_tree[curlen * 2]++;\n\t                        s.bl_tree[REP_3_6 * 2]++\n\t                    } else if (count <= 10)\n\t                        s.bl_tree[REPZ_3_10 * 2]++;\n\t                    else\n\t                        s.bl_tree[REPZ_11_138 * 2]++;\n\t                    count = 0;\n\t                    prevlen = curlen;\n\t                    if (nextlen === 0) {\n\t                        max_count = 138;\n\t                        min_count = 3\n\t                    } else if (curlen === nextlen) {\n\t                        max_count = 6;\n\t                        min_count = 3\n\t                    } else {\n\t                        max_count = 7;\n\t                        min_count = 4\n\t                    }\n\t                }\n\t            }\n\t            function send_tree(s, tree, max_code) {\n\t                var n;\n\t                var prevlen = -1;\n\t                var curlen;\n\t                var nextlen = tree[0 * 2 + 1];\n\t                var count = 0;\n\t                var max_count = 7;\n\t                var min_count = 4;\n\t                if (nextlen === 0) {\n\t                    max_count = 138;\n\t                    min_count = 3\n\t                }\n\t                for (n = 0; n <= max_code; n++) {\n\t                    curlen = nextlen;\n\t                    nextlen = tree[(n + 1) * 2 + 1];\n\t                    if (++count < max_count && curlen === nextlen)\n\t                        continue;\n\t                    else if (count < min_count) {\n\t                        do\n\t                            send_code(s, curlen, s.bl_tree);\n\t                        while (--count !== 0)\n\t                    } else if (curlen !== 0) {\n\t                        if (curlen !== prevlen) {\n\t                            send_code(s, curlen, s.bl_tree);\n\t                            count--\n\t                        }\n\t                        send_code(s, REP_3_6, s.bl_tree);\n\t                        send_bits(s, count - 3, 2)\n\t                    } else if (count <= 10) {\n\t                        send_code(s, REPZ_3_10, s.bl_tree);\n\t                        send_bits(s, count - 3, 3)\n\t                    } else {\n\t                        send_code(s, REPZ_11_138, s.bl_tree);\n\t                        send_bits(s, count - 11, 7)\n\t                    }\n\t                    count = 0;\n\t                    prevlen = curlen;\n\t                    if (nextlen === 0) {\n\t                        max_count = 138;\n\t                        min_count = 3\n\t                    } else if (curlen === nextlen) {\n\t                        max_count = 6;\n\t                        min_count = 3\n\t                    } else {\n\t                        max_count = 7;\n\t                        min_count = 4\n\t                    }\n\t                }\n\t            }\n\t            function build_bl_tree(s) {\n\t                var max_blindex;\n\t                scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n\t                scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n\t                build_tree(s, s.bl_desc);\n\t                for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--)\n\t                    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0)\n\t                        break;\n\t                s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n\t                return max_blindex\n\t            }\n\t            function send_all_trees(s, lcodes, dcodes, blcodes) {\n\t                var rank;\n\t                send_bits(s, lcodes - 257, 5);\n\t                send_bits(s, dcodes - 1, 5);\n\t                send_bits(s, blcodes - 4, 4);\n\t                for (rank = 0; rank < blcodes; rank++)\n\t                    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);\n\t                send_tree(s, s.dyn_ltree, lcodes - 1);\n\t                send_tree(s, s.dyn_dtree, dcodes - 1)\n\t            }\n\t            function detect_data_type(s) {\n\t                var black_mask = 4093624447;\n\t                var n;\n\t                for (n = 0; n <= 31; n++,\n\t                black_mask >>>= 1)\n\t                    if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0)\n\t                        return Z_BINARY;\n\t                if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0)\n\t                    return Z_TEXT;\n\t                for (n = 32; n < LITERALS; n++)\n\t                    if (s.dyn_ltree[n * 2] !== 0)\n\t                        return Z_TEXT;\n\t                return Z_BINARY\n\t            }\n\t            var static_init_done = false;\n\t            function _tr_init(s) {\n\t                if (!static_init_done) {\n\t                    tr_static_init();\n\t                    static_init_done = true\n\t                }\n\t                s.l_desc = new TreeDesc(s.dyn_ltree,static_l_desc);\n\t                s.d_desc = new TreeDesc(s.dyn_dtree,static_d_desc);\n\t                s.bl_desc = new TreeDesc(s.bl_tree,static_bl_desc);\n\t                s.bi_buf = 0;\n\t                s.bi_valid = 0;\n\t                init_block(s)\n\t            }\n\t            function _tr_stored_block(s, buf, stored_len, last) {\n\t                send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);\n\t                copy_block(s, buf, stored_len, true)\n\t            }\n\t            function _tr_align(s) {\n\t                send_bits(s, STATIC_TREES << 1, 3);\n\t                send_code(s, END_BLOCK, static_ltree);\n\t                bi_flush(s)\n\t            }\n\t            function _tr_flush_block(s, buf, stored_len, last) {\n\t                var opt_lenb, static_lenb;\n\t                var max_blindex = 0;\n\t                if (s.level > 0) {\n\t                    if (s.strm.data_type === Z_UNKNOWN)\n\t                        s.strm.data_type = detect_data_type(s);\n\t                    build_tree(s, s.l_desc);\n\t                    build_tree(s, s.d_desc);\n\t                    max_blindex = build_bl_tree(s);\n\t                    opt_lenb = s.opt_len + 3 + 7 >>> 3;\n\t                    static_lenb = s.static_len + 3 + 7 >>> 3;\n\t                    if (static_lenb <= opt_lenb)\n\t                        opt_lenb = static_lenb\n\t                } else\n\t                    opt_lenb = static_lenb = stored_len + 5;\n\t                if (stored_len + 4 <= opt_lenb && buf !== -1)\n\t                    _tr_stored_block(s, buf, stored_len, last);\n\t                else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n\t                    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n\t                    compress_block(s, static_ltree, static_dtree)\n\t                } else {\n\t                    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n\t                    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n\t                    compress_block(s, s.dyn_ltree, s.dyn_dtree)\n\t                }\n\t                init_block(s);\n\t                if (last)\n\t                    bi_windup(s)\n\t            }\n\t            function _tr_tally(s, dist, lc) {\n\t                s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;\n\t                s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;\n\t                s.pending_buf[s.l_buf + s.last_lit] = lc & 255;\n\t                s.last_lit++;\n\t                if (dist === 0)\n\t                    s.dyn_ltree[lc * 2]++;\n\t                else {\n\t                    s.matches++;\n\t                    dist--;\n\t                    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;\n\t                    s.dyn_dtree[d_code(dist) * 2]++\n\t                }\n\t                return s.last_lit === s.lit_bufsize - 1\n\t            }\n\t            exports._tr_init = _tr_init;\n\t            exports._tr_stored_block = _tr_stored_block;\n\t            exports._tr_flush_block = _tr_flush_block;\n\t            exports._tr_tally = _tr_tally;\n\t            exports._tr_align = _tr_align\n\t        }\n\t        , {\n\t            \"../utils/common\": 27\n\t        }],\n\t        39: [function(_dereq_, module, exports) {\n\t            function ZStream() {\n\t                this.input = null;\n\t                this.next_in = 0;\n\t                this.avail_in = 0;\n\t                this.total_in = 0;\n\t                this.output = null;\n\t                this.next_out = 0;\n\t                this.avail_out = 0;\n\t                this.total_out = 0;\n\t                this.msg = \"\";\n\t                this.state = null;\n\t                this.data_type = 2;\n\t                this.adler = 0\n\t            }\n\t            module.exports = ZStream\n\t        }\n\t        , {}]\n\t    }, {}, [9])(9)\n\t});\n\n\treturn {\n\t\truntime,\n\t\todf\n\t}\n});\ndefine('skylark-webodf/main',[\r\n\t\"skylark-langx-ns\",\r\n\t\"./webodf\"\r\n],function(skylark,webodf) {\r\n\treturn skylark.attach(\"intg.webodf\",webodf)\r\n});\ndefine('skylark-webodf', ['skylark-webodf/main'], function (main) { return main; });\n\n"]}